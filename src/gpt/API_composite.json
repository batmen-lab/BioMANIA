{
    "scanpy.tl.ingest": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\nto cells and columns to genes. This is the dataset without labels and\nembeddings.",
                "optional_value": true
            },
            "adata_ref": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\nto cells and columns to genes.\nVariables (`n_vars` and `var_names`) of `adata_ref` should be the same\nas in `adata`.\nThis is the dataset with labels and embeddings\nwhich need to be mapped to `adata`.",
                "optional_value": true
            },
            "obs": {
                "type": "Optional[Union[str, Iterable[str]]]",
                "default": "None",
                "optional": true,
                "description": "Labels' keys in `adata_ref.obs` which need to be mapped to `adata.obs`\n(inferred for observation of `adata`).",
                "optional_value": false
            },
            "embedding_method": {
                "type": "Union[str, Iterable[str]]",
                "default": "('umap', 'pca')",
                "optional": true,
                "description": "Embeddings in `adata_ref` which need to be mapped to `adata`.\nThe only supported values are 'umap' and 'pca'.",
                "optional_value": false
            },
            "labeling_method": {
                "type": "str",
                "default": "knn",
                "optional": true,
                "description": "The method to map labels in `adata_ref.obs` to `adata.obs`.\nThe only supported value is 'knn'.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, ingest looks adata_ref.uns['neighbors']\nfor neighbors settings and adata_ref.obsp['distances'] for\ndistances (default storage places for pp.neighbors).\nIf specified, ingest looks adata_ref.uns[neighbors_key] for\nneighbors settings and\nadata_ref.obsp[adata_ref.uns[neighbors_key]['distances_key']] for distances.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Only works if `return_joint=False`.\nAdd labels and embeddings to the passed `adata` (if `True`)\nor return a copy of `adata` with mapped embeddings and labels.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "* if `inplace=False` returns a copy of `adata`\nwith mapped embeddings and labels in `obsm` and `obs` correspondingly\n* if `inplace=True` returns `None` and updates `adata.obsm` and `adata.obs`\nwith mapped embeddings and labels"
        },
        "Docstring": "Map labels and embeddings from reference data to new data.\n\n:tutorial:`integrating-data-using-ingest`\n\nIntegrates embeddings and annotations of an `adata` with a reference dataset\n`adata_ref` through projecting on a PCA (or alternate\nmodel) that has been fitted on the reference data. The function uses a knn\nclassifier for mapping labels and the UMAP package [McInnes18]_ for mapping\nthe embeddings.\n\n.. note::\n\n    We refer to this *asymmetric* dataset integration as *ingesting*\n    annotations from reference data to new data. This is different from\n    learning a joint representation that integrates both datasets in an\n    unbiased way, as CCA (e.g. in Seurat) or a conditional VAE (e.g. in\n    scVI) would do.\n\nYou need to run :func:`~scanpy.pp.neighbors` on `adata_ref` before\npassing it.\n\nParameters\n----------\nadata\n    The annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\n    to cells and columns to genes. This is the dataset without labels and\n    embeddings.\nadata_ref\n    The annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\n    to cells and columns to genes.\n    Variables (`n_vars` and `var_names`) of `adata_ref` should be the same\n    as in `adata`.\n    This is the dataset with labels and embeddings\n    which need to be mapped to `adata`.\nobs\n    Labels' keys in `adata_ref.obs` which need to be mapped to `adata.obs`\n    (inferred for observation of `adata`).\nembedding_method\n    Embeddings in `adata_ref` which need to be mapped to `adata`.\n    The only supported values are 'umap' and 'pca'.\nlabeling_method\n    The method to map labels in `adata_ref.obs` to `adata.obs`.\n    The only supported value is 'knn'.\nneighbors_key\n    If not specified, ingest looks adata_ref.uns['neighbors']\n    for neighbors settings and adata_ref.obsp['distances'] for\n    distances (default storage places for pp.neighbors).\n    If specified, ingest looks adata_ref.uns[neighbors_key] for\n    neighbors settings and\n    adata_ref.obsp[adata_ref.uns[neighbors_key]['distances_key']] for distances.\ninplace\n    Only works if `return_joint=False`.\n    Add labels and embeddings to the passed `adata` (if `True`)\n    or return a copy of `adata` with mapped embeddings and labels.\n\nReturns\n-------\n* if `inplace=False` returns a copy of `adata`\n  with mapped embeddings and labels in `obsm` and `obs` correspondingly\n* if `inplace=True` returns `None` and updates `adata.obsm` and `adata.obs`\n  with mapped embeddings and labels\n\nExample\n-------\nCall sequence:\n\n>>> import scanpy as sc\n>>> sc.pp.neighbors(adata_ref)\n>>> sc.tl.umap(adata_ref)\n>>> sc.tl.ingest(adata, adata_ref, obs='cell_type')\n\n.. _ingest PBMC tutorial: https://scanpy-tutorials.readthedocs.io/en/latest/integrating-pbmcs-using-ingest.html\n.. _ingest Pancreas tutorial: https://scanpy-tutorials.readthedocs.io/en/latest/integrating-pancreas-using-ingest.html",
        "description": "Map labels and embeddings from reference data to new data.:tutorial:`integrating-data-using-ingest`\n\nIntegrates embeddings and annotations of an `adata` with a reference dataset\n`adata_ref` through projecting on a PCA (or alternate\nmodel) that has been fitted on the reference data. The function uses a knn\nclassifier for mapping labels and the UMAP package [McInnes18]_ for mapping\nthe embeddings.\n\n.. note::\n\n    We refer to this *asymmetric* dataset integration as *ingesting*\n    annotations from reference data to new data. This is different from\n    learning a joint representation that integrates both datasets in an\n    unbiased way, as CCA (e.g. in Seurat) or a conditional VAE (e.g. in\n    scVI) would do.\n\nYou need to run :func:`~scanpy.pp.neighbors` on `adata_ref` before\npassing it.",
        "example": "Example\n-------\nCall sequence:\n\n>>> import scanpy as sc\n>>> sc.pp.neighbors(adata_ref)\n>>> sc.tl.umap(adata_ref)\n>>> sc.tl.ingest(adata, adata_ref, obs='cell_type')\n\n.. _ingest PBMC tutorial: https://scanpy-tutorials.readthedocs.io/en/latest/integrating-pbmcs-using-ingest.html\n.. _ingest Pancreas tutorial: https://scanpy-tutorials.readthedocs.io/en/latest/integrating-pancreas-using-ingest.html",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.ingest(adata=$, adata_ref=$, obs=@, embedding_method=@, labeling_method=@, neighbors_key=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.clustermap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "obs_keys": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Categorical annotation to plot with a different color map.\nCurrently, only a single key is supported.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `show` is `False`, a :class:`~seaborn.ClusterGrid` object\n(see :func:`~seaborn.clustermap`)."
        },
        "Docstring": "Hierarchically-clustered heatmap.\n\nWraps :func:`seaborn.clustermap` for :class:`~anndata.AnnData`.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nobs_keys\n    Categorical annotation to plot with a different color map.\n    Currently, only a single key is supported.\nuse_raw\n    Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n**kwds\n    Keyword arguments passed to :func:`~seaborn.clustermap`.\n\nReturns\n-------\nIf `show` is `False`, a :class:`~seaborn.ClusterGrid` object\n(see :func:`~seaborn.clustermap`).\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.krumsiek11()\n    sc.pl.clustermap(adata)\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.clustermap(adata, obs_keys='cell_type')",
        "description": "Hierarchically-clustered heatmap.Wraps :func:`seaborn.clustermap` for :class:`~anndata.AnnData`.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.krumsiek11()\n    sc.pl.clustermap(adata)\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.clustermap(adata, obs_keys='cell_type')",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.clustermap(adata=$, obs_keys=@, use_raw=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.palantir_results": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An AnnData object.",
                "optional_value": true
            },
            "early_cell": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Start cell for pseudotime construction.",
                "optional_value": false
            },
            "ms_data": {
                "type": "str",
                "default": "X_palantir_multiscale",
                "optional": true,
                "description": "Palantir multi scale data matrix,",
                "optional_value": false
            },
            "terminal_states": {
                "type": "List[]",
                "default": "None",
                "optional": true,
                "description": "List of user defined terminal states",
                "optional_value": false
            },
            "knn": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of nearest neighbors for graph construction.",
                "optional_value": false
            },
            "num_waypoints": {
                "type": "int",
                "default": "1200",
                "optional": true,
                "description": "Number of waypoints to sample.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "-1",
                "optional": true,
                "description": "Number of jobs for parallel processing.",
                "optional_value": false
            },
            "scale_components": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Transform features by scaling each feature to a given range. Consult the\ndocumentation for `sklearn.preprocessing.minmax_scale`.",
                "optional_value": false
            },
            "use_early_cell_as_start": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Use `early_cell` as `start_cell`, instead of determining it from the boundary\ncells closest to the defined `early_cell`.",
                "optional_value": false
            },
            "max_iterations": {
                "type": "int",
                "default": "25",
                "optional": true,
                "description": "Maximum number of iterations for pseudotime convergence.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "PResults\nPResults object with pseudotime, entropy, branch probabilities and waypoints."
        },
        "Docstring": "**Running Palantir**\n\nA convenience function that wraps `palantir.core.run_palantir` to compute branch\nprobabilities and waypoints.\n\nParameters\n----------\nadata\n    An AnnData object.\nearly_cell\n    Start cell for pseudotime construction.\nms_data\n    Palantir multi scale data matrix,\nterminal_states\n    List of user defined terminal states\nknn\n    Number of nearest neighbors for graph construction.\nnum_waypoints\n    Number of waypoints to sample.\nn_jobs\n    Number of jobs for parallel processing.\nscale_components\n    Transform features by scaling each feature to a given range. Consult the\n    documentation for `sklearn.preprocessing.minmax_scale`.\nuse_early_cell_as_start\n    Use `early_cell` as `start_cell`, instead of determining it from the boundary\n    cells closest to the defined `early_cell`.\nmax_iterations\n    Maximum number of iterations for pseudotime convergence.\n\nReturns\n-------\nPResults\n    PResults object with pseudotime, entropy, branch probabilities and waypoints.",
        "description": "**Running Palantir**A convenience function that wraps `palantir.core.run_palantir` to compute branch\nprobabilities and waypoints.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.palantir_results(adata=$, early_cell=@, ms_data=@, terminal_states=@, knn=@, num_waypoints=@, n_jobs=@, scale_components=@, use_early_cell_as_start=@, max_iterations=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_10x_mtx": {
        "Parameters": {
            "path": {
                "type": "Union[Path, str]",
                "default": null,
                "optional": false,
                "description": "Path to directory for `.mtx` and `.tsv` files,\ne.g. './filtered_gene_bc_matrices/hg19/'.",
                "optional_value": false
            },
            "var_names": {
                "type": "Literal[gene_symbols, gene_ids]",
                "default": "gene_symbols",
                "optional": true,
                "description": "The variables index.",
                "optional_value": true
            },
            "make_unique": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to make the variables index unique by appending '-1',\n'-2' etc. or not.",
                "optional_value": false
            },
            "cache": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `False`, read from source, if `True`, read from fast 'h5ad' cache.",
                "optional_value": false
            },
            "cache_compression": {
                "type": "Optional[Union[Literal[gzip, lzf], Empty]]",
                "default": "Empty.token",
                "optional": true,
                "description": "See the h5py :ref:`dataset_compression`.\n(Default: `settings.cache_compression`)",
                "optional_value": true
            },
            "gex_only": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Only keep 'Gene Expression' data and ignore other feature types,\ne.g. 'Antibody Capture', 'CRISPR Guide Capture', or 'Custom'",
                "optional_value": false
            },
            "prefix": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Any prefix before `matrix.mtx`, `genes.tsv` and `barcodes.tsv`. For instance,\nif the files are named `patientA_matrix.mtx`, `patientA_genes.tsv` and\n`patientA_barcodes.tsv` the prefix is `patientA_`.\n(Default: no prefix)",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "An :class:`~anndata.AnnData` object"
        },
        "Docstring": "Read 10x-Genomics-formatted mtx directory.\n\nParameters\n----------\npath\n    Path to directory for `.mtx` and `.tsv` files,\n    e.g. './filtered_gene_bc_matrices/hg19/'.\nvar_names\n    The variables index.\nmake_unique\n    Whether to make the variables index unique by appending '-1',\n    '-2' etc. or not.\ncache\n    If `False`, read from source, if `True`, read from fast 'h5ad' cache.\ncache_compression\n    See the h5py :ref:`dataset_compression`.\n    (Default: `settings.cache_compression`)\ngex_only\n    Only keep 'Gene Expression' data and ignore other feature types,\n    e.g. 'Antibody Capture', 'CRISPR Guide Capture', or 'Custom'\nprefix\n    Any prefix before `matrix.mtx`, `genes.tsv` and `barcodes.tsv`. For instance,\n    if the files are named `patientA_matrix.mtx`, `patientA_genes.tsv` and\n    `patientA_barcodes.tsv` the prefix is `patientA_`.\n    (Default: no prefix)\n\nReturns\n-------\nAn :class:`~anndata.AnnData` object",
        "description": "Read 10x-Genomics-formatted mtx directory.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_10x_mtx(path=@, var_names=$, make_unique=@, cache=@, cache_compression=$, gex_only=@, prefix=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.filter_genes_dispersion": {
        "Parameters": {
            "data": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\nto cells and columns to genes.",
                "optional_value": true
            },
            "flavor": {
                "type": "Literal[seurat, cell_ranger]",
                "default": "seurat",
                "optional": true,
                "description": "Choose the flavor for computing normalized dispersion. If choosing\n'seurat', this expects non-logarithmized data \u2013 the logarithm of mean\nand dispersion is taken internally when `log` is at its default value\n`True`. For 'cell_ranger', this is usually called for logarithmized data\n\u2013 in this case you should set `log` to `False`. In their default\nworkflows, Seurat passes the cutoffs whereas Cell Ranger passes\n`n_top_genes`.",
                "optional_value": true
            },
            "min_disp": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": false
            },
            "max_disp": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If `n_top_genes` unequals `None`, these cutoffs for the means and the\nnormalized dispersions are ignored.",
                "optional_value": false
            },
            "min_mean": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": false
            },
            "max_mean": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": false
            },
            "n_bins": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of bins for binning the mean gene expression. Normalization is\ndone with respect to each bin. If just a single gene falls into a bin,\nthe normalized dispersion is artificially set to 1. You'll be informed\nabout this if you set `settings.verbosity = 4`.",
                "optional_value": false
            },
            "n_top_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of highly-variable genes to keep.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Use the logarithm of the mean to variance ratio.",
                "optional_value": false
            },
            "subset": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Keep highly-variable genes only (if True) else write a bool array for h\nighly-variable genes while keeping all genes",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If an :class:`~anndata.AnnData` is passed, determines whether a copy\nis returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If an AnnData `adata` is passed, returns or updates `adata` depending on\n`copy`. It filters the `adata` and adds the annotations\n**means** : adata.var\nMeans per gene. Logarithmized when `log` is `True`.\n**dispersions** : adata.var\nDispersions per gene. Logarithmized when `log` is `True`.\n**dispersions_norm** : adata.var\nNormalized dispersions per gene. Logarithmized when `log` is `True`.\nIf a data matrix `X` is passed, the annotation is returned as `np.recarray`\nwith the same information stored in fields: `gene_subset`, `means`, `dispersions`, `dispersion_norm`."
        },
        "Docstring": "Extract highly variable genes [Satija15]_ [Zheng17]_.\n\n.. warning::\n    .. deprecated:: 1.3.6\n        Use :func:`~scanpy.pp.highly_variable_genes`\n        instead. The new function is equivalent to the present\n        function, except that\n\n        * the new function always expects logarithmized data\n        * `subset=False` in the new function, it suffices to\n          merely annotate the genes, tools like `pp.pca` will\n          detect the annotation\n        * you can now call: `sc.pl.highly_variable_genes(adata)`\n        * `copy` is replaced by `inplace`\n\nIf trying out parameters, pass the data matrix instead of AnnData.\n\nDepending on `flavor`, this reproduces the R-implementations of Seurat\n[Satija15]_ and Cell Ranger [Zheng17]_.\n\nThe normalized dispersion is obtained by scaling with the mean and standard\ndeviation of the dispersions for genes falling into a given bin for mean\nexpression of genes. This means that for each bin of mean expression, highly\nvariable genes are selected.\n\nUse `flavor='cell_ranger'` with care and in the same way as in\n:func:`~scanpy.pp.recipe_zheng17`.\n\nParameters\n----------\ndata\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\n    to cells and columns to genes.\nflavor\n    Choose the flavor for computing normalized dispersion. If choosing\n    'seurat', this expects non-logarithmized data \u2013 the logarithm of mean\n    and dispersion is taken internally when `log` is at its default value\n    `True`. For 'cell_ranger', this is usually called for logarithmized data\n    \u2013 in this case you should set `log` to `False`. In their default\n    workflows, Seurat passes the cutoffs whereas Cell Ranger passes\n    `n_top_genes`.\nmin_mean\nmax_mean\nmin_disp\nmax_disp\n    If `n_top_genes` unequals `None`, these cutoffs for the means and the\n    normalized dispersions are ignored.\nn_bins\n    Number of bins for binning the mean gene expression. Normalization is\n    done with respect to each bin. If just a single gene falls into a bin,\n    the normalized dispersion is artificially set to 1. You'll be informed\n    about this if you set `settings.verbosity = 4`.\nn_top_genes\n    Number of highly-variable genes to keep.\nlog\n    Use the logarithm of the mean to variance ratio.\nsubset\n    Keep highly-variable genes only (if True) else write a bool array for h\n    ighly-variable genes while keeping all genes\ncopy\n    If an :class:`~anndata.AnnData` is passed, determines whether a copy\n    is returned.\n\nReturns\n-------\nIf an AnnData `adata` is passed, returns or updates `adata` depending on\n`copy`. It filters the `adata` and adds the annotations\n\n**means** : adata.var\n    Means per gene. Logarithmized when `log` is `True`.\n**dispersions** : adata.var\n    Dispersions per gene. Logarithmized when `log` is `True`.\n**dispersions_norm** : adata.var\n    Normalized dispersions per gene. Logarithmized when `log` is `True`.\n\nIf a data matrix `X` is passed, the annotation is returned as `np.recarray`\nwith the same information stored in fields: `gene_subset`, `means`, `dispersions`, `dispersion_norm`.",
        "description": "Extract highly variable genes [Satija15]_ [Zheng17]_... warning::\n    .. deprecated:: 1.3.6\n        Use :func:`~scanpy.pp.highly_variable_genes`\n        instead. The new function is equivalent to the present\n        function, except that\n\n        * the new function always expects logarithmized data\n        * `subset=False` in the new function, it suffices to\n          merely annotate the genes, tools like `pp.pca` will\n          detect the annotation\n        * you can now call: `sc.pl.highly_variable_genes(adata)`\n        * `copy` is replaced by `inplace`\n\nIf trying out parameters, pass the data matrix instead of AnnData.\n\nDepending on `flavor`, this reproduces the R-implementations of Seurat\n[Satija15]_ and Cell Ranger [Zheng17]_.\n\nThe normalized dispersion is obtained by scaling with the mean and standard\ndeviation of the dispersions for genes falling into a given bin for mean\nexpression of genes. This means that for each bin of mean expression, highly\nvariable genes are selected.\n\nUse `flavor='cell_ranger'` with care and in the same way as in\n:func:`~scanpy.pp.recipe_zheng17`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.filter_genes_dispersion(data=$, flavor=$, min_disp=@, max_disp=@, min_mean=@, max_mean=@, n_bins=@, n_top_genes=@, log=@, subset=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.rank_genes_groups_tracksplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The groups for which to show the gene ranking.",
                "optional_value": false
            },
            "n_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\n`gene_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key used to store the ranking results in `adata.uns`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes using heatmap plot (see :func:`~scanpy.pl.heatmap`)\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroups\n    The groups for which to show the gene ranking.\nn_genes\n    Number of genes to show. This can be a negative number to show for\n    example the down regulated genes. eg: num_genes=-10. Is ignored if\n    `gene_names` is passed.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\ngroupby\n    The key of the observation grouping to consider. By default,\n    the groupby is chosen from the rank genes groups parameter but\n    other groupby options can be used.  It is expected that\n    groupby is a categorical. If groupby is not a categorical observation,\n    it would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).\nmin_logfoldchange\n    Value to filter genes in groups if their logfoldchange is less than the\n    min_logfoldchange\nkey\n    Key used to store the ranking results in `adata.uns`.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n**kwds\n    Are passed to :func:`~scanpy.pl.tracksplot`.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.rank_genes_groups(adata, 'bulk_labels')\n    sc.pl.rank_genes_groups_tracksplot(adata)",
        "description": "Plot ranking of genes using heatmap plot (see :func:`~scanpy.pl.heatmap`)",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.rank_genes_groups(adata, 'bulk_labels')\n    sc.pl.rank_genes_groups_tracksplot(adata)",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.rank_genes_groups_tracksplot(adata=$, groups=@, n_genes=@, groupby=@, var_names=@, gene_symbols=@, min_logfoldchange=@, key=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.wishbone": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "start_cell": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Desired start cell from `obs_names`.",
                "optional_value": false
            },
            "branch": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Use True for Wishbone and False for Wanderlust.",
                "optional_value": false
            },
            "k": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "Number of nearest neighbors for graph construction.",
                "optional_value": false
            },
            "components": {
                "type": "Iterable[int]",
                "default": "(1, 2, 3)",
                "optional": true,
                "description": "Components to use for running Wishbone.",
                "optional_value": false
            },
            "num_waypoints": {
                "type": "Union[int, Collection[]]",
                "default": "250",
                "optional": true,
                "description": "Number of waypoints to sample.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Updates `adata` with the following fields:\n`trajectory_wishbone` : (`adata.obs`, dtype `float64`)\nComputed trajectory positions.\n`branch_wishbone` : (`adata.obs`, dtype `int64`)\nAssigned branches."
        },
        "Docstring": "Wishbone identifies bifurcating developmental trajectories from single-cell data\n[Setty16]_.\n\nWishbone is an algorithm for positioning single cells along bifurcating\ndevelopmental trajectories with high resolution. Wishbone uses multi-dimensional\nsingle-cell data, such as mass cytometry or RNA-Seq data, as input and orders cells\naccording to their developmental progression, and it pinpoints bifurcation points\nby labeling each cell as pre-bifurcation or as one of two post-bifurcation cell\nfates.\n\n.. note::\n   More information and bug reports `here\n   <https://github.com/dpeerlab/wishbone>`__.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nstart_cell\n    Desired start cell from `obs_names`.\nbranch\n    Use True for Wishbone and False for Wanderlust.\nk\n    Number of nearest neighbors for graph construction.\ncomponents\n    Components to use for running Wishbone.\nnum_waypoints\n    Number of waypoints to sample.\n\nReturns\n-------\nUpdates `adata` with the following fields:\n\n`trajectory_wishbone` : (`adata.obs`, dtype `float64`)\n    Computed trajectory positions.\n`branch_wishbone` : (`adata.obs`, dtype `int64`)\n    Assigned branches.\n\nExample\n-------\n\n>>> import scanpy.external as sce\n>>> import scanpy as sc\n\n**Loading Data and Pre-processing**\n\n>>> adata = sc.datasets.pbmc3k()\n>>> sc.pp.normalize_per_cell(adata)\n>>> sc.pp.pca(adata)\n>>> sc.tl.tsne(adata=adata, n_pcs=5, perplexity=30)\n>>> sc.pp.neighbors(adata, n_pcs=15, n_neighbors=10)\n>>> sc.tl.diffmap(adata, n_comps=10)\n\n**Running Wishbone Core Function**\n\nUsually, the start cell for a dataset should be chosen based on high expression of\nthe gene of interest:\n\n>>> sce.tl.wishbone(\n...     adata=adata, start_cell='ACAAGAGACTTATC-1',\n...     components=[2, 3], num_waypoints=150,\n... )\n\n**Visualizing Wishbone results**\n\n>>> sc.pl.tsne(adata, color=['trajectory_wishbone', 'branch_wishbone'])\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ', 'MALAT1']\n>>> sce.pl.wishbone_marker_trajectory(adata, markers, show=True)\n\nFor further demonstration of Wishbone methods and visualization please follow the\nnotebooks in the package `Wishbone_for_single_cell_RNAseq.ipynb\n<https://github.com/dpeerlab/wishbone/tree/master/notebooks>`_.",
        "description": "Wishbone identifies bifurcating developmental trajectories from single-cell data[Setty16]_.\n\nWishbone is an algorithm for positioning single cells along bifurcating\ndevelopmental trajectories with high resolution. Wishbone uses multi-dimensional\nsingle-cell data, such as mass cytometry or RNA-Seq data, as input and orders cells\naccording to their developmental progression, and it pinpoints bifurcation points\nby labeling each cell as pre-bifurcation or as one of two post-bifurcation cell\nfates.\n\n.. note::\n   More information and bug reports `here\n   <https://github.com/dpeerlab/wishbone>`__.",
        "example": "Example\n-------\n\n>>> import scanpy.external as sce\n>>> import scanpy as sc\n\n**Loading Data and Pre-processing**\n\n>>> adata = sc.datasets.pbmc3k()\n>>> sc.pp.normalize_per_cell(adata)\n>>> sc.pp.pca(adata)\n>>> sc.tl.tsne(adata=adata, n_pcs=5, perplexity=30)\n>>> sc.pp.neighbors(adata, n_pcs=15, n_neighbors=10)\n>>> sc.tl.diffmap(adata, n_comps=10)\n\n**Running Wishbone Core Function**\n\nUsually, the start cell for a dataset should be chosen based on high expression of\nthe gene of interest:\n\n>>> sce.tl.wishbone(\n...     adata=adata, start_cell='ACAAGAGACTTATC-1',\n...     components=[2, 3], num_waypoints=150,\n... )\n\n**Visualizing Wishbone results**\n\n>>> sc.pl.tsne(adata, color=['trajectory_wishbone', 'branch_wishbone'])\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ', 'MALAT1']\n>>> sce.pl.wishbone_marker_trajectory(adata, markers, show=True)\n\nFor further demonstration of Wishbone methods and visualization please follow the\nnotebooks in the package `Wishbone_for_single_cell_RNAseq.ipynb\n<https://github.com/dpeerlab/wishbone/tree/master/notebooks>`_.",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.wishbone(adata=$, start_cell=@, branch=@, k=@, components=@, num_waypoints=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.subsample": {
        "Parameters": {
            "data": {
                "type": "Union[AnnData, ndarray, spmatrix]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "fraction": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Subsample to this `fraction` of the number of observations.",
                "optional_value": false
            },
            "n_obs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Subsample to this number of observations.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Random seed to change subsampling.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If an :class:`~anndata.AnnData` is passed,\ndetermines whether a copy is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Returns `X[obs_indices], obs_indices` if data is array-like, otherwise\nsubsamples the passed :class:`~anndata.AnnData` (`copy == False`) or\nreturns a subsampled copy of it (`copy == True`)."
        },
        "Docstring": "Subsample to a fraction of the number of observations.\n\nParameters\n----------\ndata\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\nfraction\n    Subsample to this `fraction` of the number of observations.\nn_obs\n    Subsample to this number of observations.\nrandom_state\n    Random seed to change subsampling.\ncopy\n    If an :class:`~anndata.AnnData` is passed,\n    determines whether a copy is returned.\n\nReturns\n-------\nReturns `X[obs_indices], obs_indices` if data is array-like, otherwise\nsubsamples the passed :class:`~anndata.AnnData` (`copy == False`) or\nreturns a subsampled copy of it (`copy == True`).",
        "description": "Subsample to a fraction of the number of observations.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.subsample(data=$, fraction=@, n_obs=@, random_state=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot.add_dendrogram": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'add_dendrogram'",
                "optional_value": false
            },
            "dendrogram_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Needed if `sc.tl.dendrogram` saved the dendrogram using a key different\nthan the default name.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[float]",
                "default": "0.8",
                "optional": true,
                "description": "size of the dendrogram. Corresponds to width when dendrogram shown on\nthe right of the plot, or height when shown on top. The unit is the same\nas in matplotlib (inches).",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Show dendrogram based on the hierarchical clustering between the `groupby`\ncategories. Categories are reordered to match the dendrogram order.\n\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `sc.tl.dendrogram` has not been called previously the function is called\nwith default parameters.\n\nThe dendrogram is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n`var_names` are reordered to produce a more pleasing output if:\n    * The data contains `var_groups`\n    * the `var_groups` match the categories.\n\nThe previous conditions happen by default when using Plot\nto show the results from :func:`~scanpy.tl.rank_genes_groups` (aka gene markers), by\ncalling `scanpy.tl.rank_genes_groups_(plot_name)`.\n\n\nParameters\n----------\nshow\n    Boolean to turn on (True) or off (False) 'add_dendrogram'\ndendrogram_key\n    Needed if `sc.tl.dendrogram` saved the dendrogram using a key different\n    than the default name.\nsize\n    size of the dendrogram. Corresponds to width when dendrogram shown on\n    the right of the plot, or height when shown on top. The unit is the same\n    as in matplotlib (inches).\n\nReturns\n-------\nBasePlot\n\n\nExamples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_dendrogram().show()",
        "description": "Show dendrogram based on the hierarchical clustering between the `groupby`categories. Categories are reordered to match the dendrogram order.\n\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `sc.tl.dendrogram` has not been called previously the function is called\nwith default parameters.\n\nThe dendrogram is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n`var_names` are reordered to produce a more pleasing output if:\n    * The data contains `var_groups`\n    * the `var_groups` match the categories.\n\nThe previous conditions happen by default when using Plot\nto show the results from :func:`~scanpy.tl.rank_genes_groups` (aka gene markers), by\ncalling `scanpy.tl.rank_genes_groups_(plot_name)`.",
        "example": "Examples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_dendrogram().show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.DotPlot.add_dendrogram(show=@, dendrogram_key=@, size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.diffmap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "n_comps": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "The number of dimensions of the representation.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, diffmap looks .uns['neighbors'] for neighbors settings\nand .obsp['connectivities'], .obsp['distances'] for connectivities and\ndistances respectively (default storage places for pp.neighbors).\nIf specified, diffmap looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key]['connectivities_key']],\n.obsp[.uns[neighbors_key]['distances_key']] for connectivities and distances\nrespectively.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "A numpy random seed",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to adata.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Depending on `copy`, returns or updates `adata` with the following fields.\n`X_diffmap` : :class:`numpy.ndarray` (`adata.obsm`)\nDiffusion map representation of data, which is the right eigen basis of\nthe transition matrix with eigenvectors as columns.\n`diffmap_evals` : :class:`numpy.ndarray` (`adata.uns`)\nArray of size (number of eigen vectors).\nEigenvalues of transition matrix.\nNotes\nThe 0-th column in `adata.obsm[\"X_diffmap\"]` is the steady-state solution,\nwhich is non-informative in diffusion maps.\nTherefore, the first diffusion component is at index 1,\ne.g. `adata.obsm[\"X_diffmap\"][:,1]`"
        },
        "Docstring": "Diffusion Maps [Coifman05]_ [Haghverdi15]_ [Wolf18]_.\n\nDiffusion maps [Coifman05]_ has been proposed for visualizing single-cell\ndata by [Haghverdi15]_. The tool uses the adapted Gaussian kernel suggested\nby [Haghverdi16]_ in the implementation of [Wolf18]_.\n\nThe width (\"sigma\") of the connectivity kernel is implicitly determined by\nthe number of neighbors used to compute the single-cell graph in\n:func:`~scanpy.pp.neighbors`. To reproduce the original implementation\nusing a Gaussian kernel, use `method=='gauss'` in\n:func:`~scanpy.pp.neighbors`. To use an exponential kernel, use the default\n`method=='umap'`. Differences between these options shouldn't usually be\ndramatic.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nn_comps\n    The number of dimensions of the representation.\nneighbors_key\n    If not specified, diffmap looks .uns['neighbors'] for neighbors settings\n    and .obsp['connectivities'], .obsp['distances'] for connectivities and\n    distances respectively (default storage places for pp.neighbors).\n    If specified, diffmap looks .uns[neighbors_key] for neighbors settings and\n    .obsp[.uns[neighbors_key]['connectivities_key']],\n    .obsp[.uns[neighbors_key]['distances_key']] for connectivities and distances\n    respectively.\nrandom_state\n    A numpy random seed\ncopy\n    Return a copy instead of writing to adata.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields.\n\n`X_diffmap` : :class:`numpy.ndarray` (`adata.obsm`)\n    Diffusion map representation of data, which is the right eigen basis of\n    the transition matrix with eigenvectors as columns.\n`diffmap_evals` : :class:`numpy.ndarray` (`adata.uns`)\n    Array of size (number of eigen vectors).\n    Eigenvalues of transition matrix.\n\nNotes\n-----\nThe 0-th column in `adata.obsm[\"X_diffmap\"]` is the steady-state solution,\nwhich is non-informative in diffusion maps.\nTherefore, the first diffusion component is at index 1,\ne.g. `adata.obsm[\"X_diffmap\"][:,1]`",
        "description": "Diffusion Maps [Coifman05]_ [Haghverdi15]_ [Wolf18]_.Diffusion maps [Coifman05]_ has been proposed for visualizing single-cell\ndata by [Haghverdi15]_. The tool uses the adapted Gaussian kernel suggested\nby [Haghverdi16]_ in the implementation of [Wolf18]_.\n\nThe width (\"sigma\") of the connectivity kernel is implicitly determined by\nthe number of neighbors used to compute the single-cell graph in\n:func:`~scanpy.pp.neighbors`. To reproduce the original implementation\nusing a Gaussian kernel, use `method=='gauss'` in\n:func:`~scanpy.pp.neighbors`. To use an exponential kernel, use the default\n`method=='umap'`. Differences between these options shouldn't usually be\ndramatic.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.diffmap(adata=$, n_comps=@, neighbors_key=@, random_state=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin.legend": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Set to 'False' to hide the default plot of the legend. This sets the\nlegend width to zero which will result in a wider main plot.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "Expression\nlevel in group",
                "optional": true,
                "description": "Legend title. Appears on top of the color bar. Use '\\n' to add line breaks.",
                "optional_value": false
            },
            "width": {
                "type": "Optional[float]",
                "default": "1.5",
                "optional": true,
                "description": "Width of the legend. The unit is the same as in matplotlib (inches)",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Configure legend parameters\n\nParameters\n----------\nshow\n    Set to 'False' to hide the default plot of the legend. This sets the\n    legend width to zero which will result in a wider main plot.\ntitle\n    Legend title. Appears on top of the color bar. Use '\\n' to add line breaks.\nwidth\n    Width of the legend. The unit is the same as in matplotlib (inches)\n\nReturns\n-------\nBasePlot\n\n\nExamples\n--------\n\nSet legend title:\n\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> dp = sc.pl.BasePlot(adata, markers, groupby='bulk_labels')\n>>> dp.legend(colorbar_title='log(UMI counts + 1)').show()",
        "description": "Configure legend parameters",
        "example": "Examples\n--------\n\nSet legend title:\n\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> dp = sc.pl.BasePlot(adata, markers, groupby='bulk_labels')\n>>> dp.legend(colorbar_title='log(UMI counts + 1)').show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.StackedViolin.legend(show=@, title=@, width=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.pbmc3k": {
        "Parameters": {},
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "3k PBMCs from 10x Genomics.\n\nThe data consists in 3k PBMCs from a Healthy Donor and is freely available\nfrom 10x Genomics (`here\n<http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz>`__\nfrom this `webpage\n<https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/pbmc3k>`__).\n\nThe exact same data is also used in Seurat's\n`basic clustering tutorial <https://satijalab.org/seurat/pbmc3k_tutorial.html>`__.\n\n.. note::\n\n    This downloads 5.9 MB of data upon the first call of the function and stores it in `./data/pbmc3k_raw.h5ad`.\n\nThe following code was run to produce the file.\n\n.. code:: python\n\n    adata = sc.read_10x_mtx(\n        # the directory with the `.mtx` file\n        './data/filtered_gene_bc_matrices/hg19/',\n        # use gene symbols for the variable names (variables-axis index)\n        var_names='gene_symbols',\n        # write a cache file for faster subsequent reading\n        cache=True,\n    )\n\n    adata.var_names_make_unique()  # this is unnecessary if using 'gene_ids'\n    adata.write('write/pbmc3k_raw.h5ad', compression='gzip')\n\nReturns\n-------\nAnnotated data matrix.",
        "description": "3k PBMCs from 10x Genomics.The data consists in 3k PBMCs from a Healthy Donor and is freely available\nfrom 10x Genomics (`here\n<http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz>`__\nfrom this `webpage\n<https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/pbmc3k>`__).\n\nThe exact same data is also used in Seurat's\n`basic clustering tutorial <https://satijalab.org/seurat/pbmc3k_tutorial.html>`__.\n\n.. note::\n\n    This downloads 5.9 MB of data upon the first call of the function and stores it in `./data/pbmc3k_raw.h5ad`.\n\nThe following code was run to produce the file.\n\n.. code:: python\n\n    adata = sc.read_10x_mtx(\n        # the directory with the `.mtx` file\n        './data/filtered_gene_bc_matrices/hg19/',\n        # use gene symbols for the variable names (variables-axis index)\n        var_names='gene_symbols',\n        # write a cache file for faster subsequent reading\n        cache=True,\n    )\n\n    adata.var_names_make_unique()  # this is unnecessary if using 'gene_ids'\n    adata.write('write/pbmc3k_raw.h5ad', compression='gzip')",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.pbmc3k()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.highest_expr_genes": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "n_top": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of top",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in .var that stores gene symbols if you do not want to use .var_names.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot x-axis in log scale",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes`."
        },
        "Docstring": "Fraction of counts assigned to each gene over all cells.\n\nComputes, for each gene, the fraction of counts assigned to that gene within\na cell. The `n_top` genes with the highest mean fraction over all cells are\nplotted as boxplots.\n\nThis plot is similar to the `scater` package function `plotHighestExprs(type\n= \"highest-expression\")`, see `here\n<https://bioconductor.org/packages/devel/bioc/vignettes/scater/inst/doc/vignette-qc.html>`__. Quoting\nfrom there:\n\n    *We expect to see the \u201cusual suspects\u201d, i.e., mitochondrial genes, actin,\n    ribosomal protein, MALAT1. A few spike-in transcripts may also be\n    present here, though if all of the spike-ins are in the top 50, it\n    suggests that too much spike-in RNA was added. A large number of\n    pseudo-genes or predicted genes may indicate problems with alignment.*\n    -- Davis McCarthy and Aaron Lun\n\nParameters\n----------\nadata\n    Annotated data matrix.\nn_top\n    Number of top\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\ngene_symbols\n    Key for field in .var that stores gene symbols if you do not want to use .var_names.\nlog\n    Plot x-axis in log scale\n**kwds\n    Are passed to :func:`~seaborn.boxplot`.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes`.",
        "description": "Fraction of counts assigned to each gene over all cells.Computes, for each gene, the fraction of counts assigned to that gene within\na cell. The `n_top` genes with the highest mean fraction over all cells are\nplotted as boxplots.\n\nThis plot is similar to the `scater` package function `plotHighestExprs(type\n= \"highest-expression\")`, see `here\n<https://bioconductor.org/packages/devel/bioc/vignettes/scater/inst/doc/vignette-qc.html>`__. Quoting\nfrom there:\n\n    *We expect to see the \u201cusual suspects\u201d, i.e., mitochondrial genes, actin,\n    ribosomal protein, MALAT1. A few spike-in transcripts may also be\n    present here, though if all of the spike-ins are in the top 50, it\n    suggests that too much spike-in RNA was added. A large number of\n    pseudo-genes or predicted genes may indicate problems with alignment.*\n    -- Davis McCarthy and Aaron Lun",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.highest_expr_genes(adata=$, n_top=@, show=@, save=@, ax=$, gene_symbols=@, log=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.rank_genes_groups_stacked_violin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The groups for which to show the gene ranking.",
                "optional_value": false
            },
            "n_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\n`gene_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key used to store the ranking results in `adata.uns`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`StackedViolin` object. Useful for fine-tuning\nthe plot. Takes precedence over `show=False`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `return_fig` is `True`, returns a :class:`StackedViolin` object,\nelse if `show` is false, return axes dict"
        },
        "Docstring": "Plot ranking of genes using stacked_violin plot\n(see :func:`~scanpy.pl.stacked_violin`)\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroups\n    The groups for which to show the gene ranking.\nn_genes\n    Number of genes to show. This can be a negative number to show for\n    example the down regulated genes. eg: num_genes=-10. Is ignored if\n    `gene_names` is passed.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\ngroupby\n    The key of the observation grouping to consider. By default,\n    the groupby is chosen from the rank genes groups parameter but\n    other groupby options can be used.  It is expected that\n    groupby is a categorical. If groupby is not a categorical observation,\n    it would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).\nmin_logfoldchange\n    Value to filter genes in groups if their logfoldchange is less than the\n    min_logfoldchange\nkey\n    Key used to store the ranking results in `adata.uns`.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\nreturn_fig\n    Returns :class:`StackedViolin` object. Useful for fine-tuning\n    the plot. Takes precedence over `show=False`.\n**kwds\n    Are passed to :func:`~scanpy.pl.stacked_violin`.\n\nReturns\n-------\nIf `return_fig` is `True`, returns a :class:`StackedViolin` object,\nelse if `show` is false, return axes dict\n\nExamples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(adata, 'bulk_labels')\n\n>>> sc.pl.rank_genes_groups_stacked_violin(adata, n_genes=4,\n... min_logfoldchange=4, figsize=(8,6))",
        "description": "Plot ranking of genes using stacked_violin plot(see :func:`~scanpy.pl.stacked_violin`)",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(adata, 'bulk_labels')\n\n>>> sc.pl.rank_genes_groups_stacked_violin(adata, n_genes=4,\n... min_logfoldchange=4, figsize=(8,6))",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.rank_genes_groups_stacked_violin(adata=$, groups=@, n_genes=@, groupby=@, gene_symbols=@, var_names=@, min_logfoldchange=@, key=@, show=@, save=@, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.ranking": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The data.",
                "optional_value": true
            },
            "attr": {
                "type": "Literal[var, obs, uns, varm, obsm]",
                "default": null,
                "optional": false,
                "description": "The attribute of AnnData that contains the score.",
                "optional_value": true
            },
            "keys": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The scores to look up an array from the attribute of adata.",
                "optional_value": false
            },
            "dictionary": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "indices": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "labels": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "color": {
                "type": null,
                "default": "black",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "n_points": {
                "type": null,
                "default": "30",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "log": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "include_lowest": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "show": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "Returns matplotlib gridspec with access to the axes."
        },
        "Docstring": "Plot rankings.\n\nSee, for example, how this is used in pl.pca_loadings.\n\nParameters\n----------\nadata\n    The data.\nattr\n    The attribute of AnnData that contains the score.\nkeys\n    The scores to look up an array from the attribute of adata.\n\nReturns\n-------\nReturns matplotlib gridspec with access to the axes.",
        "description": "Plot rankings.See, for example, how this is used in pl.pca_loadings.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.ranking(adata=$, attr=$, keys=@, dictionary=$, indices=$, labels=$, color=$, n_points=$, log=$, include_lowest=$, show=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.bbknn": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Needs the PCA computed and stored in `adata.obsm[\"X_pca\"]`.",
                "optional_value": true
            },
            "batch_key": {
                "type": "str",
                "default": "batch",
                "optional": true,
                "description": "`adata.obs` column name discriminating between your batches.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_pca",
                "optional": true,
                "description": "The dimensionality reduction in `.obsm` to use for neighbour detection. Defaults to PCA.",
                "optional_value": false
            },
            "approx": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, use approximate neighbour finding - annoy or pyNNDescent. This results\nin a quicker run time for large datasets while also potentially increasing the degree of\nbatch correction.",
                "optional_value": false
            },
            "use_annoy": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Only used when `approx=True`. If `True`, will use annoy for neighbour finding. If\n`False`, will use pyNNDescent instead.",
                "optional_value": false
            },
            "metric": {
                "type": "Union[str, Callable[], sklearn.neighbors.DistanceMetric]",
                "default": "euclidean",
                "optional": true,
                "description": "What distance metric to use. The options depend on the choice of neighbour algorithm.\n\n\"euclidean\", the default, is always available.\n\nAnnoy supports \"angular\", \"manhattan\" and \"hamming\".\n\nPyNNDescent supports metrics listed in `pynndescent.distances.named_distances`\nand custom functions, including compiled Numba code.\n\n>>> pynndescent.distances.named_distances.keys()\ndict_keys(['euclidean', 'l2', 'sqeuclidean', 'manhattan', 'taxicab', 'l1', 'chebyshev', 'linfinity',\n'linfty', 'linf', 'minkowski', 'seuclidean', 'standardised_euclidean', 'wminkowski', 'weighted_minkowski',\n'mahalanobis', 'canberra', 'cosine', 'dot', 'correlation', 'hellinger', 'haversine', 'braycurtis', 'spearmanr',\n'kantorovich', 'wasserstein', 'tsss', 'true_angular', 'hamming', 'jaccard', 'dice', 'matching', 'kulsinski',\n'rogerstanimoto', 'russellrao', 'sokalsneath', 'sokalmichener', 'yule'])\n\nKDTree supports members of the `sklearn.neighbors.KDTree.valid_metrics` list, or parameterised\n`sklearn.neighbors.DistanceMetric` `objects\n<https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.DistanceMetric.html>`_:\n\n>>> sklearn.neighbors.KDTree.valid_metrics\n['p', 'chebyshev', 'cityblock', 'minkowski', 'infinity', 'l2', 'euclidean', 'manhattan', 'l1']",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, return a copy instead of writing to the supplied adata.",
                "optional_value": false
            },
            "neighbors_within_batch": {
                "type": "int",
                "default": "3",
                "optional": true,
                "description": "How many top neighbours to report for each batch; total number of neighbours in\nthe initial k-nearest-neighbours computation will be this number times the number\nof batches. This then serves as the basis for the construction of a symmetrical\nmatrix of connectivities.",
                "optional_value": false
            },
            "n_pcs": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "How many dimensions (in case of PCA, principal components) to use in the analysis.",
                "optional_value": false
            },
            "trim": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Trim the neighbours of each cell to these many top connectivities. May help with\npopulation independence and improve the tidiness of clustering. The lower the value the\nmore independent the individual populations, at the cost of more conserved batch effect.\nIf `None`, sets the parameter value automatically to 10 times `neighbors_within_batch`\ntimes the number of batches. Set to 0 to skip.",
                "optional_value": false
            },
            "annoy_n_trees": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "Only used with annoy neighbour identification. The number of trees to construct in the\nannoy forest. More trees give higher precision when querying, at the cost of increased\nrun time and resource intensity.",
                "optional_value": false
            },
            "pynndescent_n_neighbors": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Only used with pyNNDescent neighbour identification. The number of neighbours to include\nin the approximate neighbour graph. More neighbours give higher precision when querying,\nat the cost of increased run time and resource intensity.",
                "optional_value": false
            },
            "pynndescent_random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Only used with pyNNDescent neighbour identification. The RNG seed to use when creating\nthe graph.",
                "optional_value": false
            },
            "use_faiss": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `approx=False` and the metric is \"euclidean\", use the faiss package to compute\nnearest neighbours if installed. This improves performance at a minor cost to numerical\nprecision as faiss operates on float32.",
                "optional_value": false
            },
            "set_op_mix_ratio": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "UMAP connectivity computation parameter, float between 0 and 1, controlling the\nblend between a connectivity matrix formed exclusively from mutual nearest neighbour\npairs (0) and a union of all observed neighbour relationships with the mutual pairs\nemphasised (1)",
                "optional_value": false
            },
            "local_connectivity": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "UMAP connectivity computation parameter, how many nearest neighbors of each cell\nare assumed to be fully connected (and given a connectivity value of 1)",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The `adata` with the batch-corrected graph."
        },
        "Docstring": "Batch balanced kNN [Polanski19]_.\n\nBatch balanced kNN alters the kNN procedure to identify each cell's top neighbours in\neach batch separately instead of the entire cell pool with no accounting for batch.\nThe nearest neighbours for each batch are then merged to create a final list of\nneighbours for the cell. Aligns batches in a quick and lightweight manner.\n\nFor use in the scanpy workflow as an alternative to :func:`~scanpy.pp.neighbors`.\n\n.. note::\n\n    This is just a wrapper of :func:`bbknn.bbknn`: up to date docstring,\n    more information and bug reports there.\n\nParams\n------\nadata\n    Needs the PCA computed and stored in `adata.obsm[\"X_pca\"]`.\nbatch_key\n    `adata.obs` column name discriminating between your batches.\nuse_rep\n    The dimensionality reduction in `.obsm` to use for neighbour detection. Defaults to PCA.\napprox\n    If `True`, use approximate neighbour finding - annoy or pyNNDescent. This results\n    in a quicker run time for large datasets while also potentially increasing the degree of\n    batch correction.\nuse_annoy\n    Only used when `approx=True`. If `True`, will use annoy for neighbour finding. If\n    `False`, will use pyNNDescent instead.\nmetric\n    What distance metric to use. The options depend on the choice of neighbour algorithm.\n\n    \"euclidean\", the default, is always available.\n\n    Annoy supports \"angular\", \"manhattan\" and \"hamming\".\n\n    PyNNDescent supports metrics listed in `pynndescent.distances.named_distances`\n    and custom functions, including compiled Numba code.\n\n    >>> pynndescent.distances.named_distances.keys()\n    dict_keys(['euclidean', 'l2', 'sqeuclidean', 'manhattan', 'taxicab', 'l1', 'chebyshev', 'linfinity',\n    'linfty', 'linf', 'minkowski', 'seuclidean', 'standardised_euclidean', 'wminkowski', 'weighted_minkowski',\n    'mahalanobis', 'canberra', 'cosine', 'dot', 'correlation', 'hellinger', 'haversine', 'braycurtis', 'spearmanr',\n    'kantorovich', 'wasserstein', 'tsss', 'true_angular', 'hamming', 'jaccard', 'dice', 'matching', 'kulsinski',\n    'rogerstanimoto', 'russellrao', 'sokalsneath', 'sokalmichener', 'yule'])\n\n    KDTree supports members of the `sklearn.neighbors.KDTree.valid_metrics` list, or parameterised\n    `sklearn.neighbors.DistanceMetric` `objects\n    <https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.DistanceMetric.html>`_:\n\n    >>> sklearn.neighbors.KDTree.valid_metrics\n    ['p', 'chebyshev', 'cityblock', 'minkowski', 'infinity', 'l2', 'euclidean', 'manhattan', 'l1']\ncopy\n    If `True`, return a copy instead of writing to the supplied adata.\nneighbors_within_batch\n    How many top neighbours to report for each batch; total number of neighbours in\n    the initial k-nearest-neighbours computation will be this number times the number\n    of batches. This then serves as the basis for the construction of a symmetrical\n    matrix of connectivities.\nn_pcs\n    How many dimensions (in case of PCA, principal components) to use in the analysis.\ntrim\n    Trim the neighbours of each cell to these many top connectivities. May help with\n    population independence and improve the tidiness of clustering. The lower the value the\n    more independent the individual populations, at the cost of more conserved batch effect.\n    If `None`, sets the parameter value automatically to 10 times `neighbors_within_batch`\n    times the number of batches. Set to 0 to skip.\nannoy_n_trees\n    Only used with annoy neighbour identification. The number of trees to construct in the\n    annoy forest. More trees give higher precision when querying, at the cost of increased\n    run time and resource intensity.\npynndescent_n_neighbors\n    Only used with pyNNDescent neighbour identification. The number of neighbours to include\n    in the approximate neighbour graph. More neighbours give higher precision when querying,\n    at the cost of increased run time and resource intensity.\npynndescent_random_state\n    Only used with pyNNDescent neighbour identification. The RNG seed to use when creating\n    the graph.\nuse_faiss\n    If `approx=False` and the metric is \"euclidean\", use the faiss package to compute\n    nearest neighbours if installed. This improves performance at a minor cost to numerical\n    precision as faiss operates on float32.\nset_op_mix_ratio\n    UMAP connectivity computation parameter, float between 0 and 1, controlling the\n    blend between a connectivity matrix formed exclusively from mutual nearest neighbour\n    pairs (0) and a union of all observed neighbour relationships with the mutual pairs\n    emphasised (1)\nlocal_connectivity\n    UMAP connectivity computation parameter, how many nearest neighbors of each cell\n    are assumed to be fully connected (and given a connectivity value of 1)\n\nReturns\n-------\nThe `adata` with the batch-corrected graph.",
        "description": "Batch balanced kNN [Polanski19]_.Batch balanced kNN alters the kNN procedure to identify each cell's top neighbours in\neach batch separately instead of the entire cell pool with no accounting for batch.\nThe nearest neighbours for each batch are then merged to create a final list of\nneighbours for the cell. Aligns batches in a quick and lightweight manner.\n\nFor use in the scanpy workflow as an alternative to :func:`~scanpy.pp.neighbors`.\n\n.. note::\n\n    This is just a wrapper of :func:`bbknn.bbknn`: up to date docstring,\n    more information and bug reports there.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.bbknn(adata=$, batch_key=@, use_rep=@, approx=@, use_annoy=@, metric=@, copy=@, neighbors_within_batch=@, n_pcs=@, trim=@, annoy_n_trees=@, pynndescent_n_neighbors=@, pynndescent_random_state=@, use_faiss=@, set_op_mix_ratio=@, local_connectivity=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.filter_cells": {
        "Parameters": {
            "data": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "min_counts": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum number of counts required for a cell to pass filtering.",
                "optional_value": false
            },
            "min_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum number of genes expressed required for a cell to pass filtering.",
                "optional_value": false
            },
            "max_counts": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum number of counts required for a cell to pass filtering.",
                "optional_value": false
            },
            "max_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum number of genes expressed required for a cell to pass filtering.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Perform computation inplace or return result.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[tuple[ndarray, ndarray]]",
            "description": "Depending on `inplace`, returns the following arrays or directly subsets\nand annotates the data matrix:\ncells_subset\nBoolean index mask that does filtering. `True` means that the\ncell is kept. `False` means the cell is removed.\nnumber_per_cell\nDepending on what was thresholded (`counts` or `genes`),\nthe array stores `n_counts` or `n_cells` per gene."
        },
        "Docstring": "Filter cell outliers based on counts and numbers of genes expressed.\n\nFor instance, only keep cells with at least `min_counts` counts or\n`min_genes` genes expressed. This is to filter measurement outliers,\ni.e. \u201cunreliable\u201d observations.\n\nOnly provide one of the optional parameters `min_counts`, `min_genes`,\n`max_counts`, `max_genes` per call.\n\nParameters\n----------\ndata\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\nmin_counts\n    Minimum number of counts required for a cell to pass filtering.\nmin_genes\n    Minimum number of genes expressed required for a cell to pass filtering.\nmax_counts\n    Maximum number of counts required for a cell to pass filtering.\nmax_genes\n    Maximum number of genes expressed required for a cell to pass filtering.\ninplace\n    Perform computation inplace or return result.\n\nReturns\n-------\nDepending on `inplace`, returns the following arrays or directly subsets\nand annotates the data matrix:\n\ncells_subset\n    Boolean index mask that does filtering. `True` means that the\n    cell is kept. `False` means the cell is removed.\nnumber_per_cell\n    Depending on what was thresholded (`counts` or `genes`),\n    the array stores `n_counts` or `n_cells` per gene.\n\nExamples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.krumsiek11()\n>>> adata.n_obs\n640\n>>> adata.var_names\n['Gata2' 'Gata1' 'Fog1' 'EKLF' 'Fli1' 'SCL' 'Cebpa'\n 'Pu.1' 'cJun' 'EgrNab' 'Gfi1']\n>>> # add some true zeros\n>>> adata.X[adata.X < 0.3] = 0\n>>> # simply compute the number of genes per cell\n>>> sc.pp.filter_cells(adata, min_genes=0)\n>>> adata.n_obs\n640\n>>> adata.obs['n_genes'].min()\n1\n>>> # filter manually\n>>> adata_copy = adata[adata.obs['n_genes'] >= 3]\n>>> adata_copy.obs['n_genes'].min()\n>>> adata.n_obs\n554\n>>> adata.obs['n_genes'].min()\n3\n>>> # actually do some filtering\n>>> sc.pp.filter_cells(adata, min_genes=3)\n>>> adata.n_obs\n554\n>>> adata.obs['n_genes'].min()\n3",
        "description": "Filter cell outliers based on counts and numbers of genes expressed.For instance, only keep cells with at least `min_counts` counts or\n`min_genes` genes expressed. This is to filter measurement outliers,\ni.e. \u201cunreliable\u201d observations.\n\nOnly provide one of the optional parameters `min_counts`, `min_genes`,\n`max_counts`, `max_genes` per call.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.krumsiek11()\n>>> adata.n_obs\n640\n>>> adata.var_names\n['Gata2' 'Gata1' 'Fog1' 'EKLF' 'Fli1' 'SCL' 'Cebpa'\n 'Pu.1' 'cJun' 'EgrNab' 'Gfi1']\n>>> # add some true zeros\n>>> adata.X[adata.X < 0.3] = 0\n>>> # simply compute the number of genes per cell\n>>> sc.pp.filter_cells(adata, min_genes=0)\n>>> adata.n_obs\n640\n>>> adata.obs['n_genes'].min()\n1\n>>> # filter manually\n>>> adata_copy = adata[adata.obs['n_genes'] >= 3]\n>>> adata_copy.obs['n_genes'].min()\n>>> adata.n_obs\n554\n>>> adata.obs['n_genes'].min()\n3\n>>> # actually do some filtering\n>>> sc.pp.filter_cells(adata, min_genes=3)\n>>> adata.n_obs\n554\n>>> adata.obs['n_genes'].min()\n3",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.filter_cells(data=$, min_counts=@, min_genes=@, max_counts=@, max_genes=@, inplace=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.calculate_qc_metrics": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "expr_type": {
                "type": "str",
                "default": "counts",
                "optional": true,
                "description": "Name of kind of values in X.",
                "optional_value": false
            },
            "var_type": {
                "type": "str",
                "default": "genes",
                "optional": true,
                "description": "The kind of thing the variables are.",
                "optional_value": false
            },
            "qc_vars": {
                "type": "Collection[str]",
                "default": "()",
                "optional": true,
                "description": "Keys for boolean columns of `.var` which identify variables you could\nwant to control for (e.g. \"ERCC\" or \"mito\").",
                "optional_value": false
            },
            "percent_top": {
                "type": "Optional[Collection[int]]",
                "default": "(50, 100, 200, 500)",
                "optional": true,
                "description": "Which proportions of top genes to cover. If empty or `None` don't\ncalculate. Values are considered 1-indexed, `percent_top=[50]` finds\ncumulative proportion to the 50th most expressed gene.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If provided, use `adata.layers[layer]` for expression values instead\nof `adata.X`.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, use `adata.raw.X` for expression values instead of `adata.X`.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to place calculated metrics in `adata`'s `.obs` and `.var`.",
                "optional_value": false
            },
            "log1p": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Set to `False` to skip computing `log1p` transformed annotations.",
                "optional_value": false
            },
            "parallel": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[tuple[DataFrame, DataFrame]]",
            "description": "Depending on `inplace` returns calculated metrics\n(as :class:`~pandas.DataFrame`) or updates `adata`'s `obs` and `var`.\nObservation level metrics include:\n`total_{var_type}_by_{expr_type}`\nE.g. \"total_genes_by_counts\". Number of genes with positive counts in a cell.\n`total_{expr_type}`\nE.g. \"total_counts\". Total number of counts for a cell.\n`pct_{expr_type}_in_top_{n}_{var_type}` \u2013 for `n` in `percent_top`\nE.g. \"pct_counts_in_top_50_genes\". Cumulative percentage of counts\nfor 50 most expressed genes in a cell.\n`total_{expr_type}_{qc_var}` \u2013 for `qc_var` in `qc_vars`\nE.g. \"total_counts_mito\". Total number of counts for variabes in\n`qc_vars`.\n`pct_{expr_type}_{qc_var}` \u2013 for `qc_var` in `qc_vars`\nE.g. \"pct_counts_mito\". Proportion of total counts for a cell which\nare mitochondrial.\nVariable level metrics include:\n`total_{expr_type}`\nE.g. \"total_counts\". Sum of counts for a gene.\n`n_genes_by_{expr_type}`\nE.g. \"n_genes_by_counts\". The number of genes with at least 1 count in a cell. Calculated for all cells.\n`mean_{expr_type}`\nE.g. \"mean_counts\". Mean expression over all cells.\n`n_cells_by_{expr_type}`\nE.g. \"n_cells_by_counts\". Number of cells this expression is\nmeasured in.\n`pct_dropout_by_{expr_type}`\nE.g. \"pct_dropout_by_counts\". Percentage of cells this feature does\nnot appear in."
        },
        "Docstring": "Calculate quality control metrics.\n\nCalculates a number of qc metrics for an AnnData object, see section\n`Returns` for specifics. Largely based on `calculateQCMetrics` from scater\n[McCarthy17]_. Currently is most efficient on a sparse CSR or dense matrix.\n\nNote that this method can take a while to compile on the first call. That\nresult is then cached to disk to be used later.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nexpr_type\n    Name of kind of values in X.\nvar_type\n    The kind of thing the variables are.\nqc_vars\n    Keys for boolean columns of `.var` which identify variables you could\n    want to control for (e.g. \"ERCC\" or \"mito\").\npercent_top\n    Which proportions of top genes to cover. If empty or `None` don't\n    calculate. Values are considered 1-indexed, `percent_top=[50]` finds\n    cumulative proportion to the 50th most expressed gene.\nlayer\n    If provided, use `adata.layers[layer]` for expression values instead\n    of `adata.X`.\nuse_raw\n    If True, use `adata.raw.X` for expression values instead of `adata.X`.\ninplace\n    Whether to place calculated metrics in `adata`'s `.obs` and `.var`.\nlog1p\n    Set to `False` to skip computing `log1p` transformed annotations.\n\nReturns\n-------\nDepending on `inplace` returns calculated metrics\n(as :class:`~pandas.DataFrame`) or updates `adata`'s `obs` and `var`.\n\nObservation level metrics include:\n\n`total_{var_type}_by_{expr_type}`\n    E.g. \"total_genes_by_counts\". Number of genes with positive counts in a cell.\n`total_{expr_type}`\n    E.g. \"total_counts\". Total number of counts for a cell.\n`pct_{expr_type}_in_top_{n}_{var_type}` \u2013 for `n` in `percent_top`\n    E.g. \"pct_counts_in_top_50_genes\". Cumulative percentage of counts\n    for 50 most expressed genes in a cell.\n`total_{expr_type}_{qc_var}` \u2013 for `qc_var` in `qc_vars`\n    E.g. \"total_counts_mito\". Total number of counts for variabes in\n    `qc_vars`.\n`pct_{expr_type}_{qc_var}` \u2013 for `qc_var` in `qc_vars`\n    E.g. \"pct_counts_mito\". Proportion of total counts for a cell which\n    are mitochondrial.\n\nVariable level metrics include:\n\n`total_{expr_type}`\n    E.g. \"total_counts\". Sum of counts for a gene.\n`n_genes_by_{expr_type}`\n    E.g. \"n_genes_by_counts\". The number of genes with at least 1 count in a cell. Calculated for all cells.\n`mean_{expr_type}`\n    E.g. \"mean_counts\". Mean expression over all cells.\n`n_cells_by_{expr_type}`\n    E.g. \"n_cells_by_counts\". Number of cells this expression is\n    measured in.\n`pct_dropout_by_{expr_type}`\n    E.g. \"pct_dropout_by_counts\". Percentage of cells this feature does\n    not appear in.\n\nExample\n-------\nCalculate qc metrics for visualization.\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    import seaborn as sns\n\n    pbmc = sc.datasets.pbmc3k()\n    pbmc.var[\"mito\"] = pbmc.var_names.str.startswith(\"MT-\")\n    sc.pp.calculate_qc_metrics(pbmc, qc_vars=[\"mito\"], inplace=True)\n    sns.jointplot(\n        data=pbmc.obs,\n        x=\"log1p_total_counts\",\n        y=\"log1p_n_genes_by_counts\",\n        kind=\"hex\",\n    )\n\n.. plot::\n    :context: close-figs\n\n    sns.histplot(pbmc.obs[\"pct_counts_mito\"])",
        "description": "Calculate quality control metrics.Calculates a number of qc metrics for an AnnData object, see section\n`Returns` for specifics. Largely based on `calculateQCMetrics` from scater\n[McCarthy17]_. Currently is most efficient on a sparse CSR or dense matrix.\n\nNote that this method can take a while to compile on the first call. That\nresult is then cached to disk to be used later.",
        "example": "Example\n-------\nCalculate qc metrics for visualization.\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    import seaborn as sns\n\n    pbmc = sc.datasets.pbmc3k()\n    pbmc.var[\"mito\"] = pbmc.var_names.str.startswith(\"MT-\")\n    sc.pp.calculate_qc_metrics(pbmc, qc_vars=[\"mito\"], inplace=True)\n    sns.jointplot(\n        data=pbmc.obs,\n        x=\"log1p_total_counts\",\n        y=\"log1p_n_genes_by_counts\",\n        kind=\"hex\",\n    )\n\n.. plot::\n    :context: close-figs\n\n    sns.histplot(pbmc.obs[\"pct_counts_mito\"])",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.calculate_qc_metrics(adata=$, expr_type=@, var_type=@, qc_vars=@, percent_top=@, layer=@, use_raw=@, inplace=@, log1p=@, parallel=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.scrublet": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape ``n_obs`` \u00d7 ``n_vars``. Rows\ncorrespond to cells and columns to genes. Expected to be un-normalised\nwhere adata_sim is not supplied, in which case doublets will be\nsimulated and pre-processing applied to both objects. If adata_sim is\nsupplied, this should be the observed transcriptomes processed\nconsistently (filtering, transform, normalisaton, hvg) with adata_sim.",
                "optional_value": true
            },
            "adata_sim": {
                "type": "Optional[AnnData]",
                "default": "None",
                "optional": true,
                "description": "(Advanced use case) Optional annData object generated by\nsc.external.pp.scrublet_simulate_doublets(), with same number of vars\nas adata. This should have been built from adata_obs after\nfiltering genes and cells and selcting highly-variable genes.",
                "optional_value": true
            },
            "batch_key": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Optional `adata.obs` column name discriminating between batches.",
                "optional_value": false
            },
            "sim_doublet_ratio": {
                "type": "float",
                "default": "2.0",
                "optional": true,
                "description": "Number of doublets to simulate relative to the number of observed\ntranscriptomes.",
                "optional_value": false
            },
            "expected_doublet_rate": {
                "type": "float",
                "default": "0.05",
                "optional": true,
                "description": "Where adata_sim not suplied, the estimated doublet rate for the\nexperiment.",
                "optional_value": false
            },
            "stdev_doublet_rate": {
                "type": "float",
                "default": "0.02",
                "optional": true,
                "description": "Where adata_sim not suplied, uncertainty in the expected doublet rate.",
                "optional_value": false
            },
            "synthetic_doublet_umi_subsampling": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Where adata_sim not suplied, rate for sampling UMIs when creating\nsynthetic doublets. If 1.0, each doublet is created by simply adding\nthe UMI counts from two randomly sampled observed transcriptomes. For\nvalues less than 1, the UMI counts are added and then randomly sampled\nat the specified rate.",
                "optional_value": false
            },
            "knn_dist_metric": {
                "type": "str",
                "default": "euclidean",
                "optional": true,
                "description": "Distance metric used when finding nearest neighbors. For list of\nvalid values, see the documentation for annoy (if `use_approx_neighbors`\nis True) or sklearn.neighbors.NearestNeighbors (if `use_approx_neighbors`\nis False).",
                "optional_value": false
            },
            "normalize_variance": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If True, normalize the data such that each gene has a variance of 1.\n`sklearn.decomposition.TruncatedSVD` will be used for dimensionality\nreduction, unless `mean_center` is True.",
                "optional_value": false
            },
            "log_transform": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use :func:``~scanpy.pp.log1p`` to log-transform the data\nprior to PCA.",
                "optional_value": false
            },
            "mean_center": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If True, center the data such that each gene has a mean of 0.\n`sklearn.decomposition.PCA` will be used for dimensionality\nreduction.",
                "optional_value": false
            },
            "n_prin_comps": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of principal components used to embed the transcriptomes prior\nto k-nearest-neighbor graph construction.",
                "optional_value": false
            },
            "use_approx_neighbors": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Use approximate nearest neighbor method (annoy) for the KNN\nclassifier.",
                "optional_value": false
            },
            "get_doublet_neighbor_parents": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, return (in .uns) the parent transcriptomes that generated the\ndoublet neighbors of each observed transcriptome. This information can\nbe used to infer the cell states that generated a given doublet state.",
                "optional_value": false
            },
            "n_neighbors": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of neighbors used to construct the KNN graph of observed\ntranscriptomes and simulated doublets. If ``None``, this is\nautomatically set to ``np.round(0.5 * np.sqrt(n_obs))``.",
                "optional_value": false
            },
            "threshold": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Doublet score threshold for calling a transcriptome a doublet. If\n`None`, this is set automatically by looking for the minimum between\nthe two modes of the `doublet_scores_sim_` histogram. It is best\npractice to check the threshold visually using the\n`doublet_scores_sim_` histogram and/or based on co-localization of\npredicted doublets in a 2-D embedding.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If True, print progress updates.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return a copy of the input ``adata`` with Scrublet results\nadded. Otherwise, Scrublet results are added in place.",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Initial state for doublet simulation and nearest neighbors.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "adata : anndata.AnnData\nif ``copy=True`` it returns or else adds fields to ``adata``. Those fields:\n``.obs['doublet_score']``\nDoublet scores for each observed transcriptome\n``.obs['predicted_doublets']``\nBoolean indicating predicted doublet status\n``.uns['scrublet']['doublet_scores_sim']``\nDoublet scores for each simulated doublet transcriptome\n``.uns['scrublet']['doublet_parents']``\nPairs of ``.obs_names`` used to generate each simulated doublet\ntranscriptome\n``.uns['scrublet']['parameters']``\nDictionary of Scrublet parameters\nSee also\n:func:`~scanpy.external.pp.scrublet_simulate_doublets`: Run Scrublet's doublet\nsimulation separately for advanced usage.\n:func:`~scanpy.external.pl.scrublet_score_distribution`: Plot histogram of doublet\nscores for observed transcriptomes and simulated doublets."
        },
        "Docstring": "Predict doublets using Scrublet [Wolock19]_.\n\nPredict cell doublets using a nearest-neighbor classifier of observed\ntranscriptomes and simulated doublets. Works best if the input is a raw\n(unnormalized) counts matrix from a single sample or a collection of\nsimilar samples from the same experiment.\nThis function is a wrapper around functions that pre-process using Scanpy\nand directly call functions of Scrublet(). You may also undertake your own\npreprocessing, simulate doublets with\nscanpy.external.pp.scrublet_simulate_doublets(), and run the core scrublet\nfunction scanpy.external.pp.scrublet.scrublet().\n\n.. note::\n    More information and bug reports `here\n    <https://github.com/swolock/scrublet>`__.\n\nParameters\n----------\nadata\n    The annotated data matrix of shape ``n_obs`` \u00d7 ``n_vars``. Rows\n    correspond to cells and columns to genes. Expected to be un-normalised\n    where adata_sim is not supplied, in which case doublets will be\n    simulated and pre-processing applied to both objects. If adata_sim is\n    supplied, this should be the observed transcriptomes processed\n    consistently (filtering, transform, normalisaton, hvg) with adata_sim.\nadata_sim\n    (Advanced use case) Optional annData object generated by\n    sc.external.pp.scrublet_simulate_doublets(), with same number of vars\n    as adata. This should have been built from adata_obs after\n    filtering genes and cells and selcting highly-variable genes.\nbatch_key\n    Optional `adata.obs` column name discriminating between batches.\nsim_doublet_ratio\n    Number of doublets to simulate relative to the number of observed\n    transcriptomes.\nexpected_doublet_rate\n    Where adata_sim not suplied, the estimated doublet rate for the\n    experiment.\nstdev_doublet_rate\n    Where adata_sim not suplied, uncertainty in the expected doublet rate.\nsynthetic_doublet_umi_subsampling\n    Where adata_sim not suplied, rate for sampling UMIs when creating\n    synthetic doublets. If 1.0, each doublet is created by simply adding\n    the UMI counts from two randomly sampled observed transcriptomes. For\n    values less than 1, the UMI counts are added and then randomly sampled\n    at the specified rate.\nknn_dist_metric\n    Distance metric used when finding nearest neighbors. For list of\n    valid values, see the documentation for annoy (if `use_approx_neighbors`\n    is True) or sklearn.neighbors.NearestNeighbors (if `use_approx_neighbors`\n    is False).\nnormalize_variance\n    If True, normalize the data such that each gene has a variance of 1.\n    `sklearn.decomposition.TruncatedSVD` will be used for dimensionality\n    reduction, unless `mean_center` is True.\nlog_transform\n    Whether to use :func:``~scanpy.pp.log1p`` to log-transform the data\n    prior to PCA.\nmean_center\n    If True, center the data such that each gene has a mean of 0.\n    `sklearn.decomposition.PCA` will be used for dimensionality\n    reduction.\nn_prin_comps\n    Number of principal components used to embed the transcriptomes prior\n    to k-nearest-neighbor graph construction.\nuse_approx_neighbors\n    Use approximate nearest neighbor method (annoy) for the KNN\n    classifier.\nget_doublet_neighbor_parents\n    If True, return (in .uns) the parent transcriptomes that generated the\n    doublet neighbors of each observed transcriptome. This information can\n    be used to infer the cell states that generated a given doublet state.\nn_neighbors\n    Number of neighbors used to construct the KNN graph of observed\n    transcriptomes and simulated doublets. If ``None``, this is\n    automatically set to ``np.round(0.5 * np.sqrt(n_obs))``.\nthreshold\n    Doublet score threshold for calling a transcriptome a doublet. If\n    `None`, this is set automatically by looking for the minimum between\n    the two modes of the `doublet_scores_sim_` histogram. It is best\n    practice to check the threshold visually using the\n    `doublet_scores_sim_` histogram and/or based on co-localization of\n    predicted doublets in a 2-D embedding.\nverbose\n    If True, print progress updates.\ncopy\n    If ``True``, return a copy of the input ``adata`` with Scrublet results\n    added. Otherwise, Scrublet results are added in place.\nrandom_state\n    Initial state for doublet simulation and nearest neighbors.\n\nReturns\n-------\nadata : anndata.AnnData\n    if ``copy=True`` it returns or else adds fields to ``adata``. Those fields:\n\n    ``.obs['doublet_score']``\n        Doublet scores for each observed transcriptome\n\n    ``.obs['predicted_doublets']``\n        Boolean indicating predicted doublet status\n\n    ``.uns['scrublet']['doublet_scores_sim']``\n        Doublet scores for each simulated doublet transcriptome\n\n    ``.uns['scrublet']['doublet_parents']``\n        Pairs of ``.obs_names`` used to generate each simulated doublet\n        transcriptome\n\n    ``.uns['scrublet']['parameters']``\n        Dictionary of Scrublet parameters\n\nSee also\n--------\n:func:`~scanpy.external.pp.scrublet_simulate_doublets`: Run Scrublet's doublet\n    simulation separately for advanced usage.\n:func:`~scanpy.external.pl.scrublet_score_distribution`: Plot histogram of doublet\n    scores for observed transcriptomes and simulated doublets.",
        "description": "Predict doublets using Scrublet [Wolock19]_.Predict cell doublets using a nearest-neighbor classifier of observed\ntranscriptomes and simulated doublets. Works best if the input is a raw\n(unnormalized) counts matrix from a single sample or a collection of\nsimilar samples from the same experiment.\nThis function is a wrapper around functions that pre-process using Scanpy\nand directly call functions of Scrublet(). You may also undertake your own\npreprocessing, simulate doublets with\nscanpy.external.pp.scrublet_simulate_doublets(), and run the core scrublet\nfunction scanpy.external.pp.scrublet.scrublet().\n\n.. note::\n    More information and bug reports `here\n    <https://github.com/swolock/scrublet>`__.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.scrublet(adata=$, adata_sim=$, batch_key=@, sim_doublet_ratio=@, expected_doublet_rate=@, stdev_doublet_rate=@, synthetic_doublet_umi_subsampling=@, knn_dist_metric=@, normalize_variance=@, log_transform=@, mean_center=@, n_prin_comps=@, use_approx_neighbors=@, get_doublet_neighbor_parents=@, n_neighbors=@, threshold=@, verbose=@, copy=@, random_state=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.downsample_counts": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "counts_per_cell": {
                "type": "Optional[Union[int, Collection[int]]]",
                "default": "None",
                "optional": true,
                "description": "Target total counts per cell. If a cell has more than 'counts_per_cell',\nit will be downsampled to this number. Resulting counts can be specified\non a per cell basis by passing an array.Should be an integer or integer\nndarray with same length as number of obs.",
                "optional_value": false
            },
            "total_counts": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Target total counts. If the count matrix has more than `total_counts`\nit will be downsampled to have this number.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Random seed for subsampling.",
                "optional_value": false
            },
            "replace": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to sample the counts with replacement.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Determines whether a copy of `adata` is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy` returns or updates an `adata` with downsampled `.X`."
        },
        "Docstring": "Downsample counts from count matrix.\n\nIf `counts_per_cell` is specified, each cell will downsampled.\nIf `total_counts` is specified, expression matrix will be downsampled to\ncontain at most `total_counts`.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncounts_per_cell\n    Target total counts per cell. If a cell has more than 'counts_per_cell',\n    it will be downsampled to this number. Resulting counts can be specified\n    on a per cell basis by passing an array.Should be an integer or integer\n    ndarray with same length as number of obs.\ntotal_counts\n    Target total counts. If the count matrix has more than `total_counts`\n    it will be downsampled to have this number.\nrandom_state\n    Random seed for subsampling.\nreplace\n    Whether to sample the counts with replacement.\ncopy\n    Determines whether a copy of `adata` is returned.\n\nReturns\n-------\nDepending on `copy` returns or updates an `adata` with downsampled `.X`.",
        "description": "Downsample counts from count matrix.If `counts_per_cell` is specified, each cell will downsampled.\nIf `total_counts` is specified, expression matrix will be downsampled to\ncontain at most `total_counts`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.downsample_counts(adata=$, counts_per_cell=@, total_counts=@, random_state=@, replace=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.draw_graph": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show edges.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Width of edges.",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Union[str, tuple[float, Ellipsis]]",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "layout": {
                "type": "Optional[Literal[fa, fr, rt, rt_circular, drl, eq_tree, Ellipsis]]",
                "default": "None",
                "optional": true,
                "description": "One of the :func:`~scanpy.tl.draw_graph` layouts.\nBy default, the last computed layout is used.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, List[Axes]]]",
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot in graph-drawing basis.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nlayout\n    One of the :func:`~scanpy.tl.draw_graph` layouts.\n    By default, the last computed layout is used.\nedges\n    Show edges.\nedges_width\n    Width of edges.\nedges_color\n    Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\nneighbors_key\n    Where to look for neighbors connectivities.\n    If not specified, this looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, this looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\narrows\n    Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\narrows_kwds\n    Passed to :meth:`~matplotlib.axes.Axes.quiver`\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.draw_graph(adata)\n    sc.pl.draw_graph(adata, color=['phase', 'bulk_labels'])\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.draw_graph",
        "description": "Scatter plot in graph-drawing basis.",
        "example": "Examples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.draw_graph(adata)\n    sc.pl.draw_graph(adata, color=['phase', 'bulk_labels'])\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.draw_graph",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.draw_graph(adata=$, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@, layout=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.logging.print_versions": {
        "Parameters": {
            "file": {
                "type": "Optional[IO[str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Print versions of imported packages, OS, and jupyter environment.\n\nFor more options (including rich output) use `session_info.show` directly.",
        "description": "Print versions of imported packages, OS, and jupyter environment.For more options (including rich output) use `session_info.show` directly.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.logging.print_versions(file=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.scale": {
        "Parameters": {
            "X": {
                "type": "Union[AnnData, spmatrix, ndarray]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "zero_center": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `False`, omit zero-centering variables, which allows to handle sparse\ninput efficiently.",
                "optional_value": false
            },
            "max_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Clip (truncate) to this value after scaling. If `None`, do not clip.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether this function should be performed inplace. If an AnnData object\nis passed, this also determines if a copy is returned.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If provided, which element of layers to scale.",
                "optional_value": false
            },
            "obsm": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If provided, which element of obsm to scale.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Depending on `copy` returns or updates `adata` with a scaled `adata.X`,\nannotated with `'mean'` and `'std'` in `adata.var`."
        },
        "Docstring": "Scale data to unit variance and zero mean.\n\n.. note::\n    Variables (genes) that do not display any variation (are constant across\n    all observations) are retained and (for zero_center==True) set to 0\n    during this operation. In the future, they might be set to NaNs.\n\nParameters\n----------\nX\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\nzero_center\n    If `False`, omit zero-centering variables, which allows to handle sparse\n    input efficiently.\nmax_value\n    Clip (truncate) to this value after scaling. If `None`, do not clip.\ncopy\n    Whether this function should be performed inplace. If an AnnData object\n    is passed, this also determines if a copy is returned.\nlayer\n    If provided, which element of layers to scale.\nobsm\n    If provided, which element of obsm to scale.\n\nReturns\n-------\nDepending on `copy` returns or updates `adata` with a scaled `adata.X`,\nannotated with `'mean'` and `'std'` in `adata.var`.",
        "description": "Scale data to unit variance and zero mean... note::\n    Variables (genes) that do not display any variation (are constant across\n    all observations) are retained and (for zero_center==True) set to 0\n    during this operation. In the future, they might be set to NaNs.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.scale(X=$, zero_center=@, max_value=@, copy=@, layer=@, obsm=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin.style": {
        "Parameters": {
            "cmap": {
                "type": "Optional[str]",
                "default": "Blues",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "stripplot": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Add a stripplot on top of the violin plot.\nSee :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "jitter": {
                "type": "Optional[Union[float, bool]]",
                "default": "False",
                "optional": true,
                "description": "Add jitter to the stripplot (only when stripplot is True)\nSee :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "jitter_size": {
                "type": "Optional[int]",
                "default": "1",
                "optional": true,
                "description": "Size of the jitter points.",
                "optional_value": false
            },
            "linewidth": {
                "type": "Optional[float]",
                "default": "0.2",
                "optional": true,
                "description": "linewidth for the violin plots.",
                "optional_value": false
            },
            "row_palette": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The row palette determines the colors to use for the stacked violins.\nThe value should be a valid seaborn or matplotlib palette name\n(see :func:`~seaborn.color_palette`).\nAlternatively, a single color name or hex value can be passed,\ne.g. `'red'` or `'#cc33ff'`.",
                "optional_value": false
            },
            "scale": {
                "type": "Optional[Literal[area, count, width]]",
                "default": "width",
                "optional": true,
                "description": "The method used to scale the width of each violin.\nIf 'width' (the default), each violin will have the same width.\nIf 'area', each violin will have the same area.\nIf 'count', a violin\u2019s width corresponds to the number of observations.",
                "optional_value": true
            },
            "yticklabels": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Set to true to view the y tick labels.",
                "optional_value": false
            },
            "ylim": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "minimum and maximum values for the y-axis. If set. All rows will have\nthe same y-axis range. Example: ylim=(0, 5)",
                "optional_value": false
            },
            "x_padding": {
                "type": "Optional[float]",
                "default": "0.5",
                "optional": true,
                "description": "Space between the plot left/right borders and the violins. A unit\nis the distance between the x ticks.",
                "optional_value": false
            },
            "y_padding": {
                "type": "Optional[float]",
                "default": "0.5",
                "optional": true,
                "description": "Space between the plot top/bottom borders and the violins. A unit is\nthe distance between the y ticks.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ":class:`~scanpy.pl.StackedViolin`"
        },
        "Docstring": "Modifies plot visual parameters\n\nParameters\n----------\ncmap\n    String denoting matplotlib color map.\nstripplot\n    Add a stripplot on top of the violin plot.\n    See :func:`~seaborn.stripplot`.\njitter\n    Add jitter to the stripplot (only when stripplot is True)\n    See :func:`~seaborn.stripplot`.\njitter_size\n    Size of the jitter points.\nlinewidth\n    linewidth for the violin plots.\nrow_palette\n    The row palette determines the colors to use for the stacked violins.\n    The value should be a valid seaborn or matplotlib palette name\n    (see :func:`~seaborn.color_palette`).\n    Alternatively, a single color name or hex value can be passed,\n    e.g. `'red'` or `'#cc33ff'`.\nscale\n    The method used to scale the width of each violin.\n    If 'width' (the default), each violin will have the same width.\n    If 'area', each violin will have the same area.\n    If 'count', a violin\u2019s width corresponds to the number of observations.\nyticklabels\n    Set to true to view the y tick labels.\nylim\n    minimum and maximum values for the y-axis. If set. All rows will have\n    the same y-axis range. Example: ylim=(0, 5)\nx_padding\n    Space between the plot left/right borders and the violins. A unit\n    is the distance between the x ticks.\ny_padding\n    Space between the plot top/bottom borders and the violins. A unit is\n    the distance between the y ticks.\n\nReturns\n-------\n:class:`~scanpy.pl.StackedViolin`\n\nExamples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n\nChange color map and turn off edges\n\n>>> sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels')        ...               .style(row_palette='Blues', linewidth=0).show()",
        "description": "Modifies plot visual parameters",
        "example": "Examples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n\nChange color map and turn off edges\n\n>>> sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels')        ...               .style(row_palette='Blues', linewidth=0).show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.StackedViolin.style(cmap=@, stripplot=@, jitter=@, jitter_size=@, linewidth=@, row_palette=@, scale=$, yticklabels=@, ylim=@, x_padding=@, y_padding=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.regress_out": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "keys": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "Keys for observation annotation on which to regress on.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of jobs for parallel computation.\n`None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Determines whether a copy of `adata` is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy` returns or updates `adata` with the corrected data matrix."
        },
        "Docstring": "Regress out (mostly) unwanted sources of variation.\n\nUses simple linear regression. This is inspired by Seurat's `regressOut`\nfunction in R [Satija15]. Note that this function tends to overcorrect\nin certain circumstances as described in :issue:`526`.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nkeys\n    Keys for observation annotation on which to regress on.\nn_jobs\n    Number of jobs for parallel computation.\n    `None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.\ncopy\n    Determines whether a copy of `adata` is returned.\n\nReturns\n-------\nDepending on `copy` returns or updates `adata` with the corrected data matrix.",
        "description": "Regress out (mostly) unwanted sources of variation.Uses simple linear regression. This is inspired by Seurat's `regressOut`\nfunction in R [Satija15]. Note that this function tends to overcorrect\nin certain circumstances as described in :issue:`526`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.regress_out(adata=$, keys=@, n_jobs=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_text": {
        "Parameters": {
            "filename": {
                "type": "Union[PathLike, Iterator[str]]",
                "default": null,
                "optional": false,
                "description": "Data file, filename or stream.",
                "optional_value": false
            },
            "delimiter": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Delimiter that separates data within text file. If `None`, will split at\narbitrary number of white spaces, which is different from enforcing\nsplitting at single white space `' '`.",
                "optional_value": false
            },
            "first_column_names": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Assume the first column stores row names.",
                "optional_value": false
            },
            "dtype": {
                "type": "str",
                "default": "float32",
                "optional": true,
                "description": "Numpy data type.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Read `.txt`, `.tab`, `.data` (text) file.\n\nSame as :func:`~anndata.read_csv` but with default delimiter `None`.\n\nParameters\n----------\nfilename\n    Data file, filename or stream.\ndelimiter\n    Delimiter that separates data within text file. If `None`, will split at\n    arbitrary number of white spaces, which is different from enforcing\n    splitting at single white space `' '`.\nfirst_column_names\n    Assume the first column stores row names.\ndtype\n    Numpy data type.",
        "description": "Read `.txt`, `.tab`, `.data` (text) file.Same as :func:`~anndata.read_csv` but with default delimiter `None`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_text(filename=@, delimiter=@, first_column_names=@, dtype=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.pca": {
        "Parameters": {
            "data": {
                "type": "Union[AnnData, ndarray, spmatrix]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "n_comps": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of principal components to compute. Defaults to 50, or 1 - minimum\ndimension size of selected representation.",
                "optional_value": false
            },
            "zero_center": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "If `True`, compute standard PCA from covariance matrix.\nIf `False`, omit zero-centering variables\n(uses :class:`~sklearn.decomposition.TruncatedSVD`),\nwhich allows to handle sparse input efficiently.\nPassing `None` decides automatically based on sparseness of the data.",
                "optional_value": false
            },
            "svd_solver": {
                "type": "str",
                "default": "arpack",
                "optional": true,
                "description": "SVD solver to use:\n\n`'arpack'` (the default)\n  for the ARPACK wrapper in SciPy (:func:`~scipy.sparse.linalg.svds`)\n`'randomized'`\n  for the randomized algorithm due to Halko (2009).\n`'auto'`\n  chooses automatically depending on the size of the problem.\n`'lobpcg'`\n  An alternative SciPy solver.\n\n.. versionchanged:: 1.4.5\n   Default value changed from `'auto'` to `'arpack'`.\n\nEfficient computation of the principal components of a sparse matrix\ncurrently only works with the `'arpack`' or `'lobpcg'` solvers.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Change to use different initial states for the optimization.",
                "optional_value": false
            },
            "return_info": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Only relevant when not passing an :class:`~anndata.AnnData`:\nsee \u201c**Returns**\u201d.",
                "optional_value": false
            },
            "use_highly_variable": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to use highly variable genes only, stored in\n`.var['highly_variable']`.\nBy default uses them if they have been determined beforehand.",
                "optional_value": false
            },
            "dtype": {
                "type": "str",
                "default": "float32",
                "optional": true,
                "description": "Numpy data type string to which to convert the result.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If an :class:`~anndata.AnnData` is passed, determines whether a copy\nis returned. Is ignored otherwise.",
                "optional_value": false
            },
            "chunked": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, perform an incremental PCA on segments of `chunk_size`.\nThe incremental PCA automatically zero centers and ignores settings of\n`random_seed` and `svd_solver`. If `False`, perform a full PCA.",
                "optional_value": false
            },
            "chunk_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of observations to include in each chunk.\nRequired if `chunked=True` was passed.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Union[AnnData, ndarray, spmatrix]",
            "description": "X_pca : :class:`~scipy.sparse.spmatrix`, :class:`~numpy.ndarray`\nIf `data` is array-like and `return_info=False` was passed,\nthis function only returns `X_pca`\u2026\nadata : anndata.AnnData\n\u2026otherwise if `copy=True` it returns or else adds fields to `adata`:\n`.obsm['X_pca']`\nPCA representation of data.\n`.varm['PCs']`\nThe principal components containing the loadings.\n`.uns['pca']['variance_ratio']`\nRatio of explained variance.\n`.uns['pca']['variance']`\nExplained variance, equivalent to the eigenvalues of the\ncovariance matrix."
        },
        "Docstring": "Principal component analysis [Pedregosa11]_.\n\nComputes PCA coordinates, loadings and variance decomposition.\nUses the implementation of *scikit-learn* [Pedregosa11]_.\n\n.. versionchanged:: 1.5.0\n\n    In previous versions, computing a PCA on a sparse matrix would make a dense copy of\n    the array for mean centering.\n    As of scanpy 1.5.0, mean centering is implicit.\n    While results are extremely similar, they are not exactly the same.\n    If you would like to reproduce the old results, pass a dense array.\n\nParameters\n----------\ndata\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\nn_comps\n    Number of principal components to compute. Defaults to 50, or 1 - minimum\n    dimension size of selected representation.\nzero_center\n    If `True`, compute standard PCA from covariance matrix.\n    If `False`, omit zero-centering variables\n    (uses :class:`~sklearn.decomposition.TruncatedSVD`),\n    which allows to handle sparse input efficiently.\n    Passing `None` decides automatically based on sparseness of the data.\nsvd_solver\n    SVD solver to use:\n\n    `'arpack'` (the default)\n      for the ARPACK wrapper in SciPy (:func:`~scipy.sparse.linalg.svds`)\n    `'randomized'`\n      for the randomized algorithm due to Halko (2009).\n    `'auto'`\n      chooses automatically depending on the size of the problem.\n    `'lobpcg'`\n      An alternative SciPy solver.\n\n    .. versionchanged:: 1.4.5\n       Default value changed from `'auto'` to `'arpack'`.\n\n    Efficient computation of the principal components of a sparse matrix\n    currently only works with the `'arpack`' or `'lobpcg'` solvers.\n\nrandom_state\n    Change to use different initial states for the optimization.\nreturn_info\n    Only relevant when not passing an :class:`~anndata.AnnData`:\n    see \u201c**Returns**\u201d.\nuse_highly_variable\n    Whether to use highly variable genes only, stored in\n    `.var['highly_variable']`.\n    By default uses them if they have been determined beforehand.\ndtype\n    Numpy data type string to which to convert the result.\ncopy\n    If an :class:`~anndata.AnnData` is passed, determines whether a copy\n    is returned. Is ignored otherwise.\nchunked\n    If `True`, perform an incremental PCA on segments of `chunk_size`.\n    The incremental PCA automatically zero centers and ignores settings of\n    `random_seed` and `svd_solver`. If `False`, perform a full PCA.\nchunk_size\n    Number of observations to include in each chunk.\n    Required if `chunked=True` was passed.\n\nReturns\n-------\nX_pca : :class:`~scipy.sparse.spmatrix`, :class:`~numpy.ndarray`\n    If `data` is array-like and `return_info=False` was passed,\n    this function only returns `X_pca`\u2026\nadata : anndata.AnnData\n    \u2026otherwise if `copy=True` it returns or else adds fields to `adata`:\n\n    `.obsm['X_pca']`\n         PCA representation of data.\n    `.varm['PCs']`\n         The principal components containing the loadings.\n    `.uns['pca']['variance_ratio']`\n         Ratio of explained variance.\n    `.uns['pca']['variance']`\n         Explained variance, equivalent to the eigenvalues of the\n         covariance matrix.",
        "description": "Principal component analysis [Pedregosa11]_.Computes PCA coordinates, loadings and variance decomposition.\nUses the implementation of *scikit-learn* [Pedregosa11]_.\n\n.. versionchanged:: 1.5.0\n\n    In previous versions, computing a PCA on a sparse matrix would make a dense copy of\n    the array for mean centering.\n    As of scanpy 1.5.0, mean centering is implicit.\n    While results are extremely similar, they are not exactly the same.\n    If you would like to reproduce the old results, pass a dense array.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.pca(data=$, n_comps=@, zero_center=@, svd_solver=@, random_state=@, return_info=@, use_highly_variable=@, dtype=@, copy=@, chunked=@, chunk_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot.add_totals": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'add_totals'",
                "optional_value": false
            },
            "sort": {
                "type": "Literal[ascending, descending]",
                "default": "None",
                "optional": true,
                "description": "Set to either 'ascending' or 'descending' to reorder the categories\nby cell number",
                "optional_value": true
            },
            "size": {
                "type": "Optional[float]",
                "default": "0.8",
                "optional": true,
                "description": "size of the barplot. Corresponds to width when shown on\nthe right of the plot, or height when shown on top. The unit is the same\nas in matplotlib (inches).",
                "optional_value": false
            },
            "color": {
                "type": "Optional[Union[str, tuple[float, Ellipsis], Sequence[Union[str, tuple[float, Ellipsis]]]]]",
                "default": "None",
                "optional": true,
                "description": "Color for the bar plots or list of colors for each of the bar plots.\nBy default, each bar plot uses the colors assigned in\n`adata.uns[{groupby}_colors]`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Show barplot for the number of cells in in `groupby` category.\n\nThe barplot is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n\nParameters\n----------\nshow\n    Boolean to turn on (True) or off (False) 'add_totals'\nsort\n    Set to either 'ascending' or 'descending' to reorder the categories\n    by cell number\nsize\n    size of the barplot. Corresponds to width when shown on\n    the right of the plot, or height when shown on top. The unit is the same\n    as in matplotlib (inches).\ncolor\n    Color for the bar plots or list of colors for each of the bar plots.\n    By default, each bar plot uses the colors assigned in\n    `adata.uns[{groupby}_colors]`.\n\n\nReturns\n-------\nBasePlot\n\n\nExamples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_totals().show()",
        "description": "Show barplot for the number of cells in in `groupby` category.The barplot is by default shown on the right side of the plot or on top\nif the axes are swapped.",
        "example": "Examples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_totals().show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.MatrixPlot.add_totals(show=@, sort=$, size=@, color=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.heatmap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called\nwith default parameters.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Optional[Literal[var, obs]]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize that dimension between 0 and 1, meaning for each variable or observation,\nsubtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "swap_axes": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "By default, the x axis contains `var_names` (e.g. genes) and the y axis the `groupby`\ncategories (if any). By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.",
                "optional_value": false
            },
            "show_gene_labels": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "By default gene labels are shown when there are 50 or less genes. Otherwise the labels are removed.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`.\nOtherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. Values larger than vmax are plotted\nwith the same color as vmax.",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "Custom color normalization object from matplotlib. See\n`https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "List of :class:`~matplotlib.axes.Axes`"
        },
        "Docstring": "Heatmap of the expression values of genes.\n\nIf `groupby` is given, the heatmap is ordered by the respective group. For\nexample, a list of marker genes can be plotted, ordered by clustering. If\nthe `groupby` observation annotation is not categorical the observation\nannotation is turned into a categorical by binning the data into the number\nspecified in `num_categories`.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nvar_names\n    `var_names` should be a valid subset of `adata.var_names`.\n    If `var_names` is a mapping, then the key is used as label\n    to group the values (see `var_group_labels`). The mapping values\n    should be sequences of valid `adata.var_names`. In this\n    case either coloring or 'brackets' are used for the grouping\n    of var names depending on the plot. When `var_names` is a mapping,\n    then the `var_group_labels` and `var_group_positions` are set.\ngroupby\n    The key of the observation grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlog\n    Plot on logarithmic axis.\nnum_categories\n    Only used if groupby observation is not categorical. This value\n    determines the number of groups into which the groupby observation\n    should be subdivided.\ncategories_order\n    Order in which to show the categories. Note: add_dendrogram or add_totals\n    can change the categories order.\nfigsize\n    Figure size when `multi_panel=True`.\n    Otherwise the `rcParam['figure.figsize]` value is used.\n    Format is (width, height)\ndendrogram\n    If True or a valid dendrogram key, a dendrogram based on the hierarchical\n    clustering between the `groupby` categories is added.\n    The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n    If `tl.dendrogram` has not been called previously the function is called\n    with default parameters.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols.\n    By default `var_names` refer to the index column of the `.var` DataFrame.\n    Setting this option allows alternative names to be used.\nvar_group_positions\n    Use this parameter to highlight groups of `var_names`.\n    This will draw a 'bracket' or a color block between the given start and end\n    positions. If the parameter `var_group_labels` is set, the corresponding\n    labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n    will add a bracket between the fourth `var_name` and the tenth `var_name`.\n    By giving more positions, more brackets/color blocks are drawn.\nvar_group_labels\n    Labels for each of the `var_group_positions` that want to be highlighted.\nvar_group_rotation\n    Label rotation degrees.\n    By default, labels larger than 4 characters are rotated 90 degrees.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n    If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\nstandard_scale\n    Whether or not to standardize that dimension between 0 and 1, meaning for each variable or observation,\n    subtract the minimum and divide each by its maximum.\nswap_axes\n     By default, the x axis contains `var_names` (e.g. genes) and the y axis the `groupby`\n     categories (if any). By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.\nshow_gene_labels\n     By default gene labels are shown when there are 50 or less genes. Otherwise the labels are removed.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin.\nvmax\n    The value representing the upper limit of the color scale. Values larger than vmax are plotted\n    with the same color as vmax.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\nnorm\n    Custom color normalization object from matplotlib. See\n    `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.\n**kwds\n    Are passed to :func:`matplotlib.pyplot.imshow`.\n\nReturns\n-------\nList of :class:`~matplotlib.axes.Axes`\n\nExamples\n-------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.heatmap(adata, markers, groupby='bulk_labels', swap_axes=True)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\npl.rank_genes_groups_heatmap\ntl.rank_genes_groups",
        "description": "Heatmap of the expression values of genes.If `groupby` is given, the heatmap is ordered by the respective group. For\nexample, a list of marker genes can be plotted, ordered by clustering. If\nthe `groupby` observation annotation is not categorical the observation\nannotation is turned into a categorical by binning the data into the number\nspecified in `num_categories`.",
        "example": "Examples\n-------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.heatmap(adata, markers, groupby='bulk_labels', swap_axes=True)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\npl.rank_genes_groups_heatmap\ntl.rank_genes_groups",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.heatmap(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, dendrogram=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, standard_scale=$, swap_axes=@, show_gene_labels=@, show=@, save=@, figsize=@, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.embedding_density": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "basis": {
                "type": "str",
                "default": "umap",
                "optional": true,
                "description": "The embedding over which the density will be calculated. This embedded\nrepresentation should be found in `adata.obsm['X_[basis]']``.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for categorical observation/cell annotation for which densities\nare calculated per category.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the `.obs` covariate that will be added with the density\nestimates.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The embedding dimensions over which the density should be calculated.\nThis is limited to two components.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Updates `adata.obs` with an additional field specified by the `key_added`",
            "description": "parameter. This parameter defaults to `[basis]_density_[groupby]`, where\n`[basis]` is one of `umap`, `diffmap`, `pca`, `tsne`, or `draw_graph_fa`\nand `[groupby]` denotes the parameter input.\nUpdates `adata.uns` with an additional field `[key_added]_params`."
        },
        "Docstring": "Calculate the density of cells in an embedding (per condition).\n\nGaussian kernel density estimation is used to calculate the density of\ncells in an embedded space. This can be performed per category over a\ncategorical cell annotation. The cell density can be plotted using the\n`pl.embedding_density` function.\n\nNote that density values are scaled to be between 0 and 1. Thus, the\ndensity value at each cell is only comparable to densities in\nthe same category.\n\nBeware that the KDE estimate used (`scipy.stats.gaussian_kde`) becomes\nunreliable if you don't have enough cells in a category.\n\nThis function was written by Sophie Tritschler and implemented into\nScanpy by Malte Luecken.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nbasis\n    The embedding over which the density will be calculated. This embedded\n    representation should be found in `adata.obsm['X_[basis]']``.\ngroupby\n    Key for categorical observation/cell annotation for which densities\n    are calculated per category.\nkey_added\n    Name of the `.obs` covariate that will be added with the density\n    estimates.\ncomponents\n    The embedding dimensions over which the density should be calculated.\n    This is limited to two components.\n\nReturns\n-------\nUpdates `adata.obs` with an additional field specified by the `key_added`\nparameter. This parameter defaults to `[basis]_density_[groupby]`, where\n`[basis]` is one of `umap`, `diffmap`, `pca`, `tsne`, or `draw_graph_fa`\nand `[groupby]` denotes the parameter input.\nUpdates `adata.uns` with an additional field `[key_added]_params`.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.umap(adata)\n    sc.tl.embedding_density(adata, basis='umap', groupby='phase')\n    sc.pl.embedding_density(\n        adata, basis='umap', key='umap_density_phase', group='G1'\n    )\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.embedding_density(\n        adata, basis='umap', key='umap_density_phase', group='S'\n    )\n\n.. currentmodule:: scanpy\n\nSee also\n--------\npl.embedding_density",
        "description": "Calculate the density of cells in an embedding (per condition).Gaussian kernel density estimation is used to calculate the density of\ncells in an embedded space. This can be performed per category over a\ncategorical cell annotation. The cell density can be plotted using the\n`pl.embedding_density` function.\n\nNote that density values are scaled to be between 0 and 1. Thus, the\ndensity value at each cell is only comparable to densities in\nthe same category.\n\nBeware that the KDE estimate used (`scipy.stats.gaussian_kde`) becomes\nunreliable if you don't have enough cells in a category.\n\nThis function was written by Sophie Tritschler and implemented into\nScanpy by Malte Luecken.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.umap(adata)\n    sc.tl.embedding_density(adata, basis='umap', groupby='phase')\n    sc.pl.embedding_density(\n        adata, basis='umap', key='umap_density_phase', group='G1'\n    )\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.embedding_density(\n        adata, basis='umap', key='umap_density_phase', group='S'\n    )\n\n.. currentmodule:: scanpy\n\nSee also\n--------\npl.embedding_density",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.embedding_density(adata=$, basis=@, groupby=@, key_added=@, components=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.mnn_correct": {
        "Parameters": {
            "datas": {
                "type": "Union[AnnData, ndarray]",
                "default": null,
                "optional": false,
                "description": "Expression matrices or AnnData objects. Matrices should be shaped like\nn_obs \u00d7 n_vars (n_cell \u00d7 n_gene) and have consistent number of columns.\nAnnData objects should have same number of variables.",
                "optional_value": true
            },
            "var_index": {
                "type": "Optional[Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "The index (list of str) of vars (genes). Necessary when using only a\nsubset of vars to perform MNN correction, and should be supplied with\n`var_subset`. When `datas` are AnnData objects, `var_index` is ignored.",
                "optional_value": false
            },
            "var_subset": {
                "type": "Optional[Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "The subset of vars (list of str) to be used when performing MNN\ncorrection. Typically, a list of highly variable genes (HVGs).\nWhen set to `None`, uses all vars.",
                "optional_value": false
            },
            "batch_key": {
                "type": "str",
                "default": "batch",
                "optional": true,
                "description": "The `batch_key` for :meth:`~anndata.AnnData.concatenate`.\nOnly valid when `do_concatenate` and supplying `AnnData` objects.",
                "optional_value": false
            },
            "index_unique": {
                "type": "str",
                "default": "-",
                "optional": true,
                "description": "The `index_unique` for :meth:`~anndata.AnnData.concatenate`.\nOnly valid when `do_concatenate` and supplying `AnnData` objects.",
                "optional_value": false
            },
            "batch_categories": {
                "type": "Optional[Collection[Any]]",
                "default": "None",
                "optional": true,
                "description": "The `batch_categories` for :meth:`~anndata.AnnData.concatenate`.\nOnly valid when `do_concatenate` and supplying AnnData objects.",
                "optional_value": true
            },
            "k": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of mutual nearest neighbors.",
                "optional_value": false
            },
            "sigma": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "The bandwidth of the Gaussian smoothing kernel used to compute the\ncorrection vectors. Default is 1.",
                "optional_value": false
            },
            "cos_norm_in": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether cosine normalization should be performed on the input data prior\nto calculating distances between cells.",
                "optional_value": false
            },
            "cos_norm_out": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether cosine normalization should be performed prior to computing corrected expression values.",
                "optional_value": false
            },
            "svd_dim": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of dimensions to use for summarizing biological substructure\nwithin each batch. If None, biological components will not be removed\nfrom the correction vectors.",
                "optional_value": false
            },
            "var_adj": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to adjust variance of the correction vectors. Note this step\ntakes most computing time.",
                "optional_value": false
            },
            "compute_angle": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to compute the angle between each cell\u2019s correction vector and\nthe biological subspace of the reference batch.",
                "optional_value": false
            },
            "mnn_order": {
                "type": "Optional[Sequence[int]]",
                "default": "None",
                "optional": true,
                "description": "The order in which batches are to be corrected. When set to None, datas\nare corrected sequentially.",
                "optional_value": false
            },
            "svd_mode": {
                "type": "Literal[svd, rsvd, irlb]",
                "default": "rsvd",
                "optional": true,
                "description": "`'svd'` computes SVD using a non-randomized SVD-via-ID algorithm,\nwhile `'rsvd'` uses a randomized version. `'irlb'` perfores\ntruncated SVD by implicitly restarted Lanczos bidiagonalization\n(forked from https://github.com/airysen/irlbpy).",
                "optional_value": true
            },
            "do_concatenate": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to concatenate the corrected matrices or AnnData objects. Default is True.",
                "optional_value": false
            },
            "save_raw": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to save the original expression data in the\n:attr:`~anndata.AnnData.raw` attribute.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of jobs. When set to `None`, automatically uses\n:attr:`scanpy._settings.ScanpyConfig.n_jobs`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "tuple[Union[ndarray, AnnData], List[DataFrame], Optional[List[tuple[Optional[float], int]]]]",
            "description": "datas\nCorrected matrix/matrices or AnnData object/objects, depending on the\ninput type and `do_concatenate`.\nmnn_list\nA list containing MNN pairing information as DataFrames in each iteration step.\nangle_list\nA list containing angles of each batch."
        },
        "Docstring": "Correct batch effects by matching mutual nearest neighbors [Haghverdi18]_ [Kang18]_.\n\nThis uses the implementation of `mnnpy\n<https://github.com/chriscainx/mnnpy>`__ [Kang18]_.\n\nDepending on `do_concatenate`, returns matrices or `AnnData` objects in the\noriginal order containing corrected expression values or a concatenated\nmatrix or AnnData object.\n\nBe reminded that it is not advised to use the corrected data matrices for\ndifferential expression testing.\n\nMore information and bug reports `here <https://github.com/chriscainx/mnnpy>`__.\n\nParameters\n----------\ndatas\n    Expression matrices or AnnData objects. Matrices should be shaped like\n    n_obs \u00d7 n_vars (n_cell \u00d7 n_gene) and have consistent number of columns.\n    AnnData objects should have same number of variables.\nvar_index\n    The index (list of str) of vars (genes). Necessary when using only a\n    subset of vars to perform MNN correction, and should be supplied with\n    `var_subset`. When `datas` are AnnData objects, `var_index` is ignored.\nvar_subset\n    The subset of vars (list of str) to be used when performing MNN\n    correction. Typically, a list of highly variable genes (HVGs).\n    When set to `None`, uses all vars.\nbatch_key\n    The `batch_key` for :meth:`~anndata.AnnData.concatenate`.\n    Only valid when `do_concatenate` and supplying `AnnData` objects.\nindex_unique\n    The `index_unique` for :meth:`~anndata.AnnData.concatenate`.\n    Only valid when `do_concatenate` and supplying `AnnData` objects.\nbatch_categories\n    The `batch_categories` for :meth:`~anndata.AnnData.concatenate`.\n    Only valid when `do_concatenate` and supplying AnnData objects.\nk\n    Number of mutual nearest neighbors.\nsigma\n    The bandwidth of the Gaussian smoothing kernel used to compute the\n    correction vectors. Default is 1.\ncos_norm_in\n    Whether cosine normalization should be performed on the input data prior\n    to calculating distances between cells.\ncos_norm_out\n    Whether cosine normalization should be performed prior to computing corrected expression values.\nsvd_dim\n    The number of dimensions to use for summarizing biological substructure\n    within each batch. If None, biological components will not be removed\n    from the correction vectors.\nvar_adj\n    Whether to adjust variance of the correction vectors. Note this step\n    takes most computing time.\ncompute_angle\n    Whether to compute the angle between each cell\u2019s correction vector and\n    the biological subspace of the reference batch.\nmnn_order\n    The order in which batches are to be corrected. When set to None, datas\n    are corrected sequentially.\nsvd_mode\n    `'svd'` computes SVD using a non-randomized SVD-via-ID algorithm,\n    while `'rsvd'` uses a randomized version. `'irlb'` perfores\n    truncated SVD by implicitly restarted Lanczos bidiagonalization\n    (forked from https://github.com/airysen/irlbpy).\ndo_concatenate\n    Whether to concatenate the corrected matrices or AnnData objects. Default is True.\nsave_raw\n    Whether to save the original expression data in the\n    :attr:`~anndata.AnnData.raw` attribute.\nn_jobs\n    The number of jobs. When set to `None`, automatically uses\n    :attr:`scanpy._settings.ScanpyConfig.n_jobs`.\nkwargs\n    optional keyword arguments for irlb.\n\nReturns\n-------\ndatas\n    Corrected matrix/matrices or AnnData object/objects, depending on the\n    input type and `do_concatenate`.\nmnn_list\n    A list containing MNN pairing information as DataFrames in each iteration step.\nangle_list\n    A list containing angles of each batch.",
        "description": "Correct batch effects by matching mutual nearest neighbors [Haghverdi18]_ [Kang18]_.This uses the implementation of `mnnpy\n<https://github.com/chriscainx/mnnpy>`__ [Kang18]_.\n\nDepending on `do_concatenate`, returns matrices or `AnnData` objects in the\noriginal order containing corrected expression values or a concatenated\nmatrix or AnnData object.\n\nBe reminded that it is not advised to use the corrected data matrices for\ndifferential expression testing.\n\nMore information and bug reports `here <https://github.com/chriscainx/mnnpy>`__.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.mnn_correct(datas=$, var_index=@, var_subset=@, batch_key=@, index_unique=@, batch_categories=$, k=@, sigma=@, cos_norm_in=@, cos_norm_out=@, svd_dim=@, var_adj=@, compute_angle=@, mnn_order=@, svd_mode=$, do_concatenate=@, save_raw=@, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.dca": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An anndata file with `.raw` attribute representing raw counts.",
                "optional_value": true
            },
            "mode": {
                "type": "Literal[denoise, latent]",
                "default": "denoise",
                "optional": true,
                "description": "`denoise` overwrites `adata.X` with denoised expression values.\nIn `latent` mode DCA adds `adata.obsm['X_dca']` to given adata\nobject. This matrix represent latent representation of cells via DCA.",
                "optional_value": true
            },
            "ae_type": {
                "type": "Literal[zinb-conddisp, zinb, nb-conddisp, nb]",
                "default": "nb-conddisp",
                "optional": true,
                "description": "Type of the autoencoder. Return values and the architecture is\ndetermined by the type e.g. `nb` does not provide dropout\nprobabilities. Types that end with \"-conddisp\", assumes that dispersion is mean dependant.",
                "optional_value": true
            },
            "normalize_per_cell": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If true, library size normalization is performed using\nthe `sc.pp.normalize_per_cell` function in Scanpy and saved into adata\nobject. Mean layer is re-introduces library size differences by\nscaling the mean value of each cell in the output layer. See the\nmanuscript for more details.",
                "optional_value": false
            },
            "scale": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If true, the input of the autoencoder is centered using\n`sc.pp.scale` function of Scanpy. Note that the output is kept as raw\ncounts as loss functions are designed for the count data.",
                "optional_value": false
            },
            "log1p": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If true, the input of the autoencoder is log transformed with a\npseudocount of one using `sc.pp.log1p` function of Scanpy.",
                "optional_value": false
            },
            "hidden_size": {
                "type": "Sequence[int]",
                "default": "(64, 32, 64)",
                "optional": true,
                "description": "Width of hidden layers.",
                "optional_value": false
            },
            "hidden_dropout": {
                "type": "Union[float, Sequence[float]]",
                "default": "0.0",
                "optional": true,
                "description": "Probability of weight dropout in the autoencoder (per layer if list\nor tuple).",
                "optional_value": false
            },
            "batchnorm": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If true, batch normalization is performed.",
                "optional_value": false
            },
            "activation": {
                "type": "str",
                "default": "relu",
                "optional": true,
                "description": "Activation function of hidden layers.",
                "optional_value": false
            },
            "init": {
                "type": "str",
                "default": "glorot_uniform",
                "optional": true,
                "description": "Initialization method used to initialize weights.",
                "optional_value": false
            },
            "epochs": {
                "type": "int",
                "default": "300",
                "optional": true,
                "description": "Number of total epochs in training.",
                "optional_value": false
            },
            "reduce_lr": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "Reduces learning rate if validation loss does not improve in given number of epochs.",
                "optional_value": false
            },
            "early_stop": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "Stops training if validation loss does not improve in given number of epochs.",
                "optional_value": false
            },
            "batch_size": {
                "type": "int",
                "default": "32",
                "optional": true,
                "description": "Number of samples in the batch used for SGD.",
                "optional_value": false
            },
            "optimizer": {
                "type": "str",
                "default": "RMSprop",
                "optional": true,
                "description": "Type of optimization method used for training.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Seed for python, numpy and tensorflow.",
                "optional_value": false
            },
            "threads": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of threads to use in training. All cores are used by default.",
                "optional_value": false
            },
            "learning_rate": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Learning rate to use in the training.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If true, prints additional information about training and architecture.",
                "optional_value": false
            },
            "return_model": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If true, trained autoencoder object is returned. See \"Returns\".",
                "optional_value": false
            },
            "return_info": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If true, all additional parameters of DCA are stored in `adata.obsm` such as dropout\nprobabilities (obsm['X_dca_dropout']) and estimated dispersion values\n(obsm['X_dca_dispersion']), in case that autoencoder is of type\nzinb or zinb-conddisp.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If true, a copy of anndata is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "If `copy` is true and `return_model` is false, AnnData object is returned.\nIn \"denoise\" mode, `adata.X` is overwritten with the denoised values.\nIn \"latent\" mode, latent low dimensional representation of cells are stored\nin `adata.obsm['X_dca']` and `adata.X` is not modified.\nNote that these values are not corrected for library size effects.\nIf `return_info` is true, all estimated distribution parameters are stored\nin AnnData like this:\n`.obsm[\"X_dca_dropout\"]`\nThe mixture coefficient (pi) of the zero component in ZINB,\ni.e. dropout probability (if `ae_type` is `zinb` or `zinb-conddisp`).\n`.obsm[\"X_dca_dispersion\"]`\nThe dispersion parameter of NB.\n`.uns[\"dca_loss_history\"]`\nThe loss history of the training.\nSee `.history` attribute of Keras History class for mode details.\nFinally, the raw counts are stored in `.raw` attribute of AnnData object.\nIf `return_model` is given, trained model is returned.\nWhen both `copy` and `return_model` are true,\na tuple of anndata and model is returned in that order."
        },
        "Docstring": "Deep count autoencoder [Eraslan18]_.\n\nFits a count autoencoder to the raw count data given in the anndata object\nin order to denoise the data and to capture hidden representation of\ncells in low dimensions. Type of the autoencoder and return values are\ndetermined by the parameters.\n\n.. note::\n    More information and bug reports `here <https://github.com/theislab/dca>`__.\n\nParameters\n----------\nadata\n    An anndata file with `.raw` attribute representing raw counts.\nmode\n    `denoise` overwrites `adata.X` with denoised expression values.\n    In `latent` mode DCA adds `adata.obsm['X_dca']` to given adata\n    object. This matrix represent latent representation of cells via DCA.\nae_type\n    Type of the autoencoder. Return values and the architecture is\n    determined by the type e.g. `nb` does not provide dropout\n    probabilities. Types that end with \"-conddisp\", assumes that dispersion is mean dependant.\nnormalize_per_cell\n    If true, library size normalization is performed using\n    the `sc.pp.normalize_per_cell` function in Scanpy and saved into adata\n    object. Mean layer is re-introduces library size differences by\n    scaling the mean value of each cell in the output layer. See the\n    manuscript for more details.\nscale\n    If true, the input of the autoencoder is centered using\n    `sc.pp.scale` function of Scanpy. Note that the output is kept as raw\n    counts as loss functions are designed for the count data.\nlog1p\n    If true, the input of the autoencoder is log transformed with a\n    pseudocount of one using `sc.pp.log1p` function of Scanpy.\nhidden_size\n    Width of hidden layers.\nhidden_dropout\n    Probability of weight dropout in the autoencoder (per layer if list\n    or tuple).\nbatchnorm\n    If true, batch normalization is performed.\nactivation\n    Activation function of hidden layers.\ninit\n    Initialization method used to initialize weights.\nnetwork_kwds\n    Additional keyword arguments for the autoencoder.\nepochs\n    Number of total epochs in training.\nreduce_lr\n    Reduces learning rate if validation loss does not improve in given number of epochs.\nearly_stop\n    Stops training if validation loss does not improve in given number of epochs.\nbatch_size\n    Number of samples in the batch used for SGD.\noptimizer\n    Type of optimization method used for training.\nrandom_state\n    Seed for python, numpy and tensorflow.\nthreads\n    Number of threads to use in training. All cores are used by default.\nlearning_rate\n    Learning rate to use in the training.\nverbose\n    If true, prints additional information about training and architecture.\ntraining_kwds\n    Additional keyword arguments for the training process.\nreturn_model\n    If true, trained autoencoder object is returned. See \"Returns\".\nreturn_info\n    If true, all additional parameters of DCA are stored in `adata.obsm` such as dropout\n    probabilities (obsm['X_dca_dropout']) and estimated dispersion values\n    (obsm['X_dca_dispersion']), in case that autoencoder is of type\n    zinb or zinb-conddisp.\ncopy\n    If true, a copy of anndata is returned.\n\nReturns\n-------\nIf `copy` is true and `return_model` is false, AnnData object is returned.\n\nIn \"denoise\" mode, `adata.X` is overwritten with the denoised values.\nIn \"latent\" mode, latent low dimensional representation of cells are stored\nin `adata.obsm['X_dca']` and `adata.X` is not modified.\nNote that these values are not corrected for library size effects.\n\nIf `return_info` is true, all estimated distribution parameters are stored\nin AnnData like this:\n\n`.obsm[\"X_dca_dropout\"]`\n    The mixture coefficient (pi) of the zero component in ZINB,\n    i.e. dropout probability (if `ae_type` is `zinb` or `zinb-conddisp`).\n`.obsm[\"X_dca_dispersion\"]`\n    The dispersion parameter of NB.\n`.uns[\"dca_loss_history\"]`\n    The loss history of the training.\n    See `.history` attribute of Keras History class for mode details.\n\nFinally, the raw counts are stored in `.raw` attribute of AnnData object.\n\nIf `return_model` is given, trained model is returned.\nWhen both `copy` and `return_model` are true,\na tuple of anndata and model is returned in that order.",
        "description": "Deep count autoencoder [Eraslan18]_.Fits a count autoencoder to the raw count data given in the anndata object\nin order to denoise the data and to capture hidden representation of\ncells in low dimensions. Type of the autoencoder and return values are\ndetermined by the parameters.\n\n.. note::\n    More information and bug reports `here <https://github.com/theislab/dca>`__.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.dca(adata=$, mode=$, ae_type=$, normalize_per_cell=@, scale=@, log1p=@, hidden_size=@, hidden_dropout=@, batchnorm=@, activation=@, init=@, epochs=@, reduce_lr=@, early_stop=@, batch_size=@, optimizer=@, random_state=@, threads=@, learning_rate=@, verbose=@, return_model=@, return_info=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pl.trimap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show edges.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Width of edges.",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Union[str, tuple[float, Ellipsis]]",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, List[Axes]]]",
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot in TriMap basis.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nedges\n    Show edges.\nedges_width\n    Width of edges.\nedges_color\n    Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\nneighbors_key\n    Where to look for neighbors connectivities.\n    If not specified, this looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, this looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\narrows\n    Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\narrows_kwds\n    Passed to :meth:`~matplotlib.axes.Axes.quiver`\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.",
        "description": "Scatter plot in TriMap basis.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pl.trimap(adata=$, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot.legend": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Set to 'False' to hide the default plot of the legend. This sets the\nlegend width to zero which will result in a wider main plot.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "Expression\nlevel in group",
                "optional": true,
                "description": "Legend title. Appears on top of the color bar. Use '\\n' to add line breaks.",
                "optional_value": false
            },
            "width": {
                "type": "Optional[float]",
                "default": "1.5",
                "optional": true,
                "description": "Width of the legend. The unit is the same as in matplotlib (inches)",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Configure legend parameters\n\nParameters\n----------\nshow\n    Set to 'False' to hide the default plot of the legend. This sets the\n    legend width to zero which will result in a wider main plot.\ntitle\n    Legend title. Appears on top of the color bar. Use '\\n' to add line breaks.\nwidth\n    Width of the legend. The unit is the same as in matplotlib (inches)\n\nReturns\n-------\nBasePlot\n\n\nExamples\n--------\n\nSet legend title:\n\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> dp = sc.pl.BasePlot(adata, markers, groupby='bulk_labels')\n>>> dp.legend(colorbar_title='log(UMI counts + 1)').show()",
        "description": "Configure legend parameters",
        "example": "Examples\n--------\n\nSet legend title:\n\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> dp = sc.pl.BasePlot(adata, markers, groupby='bulk_labels')\n>>> dp.legend(colorbar_title='log(UMI counts + 1)').show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.MatrixPlot.legend(show=@, title=@, width=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_loom": {
        "Parameters": {
            "filename": {
                "type": "PathLike",
                "default": null,
                "optional": false,
                "description": "The filename.",
                "optional_value": true
            },
            "sparse": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to read the data matrix as sparse.",
                "optional_value": false
            },
            "cleanup": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to collapse all obs/var fields that only store\none unique value into `.uns['loom-.']`.",
                "optional_value": false
            },
            "X_name": {
                "type": "str",
                "default": "spliced",
                "optional": true,
                "description": "Loompy key with which the data matrix :attr:`~anndata.AnnData.X` is initialized.",
                "optional_value": false
            },
            "obs_names": {
                "type": "str",
                "default": "CellID",
                "optional": true,
                "description": "Loompy key where the observation/cell names are stored.",
                "optional_value": false
            },
            "obsm_names": {
                "type": "Optional[Mapping[str, Iterable[str]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "var_names": {
                "type": "str",
                "default": "Gene",
                "optional": true,
                "description": "Loompy key where the variable/gene names are stored.",
                "optional_value": false
            },
            "varm_names": {
                "type": "Optional[Mapping[str, Iterable[str]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "dtype": {
                "type": "str",
                "default": "float32",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "obsm_mapping": {
                "type": "Mapping[str, Iterable[str]]",
                "default": "{}",
                "optional": true,
                "description": "Loompy keys which will be constructed into observation matrices",
                "optional_value": false
            },
            "varm_mapping": {
                "type": "Mapping[str, Iterable[str]]",
                "default": "{}",
                "optional": true,
                "description": "Loompy keys which will be constructed into variable matrices",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Read `.loom`-formatted hdf5 file.\n\nThis reads the whole file into memory.\n\nBeware that you have to explicitly state when you want to read the file as\nsparse data.\n\nParameters\n----------\nfilename\n    The filename.\nsparse\n    Whether to read the data matrix as sparse.\ncleanup\n    Whether to collapse all obs/var fields that only store\n    one unique value into `.uns['loom-.']`.\nX_name\n    Loompy key with which the data matrix :attr:`~anndata.AnnData.X` is initialized.\nobs_names\n    Loompy key where the observation/cell names are stored.\nobsm_mapping\n    Loompy keys which will be constructed into observation matrices\nvar_names\n    Loompy key where the variable/gene names are stored.\nvarm_mapping\n    Loompy keys which will be constructed into variable matrices\n**kwargs:\n    Arguments to loompy.connect\n\nExample\n-------\n\n.. code:: python\n\n    pbmc = anndata.read_loom(\n        \"pbmc.loom\",\n        sparse=True,\n        X_name=\"lognorm\",\n        obs_names=\"cell_names\",\n        var_names=\"gene_names\",\n        obsm_mapping={\n            \"X_umap\": [\"umap_1\", \"umap_2\"]\n        }\n    )",
        "description": "Read `.loom`-formatted hdf5 file.This reads the whole file into memory.\n\nBeware that you have to explicitly state when you want to read the file as\nsparse data.",
        "example": "Example\n-------\n\n.. code:: python\n\n    pbmc = anndata.read_loom(\n        \"pbmc.loom\",\n        sparse=True,\n        X_name=\"lognorm\",\n        obs_names=\"cell_names\",\n        var_names=\"gene_names\",\n        obsm_mapping={\n            \"X_umap\": [\"umap_1\", \"umap_2\"]\n        }\n    )",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_loom(filename=$, sparse=@, cleanup=@, X_name=@, obs_names=@, obsm_names=@, var_names=@, varm_names=@, dtype=@, obsm_mapping=@, varm_mapping=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.paga": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for categorical in `adata.obs`. You can pass your predefined groups\nby choosing any categorical annotation of observations. Default:\nThe first present key of `'leiden'` or `'louvain'`.",
                "optional_value": false
            },
            "use_rna_velocity": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Use RNA velocity to orient edges in the abstracted graph and estimate\ntransitions. Requires that `adata.uns` contains a directed single-cell\ngraph with key `['velocity_graph']`. This feature might be subject\nto change in the future.",
                "optional_value": false
            },
            "model": {
                "type": "Literal[v1.2, v1.0]",
                "default": "v1.2",
                "optional": true,
                "description": "The PAGA connectivity model.",
                "optional_value": true
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, paga looks `.uns['neighbors']` for neighbors settings\nand `.obsp['connectivities']`, `.obsp['distances']` for connectivities and\ndistances respectively (default storage places for `pp.neighbors`).\nIf specified, paga looks `.uns[neighbors_key]` for neighbors settings and\n`.obsp[.uns[neighbors_key]['connectivities_key']]`,\n`.obsp[.uns[neighbors_key]['distances_key']]` for connectivities and distances\nrespectively.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Copy `adata` before computation and return a copy. Otherwise, perform\ncomputation inplace and return `None`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "**connectivities** : :class:`numpy.ndarray` (adata.uns['connectivities'])\nThe full adjacency matrix of the abstracted graph, weights correspond to\nconfidence in the connectivities of partitions.\n**connectivities_tree** : :class:`scipy.sparse.csr_matrix` (adata.uns['connectivities_tree'])\nThe adjacency matrix of the tree-like subgraph that best explains\nthe topology.\nNotes\nTogether with a random walk-based distance measure\n(e.g. :func:`scanpy.tl.dpt`) this generates a partial coordinatization of\ndata useful for exploring and explaining its variation.\n.. currentmodule:: scanpy\nSee Also\npl.paga\npl.paga_path\npl.paga_compare"
        },
        "Docstring": "Mapping out the coarse-grained connectivity structures of complex manifolds [Wolf19]_.\n\nBy quantifying the connectivity of partitions (groups, clusters) of the\nsingle-cell graph, partition-based graph abstraction (PAGA) generates a much\nsimpler abstracted graph (*PAGA graph*) of partitions, in which edge weights\nrepresent confidence in the presence of connections. By thresholding this\nconfidence in :func:`~scanpy.pl.paga`, a much simpler representation of the\nmanifold data is obtained, which is nonetheless faithful to the topology of\nthe manifold.\n\nThe confidence should be interpreted as the ratio of the actual versus the\nexpected value of connections under the null model of randomly connecting\npartitions. We do not provide a p-value as this null model does not\nprecisely capture what one would consider \"connected\" in real data, hence it\nstrongly overestimates the expected value. See an extensive discussion of\nthis in [Wolf19]_.\n\n.. note::\n    Note that you can use the result of :func:`~scanpy.pl.paga` in\n    :func:`~scanpy.tl.umap` and :func:`~scanpy.tl.draw_graph` via\n    `init_pos='paga'` to get single-cell embeddings that are typically more\n    faithful to the global topology.\n\nParameters\n----------\nadata\n    An annotated data matrix.\ngroups\n    Key for categorical in `adata.obs`. You can pass your predefined groups\n    by choosing any categorical annotation of observations. Default:\n    The first present key of `'leiden'` or `'louvain'`.\nuse_rna_velocity\n    Use RNA velocity to orient edges in the abstracted graph and estimate\n    transitions. Requires that `adata.uns` contains a directed single-cell\n    graph with key `['velocity_graph']`. This feature might be subject\n    to change in the future.\nmodel\n    The PAGA connectivity model.\nneighbors_key\n    If not specified, paga looks `.uns['neighbors']` for neighbors settings\n    and `.obsp['connectivities']`, `.obsp['distances']` for connectivities and\n    distances respectively (default storage places for `pp.neighbors`).\n    If specified, paga looks `.uns[neighbors_key]` for neighbors settings and\n    `.obsp[.uns[neighbors_key]['connectivities_key']]`,\n    `.obsp[.uns[neighbors_key]['distances_key']]` for connectivities and distances\n    respectively.\ncopy\n    Copy `adata` before computation and return a copy. Otherwise, perform\n    computation inplace and return `None`.\n\nReturns\n-------\n**connectivities** : :class:`numpy.ndarray` (adata.uns['connectivities'])\n    The full adjacency matrix of the abstracted graph, weights correspond to\n    confidence in the connectivities of partitions.\n**connectivities_tree** : :class:`scipy.sparse.csr_matrix` (adata.uns['connectivities_tree'])\n    The adjacency matrix of the tree-like subgraph that best explains\n    the topology.\n\nNotes\n-----\nTogether with a random walk-based distance measure\n(e.g. :func:`scanpy.tl.dpt`) this generates a partial coordinatization of\ndata useful for exploring and explaining its variation.\n\n.. currentmodule:: scanpy\n\nSee Also\n--------\npl.paga\npl.paga_path\npl.paga_compare",
        "description": "Mapping out the coarse-grained connectivity structures of complex manifolds [Wolf19]_.By quantifying the connectivity of partitions (groups, clusters) of the\nsingle-cell graph, partition-based graph abstraction (PAGA) generates a much\nsimpler abstracted graph (*PAGA graph*) of partitions, in which edge weights\nrepresent confidence in the presence of connections. By thresholding this\nconfidence in :func:`~scanpy.pl.paga`, a much simpler representation of the\nmanifold data is obtained, which is nonetheless faithful to the topology of\nthe manifold.\n\nThe confidence should be interpreted as the ratio of the actual versus the\nexpected value of connections under the null model of randomly connecting\npartitions. We do not provide a p-value as this null model does not\nprecisely capture what one would consider \"connected\" in real data, hence it\nstrongly overestimates the expected value. See an extensive discussion of\nthis in [Wolf19]_.\n\n.. note::\n    Note that you can use the result of :func:`~scanpy.pl.paga` in\n    :func:`~scanpy.tl.umap` and :func:`~scanpy.tl.draw_graph` via\n    `init_pos='paga'` to get single-cell embeddings that are typically more\n    faithful to the global topology.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.paga(adata=$, groups=@, use_rna_velocity=@, model=$, neighbors_key=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.get.var_df": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object to get values from.",
                "optional_value": true
            },
            "keys": {
                "type": "Iterable[str]",
                "default": "()",
                "optional": true,
                "description": "Keys from either `.obs_names`, or `.var.columns`.",
                "optional_value": false
            },
            "varm_keys": {
                "type": "Iterable[tuple[str, int]]",
                "default": "()",
                "optional": true,
                "description": "Tuple of `(key from varm, column index of varm[key])`.",
                "optional_value": false
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Layer of `adata` to use as expression values.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": "A dataframe with `adata.var_names` as index, and values specified by `keys`\nand `varm_keys`."
        },
        "Docstring": "Return values for observations in adata.\n\nParams\n------\nadata\n    AnnData object to get values from.\nkeys\n    Keys from either `.obs_names`, or `.var.columns`.\nvarm_keys\n    Tuple of `(key from varm, column index of varm[key])`.\nlayer\n    Layer of `adata` to use as expression values.\n\nReturns\n-------\nA dataframe with `adata.var_names` as index, and values specified by `keys`\nand `varm_keys`.",
        "description": "Return values for observations in adata.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.get.var_df(adata=$, keys=@, varm_keys=@, layer=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.recipe_seurat": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "log": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "plot": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Normalization and filtering as of Seurat [Satija15]_.\n\nThis uses a particular preprocessing.\n\nExpects non-logarithmized data.\nIf using logarithmized data, pass `log=False`.",
        "description": "Normalization and filtering as of Seurat [Satija15]_.This uses a particular preprocessing.\n\nExpects non-logarithmized data.\nIf using logarithmized data, pass `log=False`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.recipe_seurat(adata=$, log=@, plot=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.rank_genes_groups": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "The key of the observations grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "groups": {
                "type": "Union[Literal[all], Iterable[str]]",
                "default": "all",
                "optional": true,
                "description": "Subset of groups, e.g. [`'g1'`, `'g2'`, `'g3'`], to which comparison\nshall be restricted, or `'all'` (default), for all groups.",
                "optional_value": false
            },
            "reference": {
                "type": "str",
                "default": "rest",
                "optional": true,
                "description": "If `'rest'`, compare each group to the union of the rest of the group.\nIf a group identifier, compare with respect to this group.",
                "optional_value": false
            },
            "n_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of genes that appear in the returned tables.\nDefaults to all genes.",
                "optional_value": false
            },
            "rankby_abs": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Rank genes by the absolute value of the score, not by the\nscore. The returned scores are never the absolute values.",
                "optional_value": false
            },
            "pts": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Compute the fraction of cells expressing the genes.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key in `adata.uns` information is saved to.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "method": {
                "type": "Optional[Literal[logreg, t-test, wilcoxon, t-test_overestim_var]]",
                "default": "None",
                "optional": true,
                "description": "The default method is `'t-test'`,\n`'t-test_overestim_var'` overestimates variance of each group,\n`'wilcoxon'` uses Wilcoxon rank-sum,\n`'logreg'` uses logistic regression. See [Ntranos18]_,\n`here <https://github.com/scverse/scanpy/issues/95>`__ and `here\n<http://www.nxn.se/valent/2018/3/5/actionable-scrna-seq-clusters>`__,\nfor why this is meaningful.",
                "optional_value": true
            },
            "corr_method": {
                "type": "Literal[benjamini-hochberg, bonferroni]",
                "default": "benjamini-hochberg",
                "optional": true,
                "description": "p-value correction method.\nUsed only for `'t-test'`, `'t-test_overestim_var'`, and `'wilcoxon'`.",
                "optional_value": true
            },
            "tie_correct": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Use tie correction for `'wilcoxon'` scores.\nUsed only for `'wilcoxon'`.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key from `adata.layers` whose value will be used to perform tests on.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "**names** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\nStructured array to be indexed by group id storing the gene\nnames. Ordered according to scores.\n**scores** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\nStructured array to be indexed by group id storing the z-score\nunderlying the computation of a p-value for each gene for each\ngroup. Ordered according to scores.\n**logfoldchanges** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\nStructured array to be indexed by group id storing the log2\nfold change for each gene for each group. Ordered according to\nscores. Only provided if method is 't-test' like.\nNote: this is an approximation calculated from mean-log values.\n**pvals** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\np-values.\n**pvals_adj** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\nCorrected p-values.\n**pts** : `pandas.DataFrame` (`.uns['rank_genes_groups']`)\nFraction of cells expressing the genes for each group.\n**pts_rest** : `pandas.DataFrame` (`.uns['rank_genes_groups']`)\nOnly if `reference` is set to `'rest'`.\nFraction of cells from the union of the rest of each group\nexpressing the genes.\nNotes\nThere are slight inconsistencies depending on whether sparse\nor dense data are passed. See `here <https://github.com/scverse/scanpy/blob/master/scanpy/tests/test_rank_genes_groups.py>`__."
        },
        "Docstring": "Rank genes for characterizing groups.\n\nExpects logarithmized data.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroupby\n    The key of the observations grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlayer\n    Key from `adata.layers` whose value will be used to perform tests on.\ngroups\n    Subset of groups, e.g. [`'g1'`, `'g2'`, `'g3'`], to which comparison\n    shall be restricted, or `'all'` (default), for all groups.\nreference\n    If `'rest'`, compare each group to the union of the rest of the group.\n    If a group identifier, compare with respect to this group.\nn_genes\n    The number of genes that appear in the returned tables.\n    Defaults to all genes.\nmethod\n    The default method is `'t-test'`,\n    `'t-test_overestim_var'` overestimates variance of each group,\n    `'wilcoxon'` uses Wilcoxon rank-sum,\n    `'logreg'` uses logistic regression. See [Ntranos18]_,\n    `here <https://github.com/scverse/scanpy/issues/95>`__ and `here\n    <http://www.nxn.se/valent/2018/3/5/actionable-scrna-seq-clusters>`__,\n    for why this is meaningful.\ncorr_method\n    p-value correction method.\n    Used only for `'t-test'`, `'t-test_overestim_var'`, and `'wilcoxon'`.\ntie_correct\n    Use tie correction for `'wilcoxon'` scores.\n    Used only for `'wilcoxon'`.\nrankby_abs\n    Rank genes by the absolute value of the score, not by the\n    score. The returned scores are never the absolute values.\npts\n    Compute the fraction of cells expressing the genes.\nkey_added\n    The key in `adata.uns` information is saved to.\n**kwds\n    Are passed to test methods. Currently this affects only parameters that\n    are passed to :class:`sklearn.linear_model.LogisticRegression`.\n    For instance, you can pass `penalty='l1'` to try to come up with a\n    minimal set of genes that are good predictors (sparse solution meaning\n    few non-zero fitted coefficients).\n\nReturns\n-------\n**names** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\n    Structured array to be indexed by group id storing the gene\n    names. Ordered according to scores.\n**scores** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\n    Structured array to be indexed by group id storing the z-score\n    underlying the computation of a p-value for each gene for each\n    group. Ordered according to scores.\n**logfoldchanges** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\n    Structured array to be indexed by group id storing the log2\n    fold change for each gene for each group. Ordered according to\n    scores. Only provided if method is 't-test' like.\n    Note: this is an approximation calculated from mean-log values.\n**pvals** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\n    p-values.\n**pvals_adj** : structured `np.ndarray` (`.uns['rank_genes_groups']`)\n    Corrected p-values.\n**pts** : `pandas.DataFrame` (`.uns['rank_genes_groups']`)\n    Fraction of cells expressing the genes for each group.\n**pts_rest** : `pandas.DataFrame` (`.uns['rank_genes_groups']`)\n    Only if `reference` is set to `'rest'`.\n    Fraction of cells from the union of the rest of each group\n    expressing the genes.\n\nNotes\n-----\nThere are slight inconsistencies depending on whether sparse\nor dense data are passed. See `here <https://github.com/scverse/scanpy/blob/master/scanpy/tests/test_rank_genes_groups.py>`__.\n\nExamples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(adata, 'bulk_labels', method='wilcoxon')\n>>> # to visualize the results\n>>> sc.pl.rank_genes_groups(adata)",
        "description": "Rank genes for characterizing groups.Expects logarithmized data.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(adata, 'bulk_labels', method='wilcoxon')\n>>> # to visualize the results\n>>> sc.pl.rank_genes_groups(adata)",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.rank_genes_groups(adata=$, groupby=@, use_raw=@, groups=@, reference=@, n_genes=@, rankby_abs=@, pts=@, key_added=@, copy=@, method=$, corr_method=$, tie_correct=@, layer=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.moignard15": {
        "Parameters": {},
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "Hematopoiesis in early mouse embryos [Moignard15]_.\n\nReturns\n-------\nAnnotated data matrix.",
        "description": "Hematopoiesis in early mouse embryos [Moignard15]_.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.moignard15()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.embedding": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "basis": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Name of the `obsm` basis to use.",
                "optional_value": false
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show edges.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Width of edges.",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Union[str, tuple[float, Ellipsis]]",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Figure, Axes]]",
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot for user specified embedding basis (e.g. umap, pca, etc)\n\nParameters\n----------\nbasis\n    Name of the `obsm` basis to use.\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nedges\n    Show edges.\nedges_width\n    Width of edges.\nedges_color\n    Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\nneighbors_key\n    Where to look for neighbors connectivities.\n    If not specified, this looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, this looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\narrows\n    Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\narrows_kwds\n    Passed to :meth:`~matplotlib.axes.Axes.quiver`\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.",
        "description": "Scatter plot for user specified embedding basis (e.g. umap, pca, etc)",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.embedding(adata=$, basis=@, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.Neighbors.compute_neighbors": {
        "Parameters": {
            "n_neighbors": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Use this number of nearest neighbors.",
                "optional_value": false
            },
            "knn": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Restrict result to `n_neighbors` nearest neighbors.",
                "optional_value": false
            },
            "n_pcs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use the indicated representation. `'X'` or any key for `.obsm` is valid.\nIf `None`, the representation is chosen automatically:\nFor `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\nIf 'X_pca' is not present, it\u2019s computed with default parameters.",
                "optional_value": false
            },
            "method": {
                "type": "Literal[umap, gauss, rapids]",
                "default": "umap",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "write_knn_indices": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "metric": {
                "type": "Union[Literal[cityblock, cosine, euclidean, l1, l2, manhattan], Literal[braycurtis, canberra, chebyshev, correlation, dice, hamming, jaccard, kulsinski, mahalanobis, minkowski, rogerstanimoto, russellrao, seuclidean, sokalmichener, sokalsneath, sqeuclidean, yule]]",
                "default": "euclidean",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Writes sparse graph attributes `.distances` and `.connectivities`.",
            "description": "Also writes `.knn_indices` and `.knn_distances` if\n`write_knn_indices==True`."
        },
        "Docstring": "Compute distances and connectivities of neighbors.\n\nParameters\n----------\nn_neighbors\n     Use this number of nearest neighbors.\nknn\n     Restrict result to `n_neighbors` nearest neighbors.\nn_pcs\n    Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.\nuse_rep\n    Use the indicated representation. `'X'` or any key for `.obsm` is valid.\n    If `None`, the representation is chosen automatically:\n    For `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\n    If 'X_pca' is not present, it\u2019s computed with default parameters.\n\nReturns\n-------\nWrites sparse graph attributes `.distances` and `.connectivities`.\nAlso writes `.knn_indices` and `.knn_distances` if\n`write_knn_indices==True`.",
        "description": "Compute distances and connectivities of neighbors.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.Neighbors.compute_neighbors(n_neighbors=@, knn=@, n_pcs=@, use_rep=@, method=$, random_state=@, write_knn_indices=@, metric=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.marker_gene_overlap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "reference_markers": {
                "type": "Union[Dict[str, set], Dict[str, list]]",
                "default": null,
                "optional": false,
                "description": "A marker gene dictionary object. Keys should be strings with the\ncell identity name and values are sets or lists of strings which match\nformat of `adata.var_name`.",
                "optional_value": false
            },
            "key": {
                "type": "str",
                "default": "rank_genes_groups",
                "optional": true,
                "description": "The key in `adata.uns` where the rank_genes_groups output is stored.\nBy default this is `'rank_genes_groups'`.",
                "optional_value": false
            },
            "method": {
                "type": "Literal[overlap_count, overlap_coef, jaccard]",
                "default": "overlap_count",
                "optional": true,
                "description": "(default: `overlap_count`)\nMethod to calculate marker gene overlap. `'overlap_count'` uses the\nintersection of the gene set, `'overlap_coef'` uses the overlap\ncoefficient, and `'jaccard'` uses the Jaccard index.",
                "optional_value": true
            },
            "normalize": {
                "type": "Optional[Literal[reference, data]]",
                "default": "None",
                "optional": true,
                "description": "Normalization option for the marker gene overlap output. This parameter\ncan only be set when `method` is set to `'overlap_count'`. `'reference'`\nnormalizes the data by the total number of marker genes given in the\nreference annotation per group. `'data'` normalizes the data by the\ntotal number of marker genes used for each cluster.",
                "optional_value": true
            },
            "top_n_markers": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of top data-derived marker genes to use. By default the top\n100 marker genes are used. If `adj_pval_threshold` is set along with\n`top_n_markers`, then `adj_pval_threshold` is ignored.",
                "optional_value": false
            },
            "adj_pval_threshold": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "A significance threshold on the adjusted p-values to select marker\ngenes. This can only be used when adjusted p-values are calculated by\n`sc.tl.rank_genes_groups()`. If `adj_pval_threshold` is set along with\n`top_n_markers`, then `adj_pval_threshold` is ignored.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "marker_gene_overlap",
                "optional": true,
                "description": "Name of the `.uns` field that will contain the marker overlap scores.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a marker gene dataframe or store it inplace in `adata.uns`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "A pandas dataframe with the marker gene overlap scores if `inplace=False`.\nFor `inplace=True` `adata.uns` is updated with an additional field\nspecified by the `key_added` parameter (default = 'marker_gene_overlap')."
        },
        "Docstring": "Calculate an overlap score between data-deriven marker genes and\nprovided markers\n\nMarker gene overlap scores can be quoted as overlap counts, overlap\ncoefficients, or jaccard indices. The method returns a pandas dataframe\nwhich can be used to annotate clusters based on marker gene overlaps.\n\nThis function was written by Malte Luecken.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nreference_markers\n    A marker gene dictionary object. Keys should be strings with the\n    cell identity name and values are sets or lists of strings which match\n    format of `adata.var_name`.\nkey\n    The key in `adata.uns` where the rank_genes_groups output is stored.\n    By default this is `'rank_genes_groups'`.\nmethod\n    (default: `overlap_count`)\n    Method to calculate marker gene overlap. `'overlap_count'` uses the\n    intersection of the gene set, `'overlap_coef'` uses the overlap\n    coefficient, and `'jaccard'` uses the Jaccard index.\nnormalize\n    Normalization option for the marker gene overlap output. This parameter\n    can only be set when `method` is set to `'overlap_count'`. `'reference'`\n    normalizes the data by the total number of marker genes given in the\n    reference annotation per group. `'data'` normalizes the data by the\n    total number of marker genes used for each cluster.\ntop_n_markers\n    The number of top data-derived marker genes to use. By default the top\n    100 marker genes are used. If `adj_pval_threshold` is set along with\n    `top_n_markers`, then `adj_pval_threshold` is ignored.\nadj_pval_threshold\n    A significance threshold on the adjusted p-values to select marker\n    genes. This can only be used when adjusted p-values are calculated by\n    `sc.tl.rank_genes_groups()`. If `adj_pval_threshold` is set along with\n    `top_n_markers`, then `adj_pval_threshold` is ignored.\nkey_added\n    Name of the `.uns` field that will contain the marker overlap scores.\ninplace\n    Return a marker gene dataframe or store it inplace in `adata.uns`.\n\nReturns\n-------\nA pandas dataframe with the marker gene overlap scores if `inplace=False`.\nFor `inplace=True` `adata.uns` is updated with an additional field\nspecified by the `key_added` parameter (default = 'marker_gene_overlap').\n\nExamples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.pp.pca(adata, svd_solver='arpack')\n>>> sc.pp.neighbors(adata)\n>>> sc.tl.louvain(adata)\n>>> sc.tl.rank_genes_groups(adata, groupby='louvain')\n>>> marker_genes = {\n...     'CD4 T cells': {'IL7R'},\n...     'CD14+ Monocytes': {'CD14', 'LYZ'},\n...     'B cells': {'MS4A1'},\n...     'CD8 T cells': {'CD8A'},\n...     'NK cells': {'GNLY', 'NKG7'},\n...     'FCGR3A+ Monocytes': {'FCGR3A', 'MS4A7'},\n...     'Dendritic Cells': {'FCER1A', 'CST3'},\n...     'Megakaryocytes': {'PPBP'}\n... }\n>>> marker_matches = sc.tl.marker_gene_overlap(adata, marker_genes)",
        "description": "Calculate an overlap score between data-deriven marker genes andprovided markers\n\nMarker gene overlap scores can be quoted as overlap counts, overlap\ncoefficients, or jaccard indices. The method returns a pandas dataframe\nwhich can be used to annotate clusters based on marker gene overlaps.\n\nThis function was written by Malte Luecken.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.pp.pca(adata, svd_solver='arpack')\n>>> sc.pp.neighbors(adata)\n>>> sc.tl.louvain(adata)\n>>> sc.tl.rank_genes_groups(adata, groupby='louvain')\n>>> marker_genes = {\n...     'CD4 T cells': {'IL7R'},\n...     'CD14+ Monocytes': {'CD14', 'LYZ'},\n...     'B cells': {'MS4A1'},\n...     'CD8 T cells': {'CD8A'},\n...     'NK cells': {'GNLY', 'NKG7'},\n...     'FCGR3A+ Monocytes': {'FCGR3A', 'MS4A7'},\n...     'Dendritic Cells': {'FCER1A', 'CST3'},\n...     'Megakaryocytes': {'PPBP'}\n... }\n>>> marker_matches = sc.tl.marker_gene_overlap(adata, marker_genes)",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.marker_gene_overlap(adata=$, reference_markers=@, key=@, method=$, normalize=$, top_n_markers=@, adj_pval_threshold=@, key_added=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.scrublet_simulate_doublets": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape ``n_obs`` \u00d7 ``n_vars``. Rows\ncorrespond to cells and columns to genes. Genes should have been\nfiltered for expression and variability, and the object should contain\nraw expression of the same dimensions.",
                "optional_value": true
            },
            "layer": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Layer of adata where raw values are stored, or 'X' if values are in .X.",
                "optional_value": true
            },
            "sim_doublet_ratio": {
                "type": "float",
                "default": "2.0",
                "optional": true,
                "description": "Number of doublets to simulate relative to the number of observed\ntranscriptomes. If `None`, self.sim_doublet_ratio is used.",
                "optional_value": false
            },
            "synthetic_doublet_umi_subsampling": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Rate for sampling UMIs when creating synthetic doublets. If 1.0,\neach doublet is created by simply adding the UMIs from two randomly\nsampled observed transcriptomes. For values less than 1, the\nUMI counts are added and then randomly sampled at the specified\nrate.",
                "optional_value": false
            },
            "random_seed": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "adata : anndata.AnnData with simulated doublets in .X\nAdds fields to ``adata``:\n``.obsm['scrublet']['doublet_parents']``\nPairs of ``.obs_names`` used to generate each simulated doublet transcriptome\n``.uns['scrublet']['parameters']``\nDictionary of Scrublet parameters\nSee also\n:func:`~scanpy.external.pp.scrublet`: Main way of running Scrublet, runs\npreprocessing, doublet simulation (this function) and calling.\n:func:`~scanpy.external.pl.scrublet_score_distribution`: Plot histogram of doublet\nscores for observed transcriptomes and simulated doublets."
        },
        "Docstring": "Simulate doublets by adding the counts of random observed transcriptome pairs.\n\nParameters\n----------\nadata\n    The annotated data matrix of shape ``n_obs`` \u00d7 ``n_vars``. Rows\n    correspond to cells and columns to genes. Genes should have been\n    filtered for expression and variability, and the object should contain\n    raw expression of the same dimensions.\nlayer\n    Layer of adata where raw values are stored, or 'X' if values are in .X.\nsim_doublet_ratio\n    Number of doublets to simulate relative to the number of observed\n    transcriptomes. If `None`, self.sim_doublet_ratio is used.\nsynthetic_doublet_umi_subsampling\n    Rate for sampling UMIs when creating synthetic doublets. If 1.0,\n    each doublet is created by simply adding the UMIs from two randomly\n    sampled observed transcriptomes. For values less than 1, the\n    UMI counts are added and then randomly sampled at the specified\n    rate.\n\nReturns\n-------\nadata : anndata.AnnData with simulated doublets in .X\n    Adds fields to ``adata``:\n\n    ``.obsm['scrublet']['doublet_parents']``\n        Pairs of ``.obs_names`` used to generate each simulated doublet transcriptome\n\n    ``.uns['scrublet']['parameters']``\n        Dictionary of Scrublet parameters\n\nSee also\n--------\n:func:`~scanpy.external.pp.scrublet`: Main way of running Scrublet, runs\n    preprocessing, doublet simulation (this function) and calling.\n:func:`~scanpy.external.pl.scrublet_score_distribution`: Plot histogram of doublet\n    scores for observed transcriptomes and simulated doublets.",
        "description": "Simulate doublets by adding the counts of random observed transcriptome pairs.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.scrublet_simulate_doublets(adata=$, layer=$, sim_doublet_ratio=@, synthetic_doublet_umi_subsampling=@, random_seed=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pl.sam": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "projection": {
                "type": "Union[str, ndarray]",
                "default": "X_umap",
                "optional": true,
                "description": "A case-sensitive string indicating the projection to display (a key\nin adata.obsm) or a 2D numpy array with cell coordinates. If None,\nprojection defaults to UMAP.",
                "optional_value": false
            },
            "c": {
                "type": "Optional[Union[str, ndarray]]",
                "default": "None",
                "optional": true,
                "description": "Cell color values overlaid on the projection. Can be a string from adata.obs\nto overlay cluster assignments / annotations or a 1D numpy array.",
                "optional_value": false
            },
            "cmap": {
                "type": "str",
                "default": "Spectral_r",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "linewidth": {
                "type": "float",
                "default": "0.0",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "edgecolor": {
                "type": "str",
                "default": "k",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "axes": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "Plot output to the specified, existing axes. If None, create new\nfigure window.",
                "optional_value": true
            },
            "colorbar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "s": {
                "type": "float",
                "default": "10.0",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Axes",
            "description": ""
        },
        "Docstring": "Scatter plot using the SAM projection or another input projection.\n\nParameters\n----------\nprojection\n    A case-sensitive string indicating the projection to display (a key\n    in adata.obsm) or a 2D numpy array with cell coordinates. If None,\n    projection defaults to UMAP.\nc\n    Cell color values overlaid on the projection. Can be a string from adata.obs\n    to overlay cluster assignments / annotations or a 1D numpy array.\naxes\n    Plot output to the specified, existing axes. If None, create new\n    figure window.\nkwargs\n    all keyword arguments in matplotlib.pyplot.scatter are eligible.",
        "description": "Scatter plot using the SAM projection or another input projection.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pl.sam(adata=$, projection=@, c=@, cmap=@, linewidth=@, edgecolor=@, axes=$, colorbar=@, s=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot.legend": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Set to `False` to hide the default plot of the legends. This sets the\nlegend width to zero, which will result in a wider main plot.",
                "optional_value": false
            },
            "show_size_legend": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Set to `False` to hide the dot size legend",
                "optional_value": false
            },
            "show_colorbar": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Set to `False` to hide the colorbar legend",
                "optional_value": false
            },
            "size_title": {
                "type": "Optional[str]",
                "default": "Fraction of cells\nin group (%)",
                "optional": true,
                "description": "Title for the dot size legend. Use '\\n' to add line breaks. Appears on top\nof dot sizes",
                "optional_value": false
            },
            "colorbar_title": {
                "type": "Optional[str]",
                "default": "Mean expression\nin group",
                "optional": true,
                "description": "Title for the color bar. Use '\\n' to add line breaks. Appears on top of the\ncolor bar",
                "optional_value": false
            },
            "width": {
                "type": "Optional[float]",
                "default": "1.5",
                "optional": true,
                "description": "Width of the legends area. The unit is the same as in matplotlib (inches).",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ":class:`~scanpy.pl.DotPlot`"
        },
        "Docstring": "Configures dot size and the colorbar legends\n\nParameters\n----------\nshow\n    Set to `False` to hide the default plot of the legends. This sets the\n    legend width to zero, which will result in a wider main plot.\nshow_size_legend\n    Set to `False` to hide the dot size legend\nshow_colorbar\n    Set to `False` to hide the colorbar legend\nsize_title\n    Title for the dot size legend. Use '\\n' to add line breaks. Appears on top\n    of dot sizes\ncolorbar_title\n    Title for the color bar. Use '\\n' to add line breaks. Appears on top of the\n    color bar\nwidth\n    Width of the legends area. The unit is the same as in matplotlib (inches).\n\nReturns\n-------\n:class:`~scanpy.pl.DotPlot`\n\nExamples\n--------\n\nSet color bar title:\n\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {{'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}}\n>>> dp = sc.pl.DotPlot(adata, markers, groupby='bulk_labels')\n>>> dp.legend(colorbar_title='log(UMI counts + 1)').show()",
        "description": "Configures dot size and the colorbar legends",
        "example": "Examples\n--------\n\nSet color bar title:\n\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {{'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}}\n>>> dp = sc.pl.DotPlot(adata, markers, groupby='bulk_labels')\n>>> dp.legend(colorbar_title='log(UMI counts + 1)').show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.DotPlot.legend(show=@, show_size_legend=@, show_colorbar=@, size_title=@, colorbar_title=@, width=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_visium": {
        "Parameters": {
            "path": {
                "type": "Union[str, Path]",
                "default": null,
                "optional": false,
                "description": "Path to directory for visium datafiles.",
                "optional_value": false
            },
            "genome": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Filter expression to genes within this genome.",
                "optional_value": false
            },
            "count_file": {
                "type": "str",
                "default": "filtered_feature_bc_matrix.h5",
                "optional": true,
                "description": "Which file in the passed directory to use as the count file. Typically would be one of:\n'filtered_feature_bc_matrix.h5' or 'raw_feature_bc_matrix.h5'.",
                "optional_value": false
            },
            "library_id": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Identifier for the visium library. Can be modified when concatenating multiple adata objects.",
                "optional_value": false
            },
            "load_images": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "source_image_path": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Path to the high-resolution tissue image. Path will be included in\n`.uns[\"spatial\"][library_id][\"metadata\"][\"source_image_path\"]`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix, where observations/cells are named by their\nbarcode and variables/genes by gene name. Stores the following information:\n:attr:`~anndata.AnnData.X`\nThe data matrix is stored\n:attr:`~anndata.AnnData.obs_names`\nCell names\n:attr:`~anndata.AnnData.var_names`\nGene names for a feature barcode matrix, probe names for a probe bc matrix\n:attr:`~anndata.AnnData.var`\\ `['gene_ids']`\nGene IDs\n:attr:`~anndata.AnnData.var`\\ `['feature_types']`\nFeature types\n:attr:`~anndata.AnnData.obs`\\ `[filtered_barcodes]`\nfiltered barcodes if present in the matrix\n:attr:`~anndata.AnnData.var`\nAny additional metadata present in /matrix/features is read in.\n:attr:`~anndata.AnnData.uns`\\ `['spatial']`\nDict of spaceranger output files with 'library_id' as key\n:attr:`~anndata.AnnData.uns`\\ `['spatial'][library_id]['images']`\nDict of images (`'hires'` and `'lowres'`)\n:attr:`~anndata.AnnData.uns`\\ `['spatial'][library_id]['scalefactors']`\nScale factors for the spots\n:attr:`~anndata.AnnData.uns`\\ `['spatial'][library_id]['metadata']`\nFiles metadata: 'chemistry_description', 'software_version', 'source_image_path'\n:attr:`~anndata.AnnData.obsm`\\ `['spatial']`\nSpatial spot coordinates, usable as `basis` by :func:`~scanpy.pl.embedding`."
        },
        "Docstring": "Read 10x-Genomics-formatted visum dataset.\n\nIn addition to reading regular 10x output,\nthis looks for the `spatial` folder and loads images,\ncoordinates and scale factors.\nBased on the `Space Ranger output docs`_.\n\nSee :func:`~scanpy.pl.spatial` for a compatible plotting function.\n\n.. _Space Ranger output docs: https://support.10xgenomics.com/spatial-gene-expression/software/pipelines/latest/output/overview\n\nParameters\n----------\npath\n    Path to directory for visium datafiles.\ngenome\n    Filter expression to genes within this genome.\ncount_file\n    Which file in the passed directory to use as the count file. Typically would be one of:\n    'filtered_feature_bc_matrix.h5' or 'raw_feature_bc_matrix.h5'.\nlibrary_id\n    Identifier for the visium library. Can be modified when concatenating multiple adata objects.\nsource_image_path\n    Path to the high-resolution tissue image. Path will be included in\n    `.uns[\"spatial\"][library_id][\"metadata\"][\"source_image_path\"]`.\n\nReturns\n-------\nAnnotated data matrix, where observations/cells are named by their\nbarcode and variables/genes by gene name. Stores the following information:\n\n:attr:`~anndata.AnnData.X`\n    The data matrix is stored\n:attr:`~anndata.AnnData.obs_names`\n    Cell names\n:attr:`~anndata.AnnData.var_names`\n    Gene names for a feature barcode matrix, probe names for a probe bc matrix\n:attr:`~anndata.AnnData.var`\\ `['gene_ids']`\n    Gene IDs\n:attr:`~anndata.AnnData.var`\\ `['feature_types']`\n    Feature types\n:attr:`~anndata.AnnData.obs`\\ `[filtered_barcodes]`\n    filtered barcodes if present in the matrix\n:attr:`~anndata.AnnData.var`\n    Any additional metadata present in /matrix/features is read in.\n:attr:`~anndata.AnnData.uns`\\ `['spatial']`\n    Dict of spaceranger output files with 'library_id' as key\n:attr:`~anndata.AnnData.uns`\\ `['spatial'][library_id]['images']`\n    Dict of images (`'hires'` and `'lowres'`)\n:attr:`~anndata.AnnData.uns`\\ `['spatial'][library_id]['scalefactors']`\n    Scale factors for the spots\n:attr:`~anndata.AnnData.uns`\\ `['spatial'][library_id]['metadata']`\n    Files metadata: 'chemistry_description', 'software_version', 'source_image_path'\n:attr:`~anndata.AnnData.obsm`\\ `['spatial']`\n    Spatial spot coordinates, usable as `basis` by :func:`~scanpy.pl.embedding`.",
        "description": "Read 10x-Genomics-formatted visum dataset.In addition to reading regular 10x output,\nthis looks for the `spatial` folder and loads images,\ncoordinates and scale factors.\nBased on the `Space Ranger output docs`_.\n\nSee :func:`~scanpy.pl.spatial` for a compatible plotting function.\n\n.. _Space Ranger output docs: https://support.10xgenomics.com/spatial-gene-expression/software/pipelines/latest/output/overview",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_visium(path=@, genome=@, count_file=@, library_id=@, load_images=@, source_image_path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.queries.mitochondrial_genes": {
        "Parameters": {
            "org": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Organism to query. Must be an organism in ensembl biomart. \"hsapiens\",\n\"mmusculus\", \"drerio\", etc.",
                "optional_value": false
            },
            "attrname": {
                "type": "str",
                "default": "external_gene_name",
                "optional": true,
                "description": "Biomart attribute field to return. Possible values include\n\"external_gene_name\", \"ensembl_gene_id\", \"hgnc_symbol\", \"mgi_symbol\",\nand \"zfin_id_symbol\".",
                "optional_value": false
            },
            "host": {
                "type": "str",
                "default": "www.ensembl.org",
                "optional": true,
                "description": "A valid BioMart host URL. Alternative values include archive urls (like\n\"grch37.ensembl.org\") or regional mirrors (like \"useast.ensembl.org\").",
                "optional_value": false
            },
            "use_cache": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether pybiomart should use a cache for requests. Will create a\n`.pybiomart.sqlite` file in current directory if used.",
                "optional_value": false
            },
            "chromosome": {
                "type": "str",
                "default": "MT",
                "optional": true,
                "description": "Mitochrondrial chromosome name used in BioMart for organism.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": "Dataframe containing identifiers for mitochondrial genes."
        },
        "Docstring": "Mitochondrial gene symbols for specific organism through BioMart.\n\nParameters\n----------\norg\n    Organism to query. Must be an organism in ensembl biomart. \"hsapiens\",\n    \"mmusculus\", \"drerio\", etc.\nattrname\n    Biomart attribute field to return. Possible values include\n    \"external_gene_name\", \"ensembl_gene_id\", \"hgnc_symbol\", \"mgi_symbol\",\n    and \"zfin_id_symbol\".\nhost\n    A valid BioMart host URL. Alternative values include archive urls (like\n    \"grch37.ensembl.org\") or regional mirrors (like \"useast.ensembl.org\").\nuse_cache\n    Whether pybiomart should use a cache for requests. Will create a\n    `.pybiomart.sqlite` file in current directory if used.\nchromosome\n    Mitochrondrial chromosome name used in BioMart for organism.\n\nReturns\n-------\nDataframe containing identifiers for mitochondrial genes.\n\nExamples\n--------\n>>> import scanpy as sc\n>>> mito_gene_names = sc.queries.mitochondrial_genes(\"hsapiens\")\n>>> mito_ensembl_ids = sc.queries.mitochondrial_genes(\"hsapiens\", attrname=\"ensembl_gene_id\")\n>>> mito_gene_names_fly = sc.queries.mitochondrial_genes(\"dmelanogaster\", chromosome=\"mitochondrion_genome\")",
        "description": "Mitochondrial gene symbols for specific organism through BioMart.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> mito_gene_names = sc.queries.mitochondrial_genes(\"hsapiens\")\n>>> mito_ensembl_ids = sc.queries.mitochondrial_genes(\"hsapiens\", attrname=\"ensembl_gene_id\")\n>>> mito_gene_names_fly = sc.queries.mitochondrial_genes(\"dmelanogaster\", chromosome=\"mitochondrion_genome\")",
        "api_type": "function",
        "api_calling": [
            "scanpy.queries.mitochondrial_genes(org=@, attrname=@, host=@, use_cache=@, chromosome=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.tsne": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "n_pcs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use the indicated representation. `'X'` or any key for `.obsm` is valid.\nIf `None`, the representation is chosen automatically:\nFor `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\nIf 'X_pca' is not present, it\u2019s computed with default parameters.",
                "optional_value": false
            },
            "perplexity": {
                "type": "Union[float, int]",
                "default": "30",
                "optional": true,
                "description": "The perplexity is related to the number of nearest neighbors that\nis used in other manifold learning algorithms. Larger datasets\nusually require a larger perplexity. Consider selecting a value\nbetween 5 and 50. The choice is not extremely critical since t-SNE\nis quite insensitive to this parameter.",
                "optional_value": false
            },
            "early_exaggeration": {
                "type": "Union[float, int]",
                "default": "12",
                "optional": true,
                "description": "Controls how tight natural clusters in the original space are in the\nembedded space and how much space will be between them. For larger\nvalues, the space between natural clusters will be larger in the\nembedded space. Again, the choice of this parameter is not very\ncritical. If the cost function increases during initial optimization,\nthe early exaggeration factor or the learning rate might be too high.",
                "optional_value": false
            },
            "learning_rate": {
                "type": "Union[float, int]",
                "default": "1000",
                "optional": true,
                "description": "Note that the R-package \"Rtsne\" uses a default of 200.\nThe learning rate can be a critical parameter. It should be\nbetween 100 and 1000. If the cost function increases during initial\noptimization, the early exaggeration factor or the learning rate\nmight be too high. If the cost function gets stuck in a bad local\nminimum increasing the learning rate helps sometimes.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Change this to use different intial states for the optimization.\nIf `None`, the initial state is not reproducible.",
                "optional_value": false
            },
            "use_fast_tsne": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of jobs for parallel computation.\n`None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to `adata`.",
                "optional_value": false
            },
            "metric": {
                "type": "str",
                "default": "euclidean",
                "optional": true,
                "description": "Distance metric calculate neighbors on.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `adata` with the following fields.\n**X_tsne** : `np.ndarray` (`adata.obs`, dtype `float`)\ntSNE coordinates of data."
        },
        "Docstring": "t-SNE [Maaten08]_ [Amir13]_ [Pedregosa11]_.\n\nt-distributed stochastic neighborhood embedding (tSNE) [Maaten08]_ has been\nproposed for visualizating single-cell data by [Amir13]_. Here, by default,\nwe use the implementation of *scikit-learn* [Pedregosa11]_. You can achieve\na huge speedup and better convergence if you install `Multicore-tSNE\n<https://github.com/DmitryUlyanov/Multicore-TSNE>`__ by [Ulyanov16]_, which\nwill be automatically detected by Scanpy.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nn_pcs\n    Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.\nuse_rep\n    Use the indicated representation. `'X'` or any key for `.obsm` is valid.\n    If `None`, the representation is chosen automatically:\n    For `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\n    If 'X_pca' is not present, it\u2019s computed with default parameters.\nperplexity\n    The perplexity is related to the number of nearest neighbors that\n    is used in other manifold learning algorithms. Larger datasets\n    usually require a larger perplexity. Consider selecting a value\n    between 5 and 50. The choice is not extremely critical since t-SNE\n    is quite insensitive to this parameter.\nmetric\n    Distance metric calculate neighbors on.\nearly_exaggeration\n    Controls how tight natural clusters in the original space are in the\n    embedded space and how much space will be between them. For larger\n    values, the space between natural clusters will be larger in the\n    embedded space. Again, the choice of this parameter is not very\n    critical. If the cost function increases during initial optimization,\n    the early exaggeration factor or the learning rate might be too high.\nlearning_rate\n    Note that the R-package \"Rtsne\" uses a default of 200.\n    The learning rate can be a critical parameter. It should be\n    between 100 and 1000. If the cost function increases during initial\n    optimization, the early exaggeration factor or the learning rate\n    might be too high. If the cost function gets stuck in a bad local\n    minimum increasing the learning rate helps sometimes.\nrandom_state\n    Change this to use different intial states for the optimization.\n    If `None`, the initial state is not reproducible.\nn_jobs\n    Number of jobs for parallel computation.\n    `None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.\ncopy\n    Return a copy instead of writing to `adata`.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields.\n\n**X_tsne** : `np.ndarray` (`adata.obs`, dtype `float`)\n    tSNE coordinates of data.",
        "description": "t-SNE [Maaten08]_ [Amir13]_ [Pedregosa11]_.t-distributed stochastic neighborhood embedding (tSNE) [Maaten08]_ has been\nproposed for visualizating single-cell data by [Amir13]_. Here, by default,\nwe use the implementation of *scikit-learn* [Pedregosa11]_. You can achieve\na huge speedup and better convergence if you install `Multicore-tSNE\n<https://github.com/DmitryUlyanov/Multicore-TSNE>`__ by [Ulyanov16]_, which\nwill be automatically detected by Scanpy.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.tsne(adata=$, n_pcs=@, use_rep=@, perplexity=@, early_exaggeration=@, learning_rate=@, random_state=@, use_fast_tsne=@, n_jobs=@, copy=@, metric=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.rank_genes_groups_dotplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The groups for which to show the gene ranking.",
                "optional_value": false
            },
            "n_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\n`gene_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).",
                "optional_value": false
            },
            "values_to_plot": {
                "type": "Optional[Literal[scores, logfoldchanges, pvals, pvals_adj, log10_pvals, log10_pvals_adj]]",
                "default": "None",
                "optional": true,
                "description": "Instead of the mean gene value, plot the values computed by `sc.rank_genes_groups`.\nThe options are: ['scores', 'logfoldchanges', 'pvals', 'pvals_adj',\n'log10_pvals', 'log10_pvals_adj']. When plotting logfoldchanges a divergent\ncolormap is recommended. See examples below.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "Genes to plot. Sometimes is useful to pass a specific list of var names (e.g. genes)\nto check their fold changes or p-values, instead of the top/bottom genes. The\nvar_names could be a dictionary or a list as in :func:`~scanpy.pl.dotplot` or\n:func:`~scanpy.pl.matrixplot`. See examples below.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key used to store the ranking results in `adata.uns`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`DotPlot` object. Useful for fine-tuning\nthe plot. Takes precedence over `show=False`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `return_fig` is `True`, returns a :class:`DotPlot` object,\nelse if `show` is false, return axes dict"
        },
        "Docstring": "Plot ranking of genes using dotplot plot (see :func:`~scanpy.pl.dotplot`)\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroups\n    The groups for which to show the gene ranking.\nn_genes\n    Number of genes to show. This can be a negative number to show for\n    example the down regulated genes. eg: num_genes=-10. Is ignored if\n    `gene_names` is passed.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\ngroupby\n    The key of the observation grouping to consider. By default,\n    the groupby is chosen from the rank genes groups parameter but\n    other groupby options can be used.  It is expected that\n    groupby is a categorical. If groupby is not a categorical observation,\n    it would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).\nmin_logfoldchange\n    Value to filter genes in groups if their logfoldchange is less than the\n    min_logfoldchange\nkey\n    Key used to store the ranking results in `adata.uns`.\nvalues_to_plot\n    Instead of the mean gene value, plot the values computed by `sc.rank_genes_groups`.\n    The options are: ['scores', 'logfoldchanges', 'pvals', 'pvals_adj',\n    'log10_pvals', 'log10_pvals_adj']. When plotting logfoldchanges a divergent\n    colormap is recommended. See examples below.\nvar_names\n    Genes to plot. Sometimes is useful to pass a specific list of var names (e.g. genes)\n    to check their fold changes or p-values, instead of the top/bottom genes. The\n    var_names could be a dictionary or a list as in :func:`~scanpy.pl.dotplot` or\n    :func:`~scanpy.pl.matrixplot`. See examples below.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\nreturn_fig\n    Returns :class:`DotPlot` object. Useful for fine-tuning\n    the plot. Takes precedence over `show=False`.\n**kwds\n    Are passed to :func:`~scanpy.pl.dotplot`.\n\nReturns\n-------\nIf `return_fig` is `True`, returns a :class:`DotPlot` object,\nelse if `show` is false, return axes dict\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.rank_genes_groups(adata, 'bulk_labels', n_genes=adata.raw.shape[1])\n\nPlot top 2 genes per group.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_dotplot(adata,n_genes=2)\n\nPlot with scaled expressions for easier identification of differences.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_dotplot(adata, n_genes=2, standard_scale='var')\n\nPlot `logfoldchanges` instead of gene expression. In this case a diverging colormap\nlike `bwr` or `seismic` works better. To center the colormap in zero, the minimum\nand maximum values to plot are set to -4 and 4 respectively.\nAlso, only genes with a log fold change of 3 or more are shown.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_dotplot(\n        adata,\n        n_genes=4,\n        values_to_plot=\"logfoldchanges\", cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change'\n    )\n\nAlso, the last genes can be plotted. This can be useful to identify genes\nthat are lowly expressed in a group. For this `n_genes=-4` is used\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_dotplot(\n        adata,\n        n_genes=-4,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )\n\nA list specific genes can be given to check their log fold change. If a\ndictionary, the dictionary keys will be added as labels in the plot.\n\n.. plot::\n    :context: close-figs\n\n    var_names = {'T-cell': ['CD3D', 'CD3E', 'IL32'],\n                  'B-cell': ['CD79A', 'CD79B', 'MS4A1'],\n                  'myeloid': ['CST3', 'LYZ'] }\n    sc.pl.rank_genes_groups_dotplot(\n        adata,\n        var_names=var_names,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.rank_genes_groups",
        "description": "Plot ranking of genes using dotplot plot (see :func:`~scanpy.pl.dotplot`)",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.rank_genes_groups(adata, 'bulk_labels', n_genes=adata.raw.shape[1])\n\nPlot top 2 genes per group.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_dotplot(adata,n_genes=2)\n\nPlot with scaled expressions for easier identification of differences.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_dotplot(adata, n_genes=2, standard_scale='var')\n\nPlot `logfoldchanges` instead of gene expression. In this case a diverging colormap\nlike `bwr` or `seismic` works better. To center the colormap in zero, the minimum\nand maximum values to plot are set to -4 and 4 respectively.\nAlso, only genes with a log fold change of 3 or more are shown.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_dotplot(\n        adata,\n        n_genes=4,\n        values_to_plot=\"logfoldchanges\", cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change'\n    )\n\nAlso, the last genes can be plotted. This can be useful to identify genes\nthat are lowly expressed in a group. For this `n_genes=-4` is used\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_dotplot(\n        adata,\n        n_genes=-4,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )\n\nA list specific genes can be given to check their log fold change. If a\ndictionary, the dictionary keys will be added as labels in the plot.\n\n.. plot::\n    :context: close-figs\n\n    var_names = {'T-cell': ['CD3D', 'CD3E', 'IL32'],\n                  'B-cell': ['CD79A', 'CD79B', 'MS4A1'],\n                  'myeloid': ['CST3', 'LYZ'] }\n    sc.pl.rank_genes_groups_dotplot(\n        adata,\n        var_names=var_names,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.rank_genes_groups",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.rank_genes_groups_dotplot(adata=$, groups=@, n_genes=@, groupby=@, values_to_plot=$, var_names=@, gene_symbols=@, min_logfoldchange=@, key=@, show=@, save=@, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin.swap_axes": {
        "Parameters": {
            "swap_axes": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'swap_axes'. Default True",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Plots a transposed image.\n\nBy default, the x axis contains `var_names` (e.g. genes) and the y\naxis the `groupby` categories. By setting `swap_axes` then x are\nthe `groupby` categories and y the `var_names`.\n\nParameters\n----------\nswap_axes\n    Boolean to turn on (True) or off (False) 'swap_axes'. Default True\n\n\nReturns\n-------\nBasePlot",
        "description": "Plots a transposed image.By default, the x axis contains `var_names` (e.g. genes) and the y\naxis the `groupby` categories. By setting `swap_axes` then x are\nthe `groupby` categories and y the `var_names`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.StackedViolin.swap_axes(swap_axes=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.sim": {
        "Parameters": {
            "model": {
                "type": "Literal[krumsiek11, toggleswitch]",
                "default": null,
                "optional": false,
                "description": "Model file in 'sim_models' directory.",
                "optional_value": true
            },
            "params_file": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Read default params from file.",
                "optional_value": false
            },
            "tmax": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of time steps per realization of time series.",
                "optional_value": false
            },
            "branching": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Only write realizations that contain new branches.",
                "optional_value": false
            },
            "nrRealizations": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of realizations.",
                "optional_value": false
            },
            "noiseObs": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Observatory/Measurement noise.",
                "optional_value": false
            },
            "noiseDyn": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Dynamic noise.",
                "optional_value": false
            },
            "step": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Interval for saving state of system.",
                "optional_value": false
            },
            "seed": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Seed for generation of random numbers.",
                "optional_value": false
            },
            "writedir": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Path to directory for writing output files.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "Simulate dynamic gene expression data [Wittmann09]_ [Wolf18]_.\n\nSample from a stochastic differential equation model built from\nliterature-curated boolean gene regulatory networks, as suggested by\n[Wittmann09]_. The Scanpy implementation is due to [Wolf18]_.\n\nParameters\n----------\nmodel\n    Model file in 'sim_models' directory.\nparams_file\n    Read default params from file.\ntmax\n    Number of time steps per realization of time series.\nbranching\n    Only write realizations that contain new branches.\nnrRealizations\n    Number of realizations.\nnoiseObs\n    Observatory/Measurement noise.\nnoiseDyn\n    Dynamic noise.\nstep\n    Interval for saving state of system.\nseed\n    Seed for generation of random numbers.\nwritedir\n    Path to directory for writing output files.\n\nReturns\n-------\nAnnotated data matrix.\n\nExamples\n--------\nSee this `use case <https://github.com/scverse/scanpy_usage/tree/master/170430_krumsiek11>`__",
        "description": "Simulate dynamic gene expression data [Wittmann09]_ [Wolf18]_.Sample from a stochastic differential equation model built from\nliterature-curated boolean gene regulatory networks, as suggested by\n[Wittmann09]_. The Scanpy implementation is due to [Wolf18]_.",
        "example": "Examples\n--------\nSee this `use case <https://github.com/scverse/scanpy_usage/tree/master/170430_krumsiek11>`__",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.sim(model=$, params_file=@, tmax=@, branching=@, nrRealizations=@, noiseObs=@, noiseDyn=@, step=@, seed=@, writedir=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_csv": {
        "Parameters": {
            "filename": {
                "type": "Union[PathLike, Iterator[str]]",
                "default": null,
                "optional": false,
                "description": "Data file.",
                "optional_value": false
            },
            "delimiter": {
                "type": "Optional[str]",
                "default": ",",
                "optional": true,
                "description": "Delimiter that separates data within text file.\nIf `None`, will split at arbitrary number of white spaces,\nwhich is different from enforcing splitting at single white space `' '`.",
                "optional_value": false
            },
            "first_column_names": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Assume the first column stores row names.",
                "optional_value": false
            },
            "dtype": {
                "type": "str",
                "default": "float32",
                "optional": true,
                "description": "Numpy data type.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Read `.csv` file.\n\nSame as :func:`~anndata.read_text` but with default delimiter `','`.\n\nParameters\n----------\nfilename\n    Data file.\ndelimiter\n    Delimiter that separates data within text file.\n    If `None`, will split at arbitrary number of white spaces,\n    which is different from enforcing splitting at single white space `' '`.\nfirst_column_names\n    Assume the first column stores row names.\ndtype\n    Numpy data type.",
        "description": "Read `.csv` file.Same as :func:`~anndata.read_text` but with default delimiter `','`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_csv(filename=@, delimiter=@, first_column_names=@, dtype=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.toggleswitch": {
        "Parameters": {},
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "Simulated toggleswitch.\n\nData obtained simulating a simple toggleswitch [Gardner00]_\n\nSimulate via :func:`~scanpy.tl.sim`.\n\nReturns\n-------\nAnnotated data matrix.",
        "description": "Simulated toggleswitch.Data obtained simulating a simple toggleswitch [Gardner00]_\n\nSimulate via :func:`~scanpy.tl.sim`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.toggleswitch()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.spatial": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Scaling factor used to map from coordinate space to pixel space.\nFound by default if `library_id` and `img_key` can be resolved.\nOtherwise defaults to `1.`.",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Optional[Union[str, tuple[float, Ellipsis]]]",
                "default": "None",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "basis": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "img": {
                "type": "Optional[ndarray]",
                "default": "None",
                "optional": true,
                "description": "image data to plot, overrides `img_key`.",
                "optional_value": true
            },
            "img_key": {
                "type": "Optional[Union[str, Empty]]",
                "default": "Empty.token",
                "optional": true,
                "description": "Key for image data, used to get `img` and `scale_factor` from `\"images\"`\nand `\"scalefactors\"` entires for this library. To use spatial coordinates,\nbut not plot an image, pass `img_key=None`.",
                "optional_value": false
            },
            "library_id": {
                "type": "Optional[Union[str, Empty]]",
                "default": "Empty.token",
                "optional": true,
                "description": "library_id for Visium data, e.g. key in `adata.uns[\"spatial\"]`.",
                "optional_value": false
            },
            "crop_coord": {
                "type": "tuple[int, int, int, int]",
                "default": "None",
                "optional": true,
                "description": "Coordinates to use for cropping the image (left, right, top, bottom).\nThese coordinates are expected to be in pixel space (same as `basis`)\nand will be transformed by `scale_factor`.\nIf not provided, image is automatically cropped to bounds of `basis`,\nplus a border.",
                "optional_value": false
            },
            "alpha_img": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Alpha value for image.",
                "optional_value": false
            },
            "bw": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Plot image data in gray scale.",
                "optional_value": false
            },
            "spot_size": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Diameter of spot (in coordinate space) for each point. Diameter\nin pixels of the spots will be `size * spot_size * scale_factor`.\nThis argument is required if it cannot be resolved from library info.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, List[Axes]]]",
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot in spatial coordinates.\n\nThis function allows overlaying data on top of images.\nUse the parameter `img_key` to see the image in the background\nAnd the parameter `library_id` to select the image.\nBy default, `'hires'` and `'lowres'` are attempted.\n\nUse `crop_coord`, `alpha_img`, and `bw` to control how it is displayed.\nUse `size` to scale the size of the Visium spots plotted on top.\n\nAs this function is designed to for imaging data, there are two key assumptions\nabout how coordinates are handled:\n\n1. The origin (e.g `(0, 0)`) is at the top left \u2013 as is common convention\nwith image data.\n\n2. Coordinates are in the pixel space of the source image, so an equal\naspect ratio is assumed.\n\nIf your anndata object has a `\"spatial\"` entry in `.uns`, the `img_key`\nand `library_id` parameters to find values for `img`, `scale_factor`,\nand `spot_size` arguments. Alternatively, these values be passed directly.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nlibrary_id\n    library_id for Visium data, e.g. key in `adata.uns[\"spatial\"]`.\nimg_key\n    Key for image data, used to get `img` and `scale_factor` from `\"images\"`\n    and `\"scalefactors\"` entires for this library. To use spatial coordinates,\n    but not plot an image, pass `img_key=None`.\nimg\n    image data to plot, overrides `img_key`.\nscale_factor\n    Scaling factor used to map from coordinate space to pixel space.\n    Found by default if `library_id` and `img_key` can be resolved.\n    Otherwise defaults to `1.`.\nspot_size\n    Diameter of spot (in coordinate space) for each point. Diameter\n    in pixels of the spots will be `size * spot_size * scale_factor`.\n    This argument is required if it cannot be resolved from library info.\ncrop_coord\n    Coordinates to use for cropping the image (left, right, top, bottom).\n    These coordinates are expected to be in pixel space (same as `basis`)\n    and will be transformed by `scale_factor`.\n    If not provided, image is automatically cropped to bounds of `basis`,\n    plus a border.\nalpha_img\n    Alpha value for image.\nbw\n    Plot image data in gray scale.\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples\n--------\nThis function behaves very similarly to other embedding plots like\n:func:`~scanpy.pl.umap`\n\n>>> adata = sc.datasets.visium_sge(\"Targeted_Visium_Human_Glioblastoma_Pan_Cancer\")\n>>> sc.pp.calculate_qc_metrics(adata, inplace=True)\n>>> sc.pl.spatial(adata, color=\"log1p_n_genes_by_counts\")\n\nSee Also\n--------\n:func:`scanpy.datasets.visium_sge`\n    Example visium data.\n:tutorial:`spatial/basic-analysis`\n    Tutorial on spatial analysis.",
        "description": "Scatter plot in spatial coordinates.This function allows overlaying data on top of images.\nUse the parameter `img_key` to see the image in the background\nAnd the parameter `library_id` to select the image.\nBy default, `'hires'` and `'lowres'` are attempted.\n\nUse `crop_coord`, `alpha_img`, and `bw` to control how it is displayed.\nUse `size` to scale the size of the Visium spots plotted on top.\n\nAs this function is designed to for imaging data, there are two key assumptions\nabout how coordinates are handled:\n\n1. The origin (e.g `(0, 0)`) is at the top left \u2013 as is common convention\nwith image data.\n\n2. Coordinates are in the pixel space of the source image, so an equal\naspect ratio is assumed.\n\nIf your anndata object has a `\"spatial\"` entry in `.uns`, the `img_key`\nand `library_id` parameters to find values for `img`, `scale_factor`,\nand `spot_size` arguments. Alternatively, these values be passed directly.",
        "example": "Examples\n--------\nThis function behaves very similarly to other embedding plots like\n:func:`~scanpy.pl.umap`\n\n>>> adata = sc.datasets.visium_sge(\"Targeted_Visium_Human_Glioblastoma_Pan_Cancer\")\n>>> sc.pp.calculate_qc_metrics(adata, inplace=True)\n>>> sc.pl.spatial(adata, color=\"log1p_n_genes_by_counts\")\n\nSee Also\n--------\n:func:`scanpy.datasets.visium_sge`\n    Example visium data.\n:tutorial:`spatial/basic-analysis`\n    Tutorial on spatial analysis.",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.spatial(adata=$, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@, basis=@, img=$, img_key=@, library_id=@, crop_coord=@, alpha_img=@, bw=@, spot_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.sandbag": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "annotation": {
                "type": "Optional[Mapping[str, Collection[Union[str, int, bool]]]]",
                "default": "None",
                "optional": true,
                "description": "Mapping from category to genes, e.g. `{'phase': [Gene1, ...]}`.\nDefaults to ``data.vars['category']``.",
                "optional_value": false
            },
            "fraction": {
                "type": "float",
                "default": "0.65",
                "optional": true,
                "description": "Fraction of cells per category where marker criteria must be satisfied.",
                "optional_value": false
            },
            "filter_genes": {
                "type": "Optional[Collection[Union[str, int, bool]]]",
                "default": "None",
                "optional": true,
                "description": "Genes for sampling the reference set. Defaults to all genes.",
                "optional_value": false
            },
            "filter_samples": {
                "type": "Optional[Collection[Union[str, int, bool]]]",
                "default": "None",
                "optional": true,
                "description": "Cells for sampling the reference set. Defaults to all samples.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Dict[str, List[tuple[str, str]]]",
            "description": "A dict mapping from category to lists of marker pairs, e.g.:\n`{'Category_1': [(Gene_1, Gene_2), ...], ...}`."
        },
        "Docstring": "Calculate marker pairs of genes. [Scialdone15]_ [Fechtner18]_.\n\nCalculates the pairs of genes serving as marker pairs for each phase,\nbased on a matrix of gene counts and an annotation of known phases.\n\nThis reproduces the approach of [Scialdone15]_ in the implementation of\n[Fechtner18]_.\n\nMore information and bug reports `here\n<https://github.com/rfechtner/pypairs>`__.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nannotation\n    Mapping from category to genes, e.g. `{'phase': [Gene1, ...]}`.\n    Defaults to ``data.vars['category']``.\nfraction\n    Fraction of cells per category where marker criteria must be satisfied.\nfilter_genes\n    Genes for sampling the reference set. Defaults to all genes.\nfilter_samples\n    Cells for sampling the reference set. Defaults to all samples.\n\nReturns\n-------\nA dict mapping from category to lists of marker pairs, e.g.:\n`{'Category_1': [(Gene_1, Gene_2), ...], ...}`.\n\nExamples\n--------\n>>> from scanpy.external.tl import sandbag\n>>> from pypairs import datasets\n>>> adata = datasets.leng15()\n>>> marker_pairs = sandbag(adata, fraction=0.5)",
        "description": "Calculate marker pairs of genes. [Scialdone15]_ [Fechtner18]_.Calculates the pairs of genes serving as marker pairs for each phase,\nbased on a matrix of gene counts and an annotation of known phases.\n\nThis reproduces the approach of [Scialdone15]_ in the implementation of\n[Fechtner18]_.\n\nMore information and bug reports `here\n<https://github.com/rfechtner/pypairs>`__.",
        "example": "Examples\n--------\n>>> from scanpy.external.tl import sandbag\n>>> from pypairs import datasets\n>>> adata = datasets.leng15()\n>>> marker_pairs = sandbag(adata, fraction=0.5)",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.sandbag(adata=$, annotation=@, fraction=@, filter_genes=@, filter_samples=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.experimental.pp.normalize_pearson_residuals_pca": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "theta": {
                "type": "float",
                "default": "100",
                "optional": true,
                "description": "The negative binomial overdispersion parameter `theta` for Pearson residuals.\nHigher values correspond to less overdispersion     (`var = mean + mean^2/theta`), and `theta=np.Inf` corresponds to a Poisson model.",
                "optional_value": false
            },
            "clip": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Determines if and how residuals are clipped:\n\n* If `None`, residuals are clipped to the interval     `[-sqrt(n_obs), sqrt(n_obs)]`, where `n_obs` is the number of cells in the dataset (default behavior).\n* If any scalar `c`, residuals are clipped to the interval `[-c, c]`. Set     `clip=np.Inf` for no clipping.",
                "optional_value": false
            },
            "n_comps": {
                "type": "Optional[int]",
                "default": "50",
                "optional": true,
                "description": "Number of principal components to compute in the PCA step.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[float]",
                "default": "0",
                "optional": true,
                "description": "Random seed for setting the initial states for the optimization in the PCA step.",
                "optional_value": false
            },
            "use_highly_variable": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True`, uses gene selection present in `adata.var['highly_variable']` to\nsubset the data before normalizing (default). Otherwise, proceed on the full\ndataset.",
                "optional_value": false
            },
            "check_values": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, checks if counts in selected layer are integers as expected by this\nfunction, and return a warning if non-integers are found. Otherwise, proceed\nwithout checking. Setting this to `False` can speed up code for large datasets.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, update `adata` with results. Otherwise, return results. See below for\ndetails of what is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "If `inplace=False`, returns the Pearson residual-based PCA results (as :class:`~anndata.AnnData`\nobject). If `inplace=True`, updates `adata` with the following fields:\n`.uns['pearson_residuals_normalization']['pearson_residuals_df']`\nThe subset of highly variable genes, normalized by Pearson residuals.\n`.uns['pearson_residuals_normalization']['theta']`\nThe used value of the overdisperion parameter theta.\n`.uns['pearson_residuals_normalization']['clip']`\nThe used value of the clipping parameter.\n`.obsm['X_pca']`\nPCA representation of data after gene selection (if applicable) and Pearson\nresidual normalization.\n`.varm['PCs']`\nThe principal components containing the loadings. When `inplace=True` and\n`use_highly_variable=True`, this will contain empty rows for the genes not\nselected.\n`.uns['pca']['variance_ratio']`\nRatio of explained variance.\n`.uns['pca']['variance']`\nExplained variance, equivalent to the eigenvalues of the covariance matrix."
        },
        "Docstring": "Applies analytic Pearson residual normalization and PCA, based on [Lause21]_.\n\nThe residuals are based on a negative binomial offset model with overdispersion\n`theta` shared across genes. By default, residuals are clipped to `sqrt(n_obs)`,\noverdispersion `theta=100` is used, and PCA is run with 50 components.\n\nOperates on the subset of highly variable genes in `adata.var['highly_variable']`\nby default. Expects raw count input.\n\nParams\n------\nadata\n    The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\n\ntheta\n    The negative binomial overdispersion parameter `theta` for Pearson residuals.\n    Higher values correspond to less overdispersion     (`var = mean + mean^2/theta`), and `theta=np.Inf` corresponds to a Poisson model.\nclip\n    Determines if and how residuals are clipped:\n\n    * If `None`, residuals are clipped to the interval     `[-sqrt(n_obs), sqrt(n_obs)]`, where `n_obs` is the number of cells in the dataset (default behavior).\n    * If any scalar `c`, residuals are clipped to the interval `[-c, c]`. Set     `clip=np.Inf` for no clipping.\n\nn_comps\n    Number of principal components to compute in the PCA step.\nrandom_state\n    Random seed for setting the initial states for the optimization in the PCA step.\nkwargs_pca\n    Dictionary of further keyword arguments passed on to `scanpy.pp.pca()`.\n\nuse_highly_variable\n    If `True`, uses gene selection present in `adata.var['highly_variable']` to\n    subset the data before normalizing (default). Otherwise, proceed on the full\n    dataset.\ncheck_values\n    If `True`, checks if counts in selected layer are integers as expected by this\n    function, and return a warning if non-integers are found. Otherwise, proceed\n    without checking. Setting this to `False` can speed up code for large datasets.\n\ninplace\n    If `True`, update `adata` with results. Otherwise, return results. See below for\n    details of what is returned.\n\n\nReturns\n-------\nIf `inplace=False`, returns the Pearson residual-based PCA results (as :class:`~anndata.AnnData`\nobject). If `inplace=True`, updates `adata` with the following fields:\n\n`.uns['pearson_residuals_normalization']['pearson_residuals_df']`\n     The subset of highly variable genes, normalized by Pearson residuals.\n`.uns['pearson_residuals_normalization']['theta']`\n     The used value of the overdisperion parameter theta.\n`.uns['pearson_residuals_normalization']['clip']`\n     The used value of the clipping parameter.\n\n`.obsm['X_pca']`\n    PCA representation of data after gene selection (if applicable) and Pearson\n    residual normalization.\n`.varm['PCs']`\n     The principal components containing the loadings. When `inplace=True` and\n     `use_highly_variable=True`, this will contain empty rows for the genes not\n     selected.\n`.uns['pca']['variance_ratio']`\n     Ratio of explained variance.\n`.uns['pca']['variance']`\n     Explained variance, equivalent to the eigenvalues of the covariance matrix.",
        "description": "Applies analytic Pearson residual normalization and PCA, based on [Lause21]_.The residuals are based on a negative binomial offset model with overdispersion\n`theta` shared across genes. By default, residuals are clipped to `sqrt(n_obs)`,\noverdispersion `theta=100` is used, and PCA is run with 50 components.\n\nOperates on the subset of highly variable genes in `adata.var['highly_variable']`\nby default. Expects raw count input.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.experimental.pp.normalize_pearson_residuals_pca(adata=$, theta=@, clip=@, n_comps=@, random_state=@, use_highly_variable=@, check_values=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.recipe_weinreb17": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "log": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Logarithmize data?",
                "optional_value": false
            },
            "mean_threshold": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "cv_threshold": {
                "type": "int",
                "default": "2",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "n_pcs": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "svd_solver": {
                "type": null,
                "default": "randomized",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy if true.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Normalization and filtering as of [Weinreb17]_.\n\nExpects non-logarithmized data.\nIf using logarithmized data, pass `log=False`.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nlog\n    Logarithmize data?\ncopy\n    Return a copy if true.",
        "description": "Normalization and filtering as of [Weinreb17]_.Expects non-logarithmized data.\nIf using logarithmized data, pass `log=False`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.recipe_weinreb17(adata=$, log=@, mean_threshold=@, cv_threshold=@, n_pcs=@, svd_solver=$, random_state=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_mtx": {
        "Parameters": {
            "filename": {
                "type": "PathLike",
                "default": null,
                "optional": false,
                "description": "The filename.",
                "optional_value": true
            },
            "dtype": {
                "type": "str",
                "default": "float32",
                "optional": true,
                "description": "Numpy data type.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Read `.mtx` file.\n\nParameters\n----------\nfilename\n    The filename.\ndtype\n    Numpy data type.",
        "description": "Read `.mtx` file.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_mtx(filename=$, dtype=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.pca_overview": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot PCA results.\n\nThe parameters are the ones of the scatter plot. Call pca_ranking separately\nif you want to change the default settings.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for observation/cell annotation either as list `[\"ann1\", \"ann2\"]` or\n    string `\"ann1,ann2,...\"`.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nExamples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc3k_processed()\n    sc.pl.pca_overview(adata, color=\"louvain\")\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.pca\npp.pca",
        "description": "Plot PCA results.The parameters are the ones of the scatter plot. Call pca_ranking separately\nif you want to change the default settings.",
        "example": "Examples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc3k_processed()\n    sc.pl.pca_overview(adata, color=\"louvain\")\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.pca\npp.pca",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.pca_overview(adata=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.phate": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "n_components": {
                "type": "int",
                "default": "2",
                "optional": true,
                "description": "number of dimensions in which the data will be embedded",
                "optional_value": false
            },
            "k": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "number of nearest neighbors on which to build kernel",
                "optional_value": false
            },
            "a": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "sets decay rate of kernel tails.\nIf None, alpha decaying kernel is not used",
                "optional_value": false
            },
            "n_landmark": {
                "type": "int",
                "default": "2000",
                "optional": true,
                "description": "number of landmarks to use in fast PHATE",
                "optional_value": false
            },
            "t": {
                "type": "Union[int, str]",
                "default": "auto",
                "optional": true,
                "description": "power to which the diffusion operator is powered\nsets the level of diffusion. If 'auto', t is selected\naccording to the knee point in the Von Neumann Entropy of\nthe diffusion operator",
                "optional_value": false
            },
            "gamma": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Informational distance constant between -1 and 1.\n`gamma=1` gives the PHATE log potential, `gamma=0` gives\na square root potential.",
                "optional_value": false
            },
            "n_pca": {
                "type": "int",
                "default": "100",
                "optional": true,
                "description": "Number of principal components to use for calculating\nneighborhoods. For extremely large datasets, using\nn_pca < 20 allows neighborhoods to be calculated in\nlog(n_samples) time.",
                "optional_value": false
            },
            "knn_dist": {
                "type": "str",
                "default": "euclidean",
                "optional": true,
                "description": "recommended values: 'euclidean' and 'cosine'\nAny metric from `scipy.spatial.distance` can be used\ndistance metric for building kNN graph",
                "optional_value": false
            },
            "mds_dist": {
                "type": "str",
                "default": "euclidean",
                "optional": true,
                "description": "recommended values: 'euclidean' and 'cosine'\nAny metric from `scipy.spatial.distance` can be used\ndistance metric for MDS",
                "optional_value": false
            },
            "mds": {
                "type": "Literal[classic, metric, nonmetric]",
                "default": "metric",
                "optional": true,
                "description": "Selects which MDS algorithm is used for dimensionality reduction.",
                "optional_value": true
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of jobs to use for the computation.\nIf `None`, `sc.settings.n_jobs` is used.\nIf -1 all CPUs are used. If 1 is given, no parallel computing code is\nused at all, which is useful for debugging.\nFor n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for\nn_jobs = -2, all CPUs but one are used",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "None",
                "optional": true,
                "description": "Random seed. Defaults to the global `numpy` random number generator",
                "optional_value": false
            },
            "verbose": {
                "type": "Optional[Union[bool, int]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or an `int`/`Verbosity` \u2265 2/`hint`, print status messages.\nIf `None`, `sc.settings.verbosity` is used.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to `adata`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `adata` with the following fields.\n**X_phate** : `np.ndarray`, (`adata.obs`, shape=[n_samples, n_components], dtype `float`)\nPHATE coordinates of data."
        },
        "Docstring": "PHATE [Moon17]_.\n\nPotential of Heat-diffusion for Affinity-based Trajectory Embedding (PHATE)\nembeds high dimensional single-cell data into two or three dimensions for\nvisualization of biological progressions.\n\nFor more information and access to the object-oriented interface, read the\n`PHATE documentation <https://phate.readthedocs.io/>`__.  For\ntutorials, bug reports, and R/MATLAB implementations, visit the `PHATE\nGitHub page <https://github.com/KrishnaswamyLab/PHATE/>`__. For help\nusing PHATE, go `here <https://krishnaswamylab.org/get-help>`__.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nn_components\n    number of dimensions in which the data will be embedded\nk\n    number of nearest neighbors on which to build kernel\na\n    sets decay rate of kernel tails.\n    If None, alpha decaying kernel is not used\nn_landmark\n    number of landmarks to use in fast PHATE\nt\n    power to which the diffusion operator is powered\n    sets the level of diffusion. If 'auto', t is selected\n    according to the knee point in the Von Neumann Entropy of\n    the diffusion operator\ngamma\n    Informational distance constant between -1 and 1.\n    `gamma=1` gives the PHATE log potential, `gamma=0` gives\n    a square root potential.\nn_pca\n    Number of principal components to use for calculating\n    neighborhoods. For extremely large datasets, using\n    n_pca < 20 allows neighborhoods to be calculated in\n    log(n_samples) time.\nknn_dist\n    recommended values: 'euclidean' and 'cosine'\n    Any metric from `scipy.spatial.distance` can be used\n    distance metric for building kNN graph\nmds_dist\n    recommended values: 'euclidean' and 'cosine'\n    Any metric from `scipy.spatial.distance` can be used\n    distance metric for MDS\nmds\n    Selects which MDS algorithm is used for dimensionality reduction.\nn_jobs\n    The number of jobs to use for the computation.\n    If `None`, `sc.settings.n_jobs` is used.\n    If -1 all CPUs are used. If 1 is given, no parallel computing code is\n    used at all, which is useful for debugging.\n    For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for\n    n_jobs = -2, all CPUs but one are used\nrandom_state\n    Random seed. Defaults to the global `numpy` random number generator\nverbose\n    If `True` or an `int`/`Verbosity` \u2265 2/`hint`, print status messages.\n    If `None`, `sc.settings.verbosity` is used.\ncopy\n    Return a copy instead of writing to `adata`.\nkwargs\n    Additional arguments to `phate.PHATE`\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields.\n\n**X_phate** : `np.ndarray`, (`adata.obs`, shape=[n_samples, n_components], dtype `float`)\n    PHATE coordinates of data.\n\nExamples\n--------\n>>> from anndata import AnnData\n>>> import scanpy.external as sce\n>>> import phate\n>>> tree_data, tree_clusters = phate.tree.gen_dla(\n...     n_dim=100,\n...     n_branch=20,\n...     branch_length=100,\n... )\n>>> tree_data.shape\n(2000, 100)\n>>> adata = AnnData(tree_data)\n>>> sce.tl.phate(adata, k=5, a=20, t=150)\n>>> adata.obsm['X_phate'].shape\n(2000, 2)\n>>> sce.pl.phate(adata)",
        "description": "PHATE [Moon17]_.Potential of Heat-diffusion for Affinity-based Trajectory Embedding (PHATE)\nembeds high dimensional single-cell data into two or three dimensions for\nvisualization of biological progressions.\n\nFor more information and access to the object-oriented interface, read the\n`PHATE documentation <https://phate.readthedocs.io/>`__.  For\ntutorials, bug reports, and R/MATLAB implementations, visit the `PHATE\nGitHub page <https://github.com/KrishnaswamyLab/PHATE/>`__. For help\nusing PHATE, go `here <https://krishnaswamylab.org/get-help>`__.",
        "example": "Examples\n--------\n>>> from anndata import AnnData\n>>> import scanpy.external as sce\n>>> import phate\n>>> tree_data, tree_clusters = phate.tree.gen_dla(\n...     n_dim=100,\n...     n_branch=20,\n...     branch_length=100,\n... )\n>>> tree_data.shape\n(2000, 100)\n>>> adata = AnnData(tree_data)\n>>> sce.tl.phate(adata, k=5, a=20, t=150)\n>>> adata.obsm['X_phate'].shape\n(2000, 2)\n>>> sce.pl.phate(adata)",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.phate(adata=$, n_components=@, k=@, a=@, n_landmark=@, t=@, gamma=@, n_pca=@, knn_dist=@, mds_dist=@, mds=$, n_jobs=@, random_state=@, verbose=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot.swap_axes": {
        "Parameters": {
            "swap_axes": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'swap_axes'. Default True",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Plots a transposed image.\n\nBy default, the x axis contains `var_names` (e.g. genes) and the y\naxis the `groupby` categories. By setting `swap_axes` then x are\nthe `groupby` categories and y the `var_names`.\n\nParameters\n----------\nswap_axes\n    Boolean to turn on (True) or off (False) 'swap_axes'. Default True\n\n\nReturns\n-------\nBasePlot",
        "description": "Plots a transposed image.By default, the x axis contains `var_names` (e.g. genes) and the y\naxis the `groupby` categories. By setting `swap_axes` then x are\nthe `groupby` categories and y the `var_names`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.DotPlot.swap_axes(swap_axes=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.trimap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "n_components": {
                "type": "int",
                "default": "2",
                "optional": true,
                "description": "Number of dimensions of the embedding.",
                "optional_value": false
            },
            "n_inliers": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "Number of inlier points for triplet constraints.",
                "optional_value": false
            },
            "n_outliers": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "Number of outlier points for triplet constraints.",
                "optional_value": false
            },
            "n_random": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "Number of random triplet constraints per point.",
                "optional_value": false
            },
            "metric": {
                "type": "Literal[angular, euclidean, hamming, manhattan]",
                "default": "euclidean",
                "optional": true,
                "description": "Distance measure: 'angular', 'euclidean', 'hamming', 'manhattan'.",
                "optional_value": true
            },
            "weight_adj": {
                "type": "float",
                "default": "500.0",
                "optional": true,
                "description": "Adjusting the weights using a non-linear transformation.",
                "optional_value": false
            },
            "lr": {
                "type": "float",
                "default": "1000.0",
                "optional": true,
                "description": "Learning rate.",
                "optional_value": false
            },
            "n_iters": {
                "type": "int",
                "default": "400",
                "optional": true,
                "description": "Number of iterations.",
                "optional_value": false
            },
            "verbose": {
                "type": "Optional[Union[bool, int]]",
                "default": "None",
                "optional": true,
                "description": "If `True`, print the progress report.\nIf `None`, `sc.settings.verbosity` is used.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to `adata`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `adata` with the following fields.\n**X_trimap** : :class:`~numpy.ndarray`, (:attr:`~anndata.AnnData.obsm`, shape=(n_samples, n_components), dtype `float`)\nTriMap coordinates of data."
        },
        "Docstring": "TriMap: Large-scale Dimensionality Reduction Using Triplets [Amid19]_.\n\nTriMap is a dimensionality reduction method that uses triplet constraints\nto form a low-dimensional embedding of a set of points. The triplet\nconstraints are of the form \"point i is closer to point j than point k\".\nThe triplets are sampled from the high-dimensional representation of the\npoints and a weighting scheme is used to reflect the importance of each\ntriplet.\n\nTriMap provides a significantly better global view of the data than the\nother dimensionality reduction methods such t-SNE, LargeVis, and UMAP.\nThe global structure includes relative distances of the clusters, multiple\nscales in the data, and the existence of possible outliers. We define a\nglobal score to quantify the quality of an embedding in reflecting the\nglobal structure of the data.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nn_components\n    Number of dimensions of the embedding.\nn_inliers\n    Number of inlier points for triplet constraints.\nn_outliers\n    Number of outlier points for triplet constraints.\nn_random\n    Number of random triplet constraints per point.\nmetric\n    Distance measure: 'angular', 'euclidean', 'hamming', 'manhattan'.\nweight_adj\n    Adjusting the weights using a non-linear transformation.\nlr\n    Learning rate.\nn_iters\n    Number of iterations.\nverbose\n    If `True`, print the progress report.\n    If `None`, `sc.settings.verbosity` is used.\ncopy\n    Return a copy instead of writing to `adata`.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields.\n\n**X_trimap** : :class:`~numpy.ndarray`, (:attr:`~anndata.AnnData.obsm`, shape=(n_samples, n_components), dtype `float`)\n    TriMap coordinates of data.\n\nExample\n-------\n\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> pbmc = sc.datasets.pbmc68k_reduced()\n>>> pbmc = sce.tl.trimap(pbmc, copy=True)\n>>> sce.pl.trimap(pbmc, color=['bulk_labels'], s=10)",
        "description": "TriMap: Large-scale Dimensionality Reduction Using Triplets [Amid19]_.TriMap is a dimensionality reduction method that uses triplet constraints\nto form a low-dimensional embedding of a set of points. The triplet\nconstraints are of the form \"point i is closer to point j than point k\".\nThe triplets are sampled from the high-dimensional representation of the\npoints and a weighting scheme is used to reflect the importance of each\ntriplet.\n\nTriMap provides a significantly better global view of the data than the\nother dimensionality reduction methods such t-SNE, LargeVis, and UMAP.\nThe global structure includes relative distances of the clusters, multiple\nscales in the data, and the existence of possible outliers. We define a\nglobal score to quantify the quality of an embedding in reflecting the\nglobal structure of the data.",
        "example": "Example\n-------\n\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> pbmc = sc.datasets.pbmc68k_reduced()\n>>> pbmc = sce.tl.trimap(pbmc, copy=True)\n>>> sce.pl.trimap(pbmc, color=['bulk_labels'], s=10)",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.trimap(adata=$, n_components=@, n_inliers=@, n_outliers=@, n_random=@, metric=$, weight_adj=@, lr=@, n_iters=@, verbose=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.experimental.pp.recipe_pearson_residuals": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "theta": {
                "type": "float",
                "default": "100",
                "optional": true,
                "description": "The negative binomial overdispersion parameter `theta` for Pearson residuals.\nHigher values correspond to less overdispersion     (`var = mean + mean^2/theta`), and `theta=np.Inf` corresponds to a Poisson model.",
                "optional_value": false
            },
            "clip": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Determines if and how residuals are clipped:\n\n* If `None`, residuals are clipped to the interval     `[-sqrt(n_obs), sqrt(n_obs)]`, where `n_obs` is the number of cells in the dataset (default behavior).\n* If any scalar `c`, residuals are clipped to the interval `[-c, c]`. Set     `clip=np.Inf` for no clipping.",
                "optional_value": false
            },
            "n_top_genes": {
                "type": "int",
                "default": "1000",
                "optional": true,
                "description": "Number of highly-variable genes to keep. Mandatory if `flavor='seurat_v3'` or\n`flavor='pearson_residuals'`.",
                "optional_value": false
            },
            "batch_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If specified, highly-variable genes are selected within each batch separately\nand merged. This simple process avoids the selection of batch-specific genes\nand acts as a lightweight batch correction method. Genes are first sorted by\nhow many batches they are a HVG. If `flavor='pearson_residuals'`, ties are\nbroken by the median rank (across batches) based on within-batch residual\nvariance.",
                "optional_value": false
            },
            "chunksize": {
                "type": "int",
                "default": "1000",
                "optional": true,
                "description": "If `flavor='pearson_residuals'`, this dertermines how many genes are processed at\nonce while computing the residual variance. Choosing a smaller value will reduce\nthe required memory.",
                "optional_value": false
            },
            "n_comps": {
                "type": "Optional[int]",
                "default": "50",
                "optional": true,
                "description": "Number of principal components to compute in the PCA step.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[float]",
                "default": "0",
                "optional": true,
                "description": "Random seed for setting the initial states for the optimization in the PCA step.",
                "optional_value": false
            },
            "check_values": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, checks if counts in selected layer are integers as expected by this\nfunction, and return a warning if non-integers are found. Otherwise, proceed\nwithout checking. Setting this to `False` can speed up code for large datasets.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, update `adata` with results. Otherwise, return results. See below for\ndetails of what is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[tuple[AnnData, DataFrame]]",
            "description": "If `inplace=False`, separately returns the gene selection results (as\n:class:`~pandas.DataFrame`) and Pearson residual-based PCA results (as\n:class:`~anndata.AnnData`). If `inplace=True`, updates `adata` with the\nfollowing fields for gene selection results:\n`.var['highly_variable']` : bool\nboolean indicator of highly-variable genes.\n`.var['means']` : float\nmeans per gene.\n`.var['variances']` : float\nvariances per gene.\n`.var['residual_variances']` : float\nPearson residual variance per gene. Averaged in the case of multiple\nbatches.\n`.var['highly_variable_rank']` : float\nRank of the gene according to residual variance, median rank in the\ncase of multiple batches.\n`.var['highly_variable_nbatches']` : int\nIf batch_key is given, this denotes in how many batches genes are\ndetected as HVG.\n`.var['highly_variable_intersection']` : bool\nIf batch_key is given, this denotes the genes that are highly variable\nin all batches.\nThe following fields contain Pearson residual-based PCA results and\nnormalization settings:\n`.uns['pearson_residuals_normalization']['pearson_residuals_df']`\nThe subset of highly variable genes, normalized by Pearson residuals.\n`.uns['pearson_residuals_normalization']['theta']`\nThe used value of the overdisperion parameter theta.\n`.uns['pearson_residuals_normalization']['clip']`\nThe used value of the clipping parameter.\n`.obsm['X_pca']`\nPCA representation of data after gene selection and Pearson residual\nnormalization.\n`.varm['PCs']`\nThe principal components containing the loadings. When `inplace=True` this\nwill contain empty rows for the genes not selected during HVG selection.\n`.uns['pca']['variance_ratio']`\nRatio of explained variance.\n`.uns['pca']['variance']`\nExplained variance, equivalent to the eigenvalues of the covariance matrix."
        },
        "Docstring": "Full pipeline for HVG selection and normalization by analytic Pearson residuals ([Lause21]_).\n\nApplies gene selection based on Pearson residuals. On the resulting subset,\nPearson residual normalization and PCA are performed.\n\nExpects raw count input.\n\nParams\n------\nadata\n    The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\n\ntheta\n    The negative binomial overdispersion parameter `theta` for Pearson residuals.\n    Higher values correspond to less overdispersion     (`var = mean + mean^2/theta`), and `theta=np.Inf` corresponds to a Poisson model.\nclip\n    Determines if and how residuals are clipped:\n\n    * If `None`, residuals are clipped to the interval     `[-sqrt(n_obs), sqrt(n_obs)]`, where `n_obs` is the number of cells in the dataset (default behavior).\n    * If any scalar `c`, residuals are clipped to the interval `[-c, c]`. Set     `clip=np.Inf` for no clipping.\n\nn_top_genes\n    Number of highly-variable genes to keep. Mandatory if `flavor='seurat_v3'` or\n    `flavor='pearson_residuals'`.\nbatch_key\n    If specified, highly-variable genes are selected within each batch separately\n    and merged. This simple process avoids the selection of batch-specific genes\n    and acts as a lightweight batch correction method. Genes are first sorted by\n    how many batches they are a HVG. If `flavor='pearson_residuals'`, ties are\n    broken by the median rank (across batches) based on within-batch residual\n    variance.\nchunksize\n    If `flavor='pearson_residuals'`, this dertermines how many genes are processed at\n    once while computing the residual variance. Choosing a smaller value will reduce\n    the required memory.\n\nn_comps\n    Number of principal components to compute in the PCA step.\nrandom_state\n    Random seed for setting the initial states for the optimization in the PCA step.\nkwargs_pca\n    Dictionary of further keyword arguments passed on to `scanpy.pp.pca()`.\n\ncheck_values\n    If `True`, checks if counts in selected layer are integers as expected by this\n    function, and return a warning if non-integers are found. Otherwise, proceed\n    without checking. Setting this to `False` can speed up code for large datasets.\n\ninplace\n    If `True`, update `adata` with results. Otherwise, return results. See below for\n    details of what is returned.\n\n\nReturns\n-------\nIf `inplace=False`, separately returns the gene selection results (as\n:class:`~pandas.DataFrame`) and Pearson residual-based PCA results (as\n:class:`~anndata.AnnData`). If `inplace=True`, updates `adata` with the\nfollowing fields for gene selection results:\n\n`.var['highly_variable']` : bool\n    boolean indicator of highly-variable genes.\n`.var['means']` : float\n    means per gene.\n`.var['variances']` : float\n    variances per gene.\n`.var['residual_variances']` : float\n    Pearson residual variance per gene. Averaged in the case of multiple\n    batches.\n`.var['highly_variable_rank']` : float\n    Rank of the gene according to residual variance, median rank in the\n    case of multiple batches.\n`.var['highly_variable_nbatches']` : int\n    If batch_key is given, this denotes in how many batches genes are\n    detected as HVG.\n`.var['highly_variable_intersection']` : bool\n    If batch_key is given, this denotes the genes that are highly variable\n    in all batches.\n\nThe following fields contain Pearson residual-based PCA results and\nnormalization settings:\n\n`.uns['pearson_residuals_normalization']['pearson_residuals_df']`\n     The subset of highly variable genes, normalized by Pearson residuals.\n`.uns['pearson_residuals_normalization']['theta']`\n     The used value of the overdisperion parameter theta.\n`.uns['pearson_residuals_normalization']['clip']`\n     The used value of the clipping parameter.\n\n`.obsm['X_pca']`\n    PCA representation of data after gene selection and Pearson residual\n    normalization.\n`.varm['PCs']`\n     The principal components containing the loadings. When `inplace=True` this\n     will contain empty rows for the genes not selected during HVG selection.\n`.uns['pca']['variance_ratio']`\n     Ratio of explained variance.\n`.uns['pca']['variance']`\n     Explained variance, equivalent to the eigenvalues of the covariance matrix.",
        "description": "Full pipeline for HVG selection and normalization by analytic Pearson residuals ([Lause21]_).Applies gene selection based on Pearson residuals. On the resulting subset,\nPearson residual normalization and PCA are performed.\n\nExpects raw count input.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.experimental.pp.recipe_pearson_residuals(adata=$, theta=@, clip=@, n_top_genes=@, batch_key=@, chunksize=@, n_comps=@, random_state=@, check_values=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.Neighbors.compute_eigen": {
        "Parameters": {
            "n_comps": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "Number of eigenvalues/vectors to be computed, set `n_comps = 0` if\nyou need all eigenvectors.",
                "optional_value": false
            },
            "sym": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Instead of computing the eigendecomposition of the assymetric\ntransition matrix, computed the eigendecomposition of the symmetric\nKtilde matrix.",
                "optional_value": false
            },
            "sort": {
                "type": "Literal[decrease, increase]",
                "default": "decrease",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "A numpy random seed",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Writes the following attributes.\neigen_values : numpy.ndarray\nEigenvalues of transition matrix.\neigen_basis : numpy.ndarray\nMatrix of eigenvectors (stored in columns).  `.eigen_basis` is\nprojection of data matrix on right eigenvectors, that is, the\nprojection on the diffusion components.  these are simply the\ncomponents of the right eigenvectors and can directly be used for\nplotting."
        },
        "Docstring": "Compute eigen decomposition of transition matrix.\n\nParameters\n----------\nn_comps\n    Number of eigenvalues/vectors to be computed, set `n_comps = 0` if\n    you need all eigenvectors.\nsym\n    Instead of computing the eigendecomposition of the assymetric\n    transition matrix, computed the eigendecomposition of the symmetric\n    Ktilde matrix.\nrandom_state\n    A numpy random seed\n\nReturns\n-------\nWrites the following attributes.\n\neigen_values : numpy.ndarray\n    Eigenvalues of transition matrix.\neigen_basis : numpy.ndarray\n     Matrix of eigenvectors (stored in columns).  `.eigen_basis` is\n     projection of data matrix on right eigenvectors, that is, the\n     projection on the diffusion components.  these are simply the\n     components of the right eigenvectors and can directly be used for\n     plotting.",
        "description": "Compute eigen decomposition of transition matrix.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.Neighbors.compute_eigen(n_comps=@, sym=@, sort=$, random_state=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.Neighbors.compute_transitions": {
        "Parameters": {
            "density_normalize": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "The density rescaling of Coifman and Lafon (2006): Then only the\ngeometry of the data matters, not the sampled density.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Makes attributes `.transitions_sym` and `.transitions` available."
        },
        "Docstring": "Compute transition matrix.\n\nParameters\n----------\ndensity_normalize\n    The density rescaling of Coifman and Lafon (2006): Then only the\n    geometry of the data matters, not the sampled density.\n\nReturns\n-------\nMakes attributes `.transitions_sym` and `.transitions` available.",
        "description": "Compute transition matrix.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.Neighbors.compute_transitions(density_normalize=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot.show": {
        "Parameters": {
            "return_axes": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If true return a dictionary with the figure axes. When return_axes is true\nthen :func:`matplotlib.pyplot.show` is not called.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `return_axes=True`: Dict of :class:`matplotlib.axes.Axes`. The dict key\nindicates the type of ax (eg. `mainplot_ax`)\nSee also\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`savefig()`: Saves the plot."
        },
        "Docstring": "Show the figure\n\nParameters\n----------\nreturn_axes\n     If true return a dictionary with the figure axes. When return_axes is true\n     then :func:`matplotlib.pyplot.show` is not called.\n\nReturns\n-------\nIf `return_axes=True`: Dict of :class:`matplotlib.axes.Axes`. The dict key\nindicates the type of ax (eg. `mainplot_ax`)\n\nSee also\n--------\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`savefig()`: Saves the plot.\n\nExamples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.Plot(adata, markers, groupby='bulk_labels').show()",
        "description": "Show the figure",
        "example": "Examples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.Plot(adata, markers, groupby='bulk_labels').show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.MatrixPlot.show(return_axes=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.diffmap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Union[str, tuple[float, Ellipsis]]",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, List[Axes]]]",
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot in Diffusion Map basis.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.diffmap(adata)\n    sc.pl.diffmap(adata, color='bulk_labels')\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.diffmap",
        "description": "Scatter plot in Diffusion Map basis.",
        "example": "Examples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.diffmap(adata)\n    sc.pl.diffmap(adata, color='bulk_labels')\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.diffmap",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.diffmap(adata=$, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.rank_genes_groups": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The groups for which to show the gene ranking.",
                "optional_value": false
            },
            "n_genes": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of genes to show.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores gene symbols if you do not want to\nuse `.var_names`.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "rank_genes_groups",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "fontsize": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Fontsize for gene names.",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels shown per row.",
                "optional_value": false
            },
            "sharey": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Controls if the y-axis of each panels should be shared. But passing\n`sharey=False`, each panel has its own y-axis range.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroups\n    The groups for which to show the gene ranking.\ngene_symbols\n    Key for field in `.var` that stores gene symbols if you do not want to\n    use `.var_names`.\nn_genes\n    Number of genes to show.\nfontsize\n    Fontsize for gene names.\nncols\n    Number of panels shown per row.\nsharey\n    Controls if the y-axis of each panels should be shared. But passing\n    `sharey=False`, each panel has its own y-axis range.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.pl.rank_genes_groups(adata)\n\n\nPlot top 10 genes (default 20 genes)\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups(adata, n_genes=10)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.rank_genes_groups",
        "description": "Plot ranking of genes.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.pl.rank_genes_groups(adata)\n\n\nPlot top 10 genes (default 20 genes)\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups(adata, n_genes=10)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.rank_genes_groups",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.rank_genes_groups(adata=$, groups=@, n_genes=@, gene_symbols=@, key=@, fontsize=@, ncols=@, sharey=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pl.wishbone_marker_trajectory": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "markers": {
                "type": "Collection[str]",
                "default": null,
                "optional": false,
                "description": "Iterable of markers/genes to be plotted.",
                "optional_value": false
            },
            "no_bins": {
                "type": "int",
                "default": "150",
                "optional": true,
                "description": "Number of bins for calculating marker density.",
                "optional_value": false
            },
            "smoothing_factor": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Parameter controlling the degree of smoothing.",
                "optional_value": false
            },
            "min_delta": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Minimum difference in marker expression after normalization to show\nseparate trends for the two branches.",
                "optional_value": false
            },
            "show_variance": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Logical indicating if the trends should be accompanied with variance.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "width, height",
                "optional_value": false
            },
            "return_fig": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "show": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "Updates `adata` with the following fields:\n`trunk_wishbone` : :class:`pandas.DataFrame` (`adata.uns`)\nComputed values before branching\n`branch1_wishbone` : :class:`pandas.DataFrame` (`adata.uns`)\nComputed values for the first branch\n`branch2_wishbone` : :class:`pandas.DataFrame` (`adata.uns`)\nComputed values for the second branch."
        },
        "Docstring": "Plot marker trends along trajectory, and return trajectory branches for further\nanalysis and visualization (heatmap, etc..)\n\nParameters\n----------\nadata\n    Annotated data matrix.\nmarkers\n    Iterable of markers/genes to be plotted.\nshow_variance\n    Logical indicating if the trends should be accompanied with variance.\nno_bins\n    Number of bins for calculating marker density.\nsmoothing_factor\n    Parameter controlling the degree of smoothing.\nmin_delta\n    Minimum difference in marker expression after normalization to show\n    separate trends for the two branches.\nfigsize\n    width, height\nreturn_fig\n    Return the matplotlib figure.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nUpdates `adata` with the following fields:\n\n`trunk_wishbone` : :class:`pandas.DataFrame` (`adata.uns`)\n    Computed values before branching\n`branch1_wishbone` : :class:`pandas.DataFrame` (`adata.uns`)\n    Computed values for the first branch\n`branch2_wishbone` : :class:`pandas.DataFrame` (`adata.uns`)\n    Computed values for the second branch.",
        "description": "Plot marker trends along trajectory, and return trajectory branches for furtheranalysis and visualization (heatmap, etc..)",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pl.wishbone_marker_trajectory(adata=$, markers=@, no_bins=@, smoothing_factor=@, min_delta=@, show_variance=@, figsize=@, return_fig=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.harmony_timeseries": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix of shape n_obs `\u00d7` n_vars. Rows correspond to\ncells and columns to genes. Rows represent two or more time points,\nwhere replicates of the same time point are consecutive in order.",
                "optional_value": true
            },
            "tp": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "key name of observation annotation `.obs` representing time points. Time\npoints should be categorical of `dtype=category`. The unique categories for\nthe categorical will be used as the time points to construct the timepoint\nconnections.",
                "optional_value": false
            },
            "n_neighbors": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of nearest neighbors for graph construction.",
                "optional_value": false
            },
            "n_components": {
                "type": "Optional[int]",
                "default": "1000",
                "optional": true,
                "description": "Minimum number of principal components to use. Specify `None` to use\npre-computed components. The higher the value the better to capture 85% of the\nvariance.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "-2",
                "optional": true,
                "description": "Nearest Neighbors will be computed in parallel using n_jobs.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to `adata`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `.obsm`, `.obsp` and `.uns` with the following:\n**X_harmony** - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.obsm`, dtype `float`)\nforce directed layout\n**harmony_aff** - :class:`~scipy.sparse.spmatrix` (:attr:`~anndata.AnnData.obsp`, dtype `float`)\naffinity matrix\n**harmony_aff_aug** - :class:`~scipy.sparse.spmatrix` (:attr:`~anndata.AnnData.obsp`, dtype `float`)\naugmented affinity matrix\n**harmony_timepoint_var** - `str` (:attr:`~anndata.AnnData.uns`)\nThe name of the variable passed as `tp`\n**harmony_timepoint_connections** - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.uns`, dtype `str`)\nThe links between time points"
        },
        "Docstring": "Harmony time series for data visualization with augmented affinity matrix\nat discrete time points [Nowotschin18i]_.\n\nHarmony time series is a framework for data visualization, trajectory\ndetection and interpretation for scRNA-seq data measured at discrete\ntime points. Harmony constructs an augmented affinity matrix by augmenting\nthe kNN graph affinity matrix with mutually nearest neighbors between\nsuccessive time points. This augmented affinity matrix forms the basis for\ngenerated a force directed layout for visualization and also serves as input\nfor computing the diffusion operator which can be used for trajectory\ndetection using Palantir_.\n\n.. _Palantir: https://github.com/dpeerlab/Palantir\n\n.. note::\n   More information and bug reports `here\n   <https://github.com/dpeerlab/Harmony>`__.\n\nParameters\n----------\nadata\n    Annotated data matrix of shape n_obs `\u00d7` n_vars. Rows correspond to\n    cells and columns to genes. Rows represent two or more time points,\n    where replicates of the same time point are consecutive in order.\ntp\n    key name of observation annotation `.obs` representing time points. Time\n    points should be categorical of `dtype=category`. The unique categories for\n    the categorical will be used as the time points to construct the timepoint\n    connections.\nn_neighbors\n    Number of nearest neighbors for graph construction.\nn_components\n    Minimum number of principal components to use. Specify `None` to use\n    pre-computed components. The higher the value the better to capture 85% of the\n    variance.\nn_jobs\n    Nearest Neighbors will be computed in parallel using n_jobs.\ncopy\n    Return a copy instead of writing to `adata`.\n\nReturns\n-------\nDepending on `copy`, returns or updates `.obsm`, `.obsp` and `.uns` with the following:\n\n**X_harmony** - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.obsm`, dtype `float`)\n    force directed layout\n**harmony_aff** - :class:`~scipy.sparse.spmatrix` (:attr:`~anndata.AnnData.obsp`, dtype `float`)\n    affinity matrix\n**harmony_aff_aug** - :class:`~scipy.sparse.spmatrix` (:attr:`~anndata.AnnData.obsp`, dtype `float`)\n    augmented affinity matrix\n**harmony_timepoint_var** - `str` (:attr:`~anndata.AnnData.uns`)\n    The name of the variable passed as `tp`\n**harmony_timepoint_connections** - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.uns`, dtype `str`)\n    The links between time points\n\nExample\n-------\n\n>>> from itertools import product\n>>> import pandas as pd\n>>> from anndata import AnnData\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n\n**Load** `AnnData`\n\nA sample with real data is available here_.\n\n.. _here: https://github.com/dpeerlab/Harmony/tree/master/data\n\nRandom data sets of three time points with two replicates each:\n\n>>> adata_ref = sc.datasets.pbmc3k()\n>>> start = [596, 615, 1682, 1663, 1409, 1432]\n>>> adata = AnnData.concatenate(\n...     *(adata_ref[i : i + 1000] for i in start),\n...     join=\"outer\",\n...     batch_key=\"sample\",\n...     batch_categories=[f\"sa{i}_Rep{j}\" for i, j in product((1, 2, 3), (1, 2))],\n... )\n>>> time_points = adata.obs[\"sample\"].str.split(\"_\", expand=True)[0]\n>>> adata.obs[\"time_points\"] = pd.Categorical(\n....    time_points, categories=['sa1', 'sa2', 'sa3']\n... )\n\nNormalize and filter for highly expressed genes\n\n>>> sc.pp.normalize_total(adata, target_sum=10000)\n>>> sc.pp.log1p(adata)\n>>> sc.pp.highly_variable_genes(adata, n_top_genes=1000, subset=True)\n\nRun harmony_timeseries\n\n>>> sce.tl.harmony_timeseries(adata, tp=\"time_points\", n_components=500)\n\nPlot time points:\n\n>>> sce.pl.harmony_timeseries(adata)\n\nFor further demonstration of Harmony visualizations please follow the notebook\n`Harmony_sample_notebook.ipynb\n<https://github.com/dpeerlab/Harmony/blob/master/notebooks/\nHarmony_sample_notebook.ipynb>`_.\nIt provides a comprehensive guide to draw *gene expression trends*,\namongst other things.",
        "description": "Harmony time series for data visualization with augmented affinity matrixat discrete time points [Nowotschin18i]_.\n\nHarmony time series is a framework for data visualization, trajectory\ndetection and interpretation for scRNA-seq data measured at discrete\ntime points. Harmony constructs an augmented affinity matrix by augmenting\nthe kNN graph affinity matrix with mutually nearest neighbors between\nsuccessive time points. This augmented affinity matrix forms the basis for\ngenerated a force directed layout for visualization and also serves as input\nfor computing the diffusion operator which can be used for trajectory\ndetection using Palantir_.\n\n.. _Palantir: https://github.com/dpeerlab/Palantir\n\n.. note::\n   More information and bug reports `here\n   <https://github.com/dpeerlab/Harmony>`__.",
        "example": "Example\n-------\n\n>>> from itertools import product\n>>> import pandas as pd\n>>> from anndata import AnnData\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n\n**Load** `AnnData`\n\nA sample with real data is available here_.\n\n.. _here: https://github.com/dpeerlab/Harmony/tree/master/data\n\nRandom data sets of three time points with two replicates each:\n\n>>> adata_ref = sc.datasets.pbmc3k()\n>>> start = [596, 615, 1682, 1663, 1409, 1432]\n>>> adata = AnnData.concatenate(\n...     *(adata_ref[i : i + 1000] for i in start),\n...     join=\"outer\",\n...     batch_key=\"sample\",\n...     batch_categories=[f\"sa{i}_Rep{j}\" for i, j in product((1, 2, 3), (1, 2))],\n... )\n>>> time_points = adata.obs[\"sample\"].str.split(\"_\", expand=True)[0]\n>>> adata.obs[\"time_points\"] = pd.Categorical(\n....    time_points, categories=['sa1', 'sa2', 'sa3']\n... )\n\nNormalize and filter for highly expressed genes\n\n>>> sc.pp.normalize_total(adata, target_sum=10000)\n>>> sc.pp.log1p(adata)\n>>> sc.pp.highly_variable_genes(adata, n_top_genes=1000, subset=True)\n\nRun harmony_timeseries\n\n>>> sce.tl.harmony_timeseries(adata, tp=\"time_points\", n_components=500)\n\nPlot time points:\n\n>>> sce.pl.harmony_timeseries(adata)\n\nFor further demonstration of Harmony visualizations please follow the notebook\n`Harmony_sample_notebook.ipynb\n<https://github.com/dpeerlab/Harmony/blob/master/notebooks/\nHarmony_sample_notebook.ipynb>`_.\nIt provides a comprehensive guide to draw *gene expression trends*,\namongst other things.",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.harmony_timeseries(adata=$, tp=@, n_neighbors=@, n_components=@, n_jobs=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_h5ad": {
        "Parameters": {
            "filename": {
                "type": "Union[str, Path]",
                "default": null,
                "optional": false,
                "description": "File name of data file.",
                "optional_value": false
            },
            "backed": {
                "type": "Optional[Union[Literal[r, r+], bool]]",
                "default": "None",
                "optional": true,
                "description": "If `'r'`, load :class:`~anndata.AnnData` in `backed` mode\ninstead of fully loading it into memory (`memory` mode).\nIf you want to modify backed attributes of the AnnData object,\nyou need to choose `'r+'`.\n\nCurrently, `backed` only support updates to `X`. That means any\nchanges to other slots like `obs` will not be written to disk in\n`backed` mode. If you would like save changes made to these slots\nof a `backed` :class:`~anndata.AnnData`, write them to a new file\n(see :meth:`~anndata.AnnData.write`). For an example, see\n[here] (https://anndata-tutorials.readthedocs.io/en/latest/getting-started.html#Partial-reading-of-large-data).",
                "optional_value": false
            },
            "as_sparse": {
                "type": "Sequence[str]",
                "default": "()",
                "optional": true,
                "description": "If an array was saved as dense, passing its name here will read it as\na sparse_matrix, by chunk of size `chunk_size`.",
                "optional_value": false
            },
            "as_sparse_fmt": {
                "type": "type[spmatrix]",
                "default": "<class 'scipy.sparse._csr.csr_matrix'>",
                "optional": true,
                "description": "Sparse format class to read elements from `as_sparse` in as.",
                "optional_value": true
            },
            "chunk_size": {
                "type": "int",
                "default": "6000",
                "optional": true,
                "description": "Used only when loading sparse dataset that is stored as dense.\nLoading iterates through chunks of the dataset of this row size\nuntil it reads the whole dataset.\nHigher size means higher memory consumption and higher (to a point)\nloading speed.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Read `.h5ad`-formatted hdf5 file.\n\nParameters\n----------\nfilename\n    File name of data file.\nbacked\n    If `'r'`, load :class:`~anndata.AnnData` in `backed` mode\n    instead of fully loading it into memory (`memory` mode).\n    If you want to modify backed attributes of the AnnData object,\n    you need to choose `'r+'`.\n\n    Currently, `backed` only support updates to `X`. That means any\n    changes to other slots like `obs` will not be written to disk in\n    `backed` mode. If you would like save changes made to these slots\n    of a `backed` :class:`~anndata.AnnData`, write them to a new file\n    (see :meth:`~anndata.AnnData.write`). For an example, see\n    [here] (https://anndata-tutorials.readthedocs.io/en/latest/getting-started.html#Partial-reading-of-large-data).\nas_sparse\n    If an array was saved as dense, passing its name here will read it as\n    a sparse_matrix, by chunk of size `chunk_size`.\nas_sparse_fmt\n    Sparse format class to read elements from `as_sparse` in as.\nchunk_size\n    Used only when loading sparse dataset that is stored as dense.\n    Loading iterates through chunks of the dataset of this row size\n    until it reads the whole dataset.\n    Higher size means higher memory consumption and higher (to a point)\n    loading speed.",
        "description": "Read `.h5ad`-formatted hdf5 file.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_h5ad(filename=@, backed=@, as_sparse=@, as_sparse_fmt=$, chunk_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.experimental.pp.highly_variable_genes": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "theta": {
                "type": "float",
                "default": "100",
                "optional": true,
                "description": "The negative binomial overdispersion parameter `theta` for Pearson residuals.\nHigher values correspond to less overdispersion     (`var = mean + mean^2/theta`), and `theta=np.Inf` corresponds to a Poisson model.",
                "optional_value": false
            },
            "clip": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Determines if and how residuals are clipped:\n\n* If `None`, residuals are clipped to the interval     `[-sqrt(n_obs), sqrt(n_obs)]`, where `n_obs` is the number of cells in the dataset (default behavior).\n* If any scalar `c`, residuals are clipped to the interval `[-c, c]`. Set     `clip=np.Inf` for no clipping.",
                "optional_value": false
            },
            "n_top_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of highly-variable genes to keep. Mandatory if `flavor='seurat_v3'` or\n`flavor='pearson_residuals'`.",
                "optional_value": false
            },
            "batch_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If specified, highly-variable genes are selected within each batch separately\nand merged. This simple process avoids the selection of batch-specific genes\nand acts as a lightweight batch correction method. Genes are first sorted by\nhow many batches they are a HVG. If `flavor='pearson_residuals'`, ties are\nbroken by the median rank (across batches) based on within-batch residual\nvariance.",
                "optional_value": false
            },
            "chunksize": {
                "type": "int",
                "default": "1000",
                "optional": true,
                "description": "If `flavor='pearson_residuals'`, this dertermines how many genes are processed at\nonce while computing the residual variance. Choosing a smaller value will reduce\nthe required memory.",
                "optional_value": false
            },
            "flavor": {
                "type": "Literal[pearson_residuals]",
                "default": "pearson_residuals",
                "optional": true,
                "description": "Choose the flavor for identifying highly variable genes. In this experimental\nversion, only 'pearson_residuals' is functional.",
                "optional_value": true
            },
            "check_values": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, checks if counts in selected layer are integers as expected by this\nfunction, and return a warning if non-integers are found. Otherwise, proceed\nwithout checking. Setting this to `False` can speed up code for large datasets.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Layer to use as input instead of `X`. If `None`, `X` is used.",
                "optional_value": false
            },
            "subset": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, subset the data to highly-variable genes after finding them.\nOtherwise merely indicate highly variable genes in `adata.var` (see below).",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, update `adata` with results. Otherwise, return results. See below for\ndetails of what is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[DataFrame]",
            "description": "If `inplace=True`, `adata.var` is updated with the following fields. Otherwise,\nreturns the same fields as :class:`~pandas.DataFrame`.\nhighly_variable : bool\nboolean indicator of highly-variable genes.\nmeans : float\nmeans per gene.\nvariances : float\nvariance per gene.\nresidual_variances : float\nFor `flavor='pearson_residuals'`, residual variance per gene. Averaged in the\ncase of multiple batches.\nhighly_variable_rank : float\nFor `flavor='pearson_residuals'`, rank of the gene according to residual.\nvariance, median rank in the case of multiple batches.\nhighly_variable_nbatches : int\nIf `batch_key` given, denotes in how many batches genes are detected as HVG.\nhighly_variable_intersection : bool\nIf `batch_key` given, denotes the genes that are highly variable in all batches.\nNotes\nExperimental version of `sc.pp.highly_variable_genes()`"
        },
        "Docstring": "Select highly variable genes using analytic Pearson residuals [Lause21]_.\n\nIn [Lause21]_, Pearson residuals of a negative binomial offset model are computed\n(with overdispersion `theta` shared across genes). By default, overdispersion\n`theta=100` is used and residuals are clipped to `sqrt(n_obs)`. Finally, genes\nare ranked by residual variance.\n\nExpects raw count input.\n\nParameters\n----------\nadata\n    The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\n\ntheta\n    The negative binomial overdispersion parameter `theta` for Pearson residuals.\n    Higher values correspond to less overdispersion     (`var = mean + mean^2/theta`), and `theta=np.Inf` corresponds to a Poisson model.\nclip\n    Determines if and how residuals are clipped:\n\n    * If `None`, residuals are clipped to the interval     `[-sqrt(n_obs), sqrt(n_obs)]`, where `n_obs` is the number of cells in the dataset (default behavior).\n    * If any scalar `c`, residuals are clipped to the interval `[-c, c]`. Set     `clip=np.Inf` for no clipping.\n\nn_top_genes\n    Number of highly-variable genes to keep. Mandatory if `flavor='seurat_v3'` or\n    `flavor='pearson_residuals'`.\nbatch_key\n    If specified, highly-variable genes are selected within each batch separately\n    and merged. This simple process avoids the selection of batch-specific genes\n    and acts as a lightweight batch correction method. Genes are first sorted by\n    how many batches they are a HVG. If `flavor='pearson_residuals'`, ties are\n    broken by the median rank (across batches) based on within-batch residual\n    variance.\nchunksize\n    If `flavor='pearson_residuals'`, this dertermines how many genes are processed at\n    once while computing the residual variance. Choosing a smaller value will reduce\n    the required memory.\n\nflavor\n    Choose the flavor for identifying highly variable genes. In this experimental\n    version, only 'pearson_residuals' is functional.\ncheck_values\n    If `True`, checks if counts in selected layer are integers as expected by this\n    function, and return a warning if non-integers are found. Otherwise, proceed\n    without checking. Setting this to `False` can speed up code for large datasets.\n\nlayer\n    Layer to use as input instead of `X`. If `None`, `X` is used.\n\nsubset\n    If `True`, subset the data to highly-variable genes after finding them.\n    Otherwise merely indicate highly variable genes in `adata.var` (see below).\ninplace\n    If `True`, update `adata` with results. Otherwise, return results. See below for\n    details of what is returned.\n\n\nReturns\n-------\nIf `inplace=True`, `adata.var` is updated with the following fields. Otherwise,\nreturns the same fields as :class:`~pandas.DataFrame`.\n\nhighly_variable : bool\n    boolean indicator of highly-variable genes.\nmeans : float\n    means per gene.\nvariances : float\n    variance per gene.\nresidual_variances : float\n    For `flavor='pearson_residuals'`, residual variance per gene. Averaged in the\n    case of multiple batches.\nhighly_variable_rank : float\n    For `flavor='pearson_residuals'`, rank of the gene according to residual.\n    variance, median rank in the case of multiple batches.\nhighly_variable_nbatches : int\n    If `batch_key` given, denotes in how many batches genes are detected as HVG.\nhighly_variable_intersection : bool\n    If `batch_key` given, denotes the genes that are highly variable in all batches.\n\nNotes\n-----\nExperimental version of `sc.pp.highly_variable_genes()`",
        "description": "Select highly variable genes using analytic Pearson residuals [Lause21]_.In [Lause21]_, Pearson residuals of a negative binomial offset model are computed\n(with overdispersion `theta` shared across genes). By default, overdispersion\n`theta=100` is used and residuals are clipped to `sqrt(n_obs)`. Finally, genes\nare ranked by residual variance.\n\nExpects raw count input.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.experimental.pp.highly_variable_genes(adata=$, theta=@, clip=@, n_top_genes=@, batch_key=@, chunksize=@, flavor=$, check_values=@, layer=@, subset=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.Neighbors": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "n_dcs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of diffusion components to use.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Where to look in .uns and .obsp for neighbors data",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Data represented as graph of nearest neighbors.\n\nRepresent a data matrix as a graph of nearest neighbor relations (edges)\namong data points (nodes).\n\nParameters\n----------\nadata\n    Annotated data object.\nn_dcs\n    Number of diffusion components to use.\nneighbors_key\n    Where to look in .uns and .obsp for neighbors data",
        "description": "Data represented as graph of nearest neighbors.Represent a data matrix as a graph of nearest neighbor relations (edges)\namong data points (nodes).",
        "example": "",
        "api_type": "class",
        "api_calling": [
            "scanpy.Neighbors(adata=$, n_dcs=@, neighbors_key=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.Neighbors.to_igraph": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Generate igraph from connectiviies.",
        "description": "Generate igraph from connectiviies.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.Neighbors.to_igraph()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.logging.print_header": {
        "Parameters": {
            "file": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Versions that might influence the numerical results.\nMatplotlib and Seaborn are excluded from this.",
        "description": "Versions that might influence the numerical results.Matplotlib and Seaborn are excluded from this.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.logging.print_header(file=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot.swap_axes": {
        "Parameters": {
            "swap_axes": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'swap_axes'. Default True",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Plots a transposed image.\n\nBy default, the x axis contains `var_names` (e.g. genes) and the y\naxis the `groupby` categories. By setting `swap_axes` then x are\nthe `groupby` categories and y the `var_names`.\n\nParameters\n----------\nswap_axes\n    Boolean to turn on (True) or off (False) 'swap_axes'. Default True\n\n\nReturns\n-------\nBasePlot",
        "description": "Plots a transposed image.By default, the x axis contains `var_names` (e.g. genes) and the y\naxis the `groupby` categories. By setting `swap_axes` then x are\nthe `groupby` categories and y the `var_names`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.MatrixPlot.swap_axes(swap_axes=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
                "optional_value": false
            },
            "categories_order": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Order in which to show the categories. Note: add_dendrogram or add_totals\ncan change the categories order.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`.\nOtherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "expression_cutoff": {
                "type": "float",
                "default": "0.0",
                "optional": true,
                "description": "Expression cutoff that is used for binarizing the gene expression and\ndetermining the fraction of cells expressing given genes. A gene is\nexpressed only if the expression value is greater than this threshold.",
                "optional_value": false
            },
            "mean_only_expressed": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, gene expression is averaged only over the cells\nexpressing the given genes.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Literal[var, group]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize that dimension between 0 and 1,\nmeaning for each variable or group,\nsubtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "dot_color_df": {
                "type": "Optional[DataFrame]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "dot_size_df": {
                "type": "Optional[DataFrame]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Allows the visualization of two values that are encoded as\ndot size and color. The size usually represents the fraction\nof cells (obs) that have a non-zero value for genes (var).\n\nFor each var_name and each `groupby` category a dot is plotted.\nEach dot represents two values: mean expression within each category\n(visualized by color) and fraction of cells expressing the `var_name` in the\ncategory (visualized by the size of the dot). If `groupby` is not given,\nthe dotplot assumes that all data belongs to a single category.\n\n.. note::\n   A gene is considered expressed if the expression value in the `adata` (or\n   `adata.raw`) is above the specified threshold which is zero by default.\n\nAn example of dotplot usage is to visualize, for multiple marker genes,\nthe mean value and the percentage of cells expressing the gene\nacross multiple clusters.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nvar_names\n    `var_names` should be a valid subset of `adata.var_names`.\n    If `var_names` is a mapping, then the key is used as label\n    to group the values (see `var_group_labels`). The mapping values\n    should be sequences of valid `adata.var_names`. In this\n    case either coloring or 'brackets' are used for the grouping\n    of var names depending on the plot. When `var_names` is a mapping,\n    then the `var_group_labels` and `var_group_positions` are set.\ngroupby\n    The key of the observation grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlog\n    Plot on logarithmic axis.\nnum_categories\n    Only used if groupby observation is not categorical. This value\n    determines the number of groups into which the groupby observation\n    should be subdivided.\ncategories_order\n    Order in which to show the categories. Note: add_dendrogram or add_totals\n    can change the categories order.\nfigsize\n    Figure size when `multi_panel=True`.\n    Otherwise the `rcParam['figure.figsize]` value is used.\n    Format is (width, height)\ndendrogram\n    If True or a valid dendrogram key, a dendrogram based on the hierarchical\n    clustering between the `groupby` categories is added.\n    The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n    If `tl.dendrogram` has not been called previously the function is called\n    with default parameters.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols.\n    By default `var_names` refer to the index column of the `.var` DataFrame.\n    Setting this option allows alternative names to be used.\nvar_group_positions\n    Use this parameter to highlight groups of `var_names`.\n    This will draw a 'bracket' or a color block between the given start and end\n    positions. If the parameter `var_group_labels` is set, the corresponding\n    labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n    will add a bracket between the fourth `var_name` and the tenth `var_name`.\n    By giving more positions, more brackets/color blocks are drawn.\nvar_group_labels\n    Labels for each of the `var_group_positions` that want to be highlighted.\nvar_group_rotation\n    Label rotation degrees.\n    By default, labels larger than 4 characters are rotated 90 degrees.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n    If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\ntitle\n    Title for the figure\nexpression_cutoff\n    Expression cutoff that is used for binarizing the gene expression and\n    determining the fraction of cells expressing given genes. A gene is\n    expressed only if the expression value is greater than this threshold.\nmean_only_expressed\n    If True, gene expression is averaged only over the cells\n    expressing the given genes.\nstandard_scale\n    Whether or not to standardize that dimension between 0 and 1,\n    meaning for each variable or group,\n    subtract the minimum and divide each by its maximum.\nkwds\n    Are passed to :func:`matplotlib.pyplot.scatter`.\n\nSee also\n--------\n:func:`~scanpy.pl.dotplot`: Simpler way to call DotPlot but with less options.\n:func:`~scanpy.pl.rank_genes_groups_dotplot`: to plot marker\n    genes identified using the :func:`~scanpy.tl.rank_genes_groups` function.\n\nExamples\n--------\n\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels').show()\n\nUsing var_names as dict:\n\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels').show()",
        "description": "Allows the visualization of two values that are encoded asdot size and color. The size usually represents the fraction\nof cells (obs) that have a non-zero value for genes (var).\n\nFor each var_name and each `groupby` category a dot is plotted.\nEach dot represents two values: mean expression within each category\n(visualized by color) and fraction of cells expressing the `var_name` in the\ncategory (visualized by the size of the dot). If `groupby` is not given,\nthe dotplot assumes that all data belongs to a single category.\n\n.. note::\n   A gene is considered expressed if the expression value in the `adata` (or\n   `adata.raw`) is above the specified threshold which is zero by default.\n\nAn example of dotplot usage is to visualize, for multiple marker genes,\nthe mean value and the percentage of cells expressing the gene\nacross multiple clusters.",
        "example": "Examples\n--------\n\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels').show()\n\nUsing var_names as dict:\n\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels').show()",
        "api_type": "class",
        "api_calling": [
            "scanpy.pl.DotPlot(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, categories_order=@, title=@, figsize=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, expression_cutoff=@, mean_only_expressed=@, standard_scale=$, dot_color_df=$, dot_size_df=$, ax=$, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot.add_totals": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'add_totals'",
                "optional_value": false
            },
            "sort": {
                "type": "Literal[ascending, descending]",
                "default": "None",
                "optional": true,
                "description": "Set to either 'ascending' or 'descending' to reorder the categories\nby cell number",
                "optional_value": true
            },
            "size": {
                "type": "Optional[float]",
                "default": "0.8",
                "optional": true,
                "description": "size of the barplot. Corresponds to width when shown on\nthe right of the plot, or height when shown on top. The unit is the same\nas in matplotlib (inches).",
                "optional_value": false
            },
            "color": {
                "type": "Optional[Union[str, tuple[float, Ellipsis], Sequence[Union[str, tuple[float, Ellipsis]]]]]",
                "default": "None",
                "optional": true,
                "description": "Color for the bar plots or list of colors for each of the bar plots.\nBy default, each bar plot uses the colors assigned in\n`adata.uns[{groupby}_colors]`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Show barplot for the number of cells in in `groupby` category.\n\nThe barplot is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n\nParameters\n----------\nshow\n    Boolean to turn on (True) or off (False) 'add_totals'\nsort\n    Set to either 'ascending' or 'descending' to reorder the categories\n    by cell number\nsize\n    size of the barplot. Corresponds to width when shown on\n    the right of the plot, or height when shown on top. The unit is the same\n    as in matplotlib (inches).\ncolor\n    Color for the bar plots or list of colors for each of the bar plots.\n    By default, each bar plot uses the colors assigned in\n    `adata.uns[{groupby}_colors]`.\n\n\nReturns\n-------\nBasePlot\n\n\nExamples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_totals().show()",
        "description": "Show barplot for the number of cells in in `groupby` category.The barplot is by default shown on the right side of the plot or on top\nif the axes are swapped.",
        "example": "Examples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_totals().show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.DotPlot.add_totals(show=@, sort=$, size=@, color=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot.make_figure": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Renders the image but does not call :func:`matplotlib.pyplot.show`. Useful\nwhen several plots are put together into one figure.\n\nSee also\n--------\n`show()`: Renders and shows the plot.\n`savefig()`: Saves the plot.\n\nExamples\n--------\n\n>>> import matplotlib.pyplot as plt\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> fig, (ax0, ax1) = plt.subplots(1, 2)\n>>> sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels', ax=ax0)        ...               .style(cmap='Blues', edge_color='none').make_figure()\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels', ax=ax1).make_figure()",
        "description": "Renders the image but does not call :func:`matplotlib.pyplot.show`. Usefulwhen several plots are put together into one figure.\n\nSee also\n--------\n`show()`: Renders and shows the plot.\n`savefig()`: Saves the plot.",
        "example": "Examples\n--------\n\n>>> import matplotlib.pyplot as plt\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> fig, (ax0, ax1) = plt.subplots(1, 2)\n>>> sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels', ax=ax0)        ...               .style(cmap='Blues', edge_color='none').make_figure()\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels', ax=ax1).make_figure()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.DotPlot.make_figure()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot.savefig": {
        "Parameters": {
            "filename": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Figure filename. Figure *format* is taken from the file ending unless\nthe parameter `format` is given.",
                "optional_value": false
            },
            "bbox_inches": {
                "type": "Optional[str]",
                "default": "tight",
                "optional": true,
                "description": "By default is set to 'tight' to avoid cropping of the legends.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Save the current figure\n\nParameters\n----------\nfilename\n    Figure filename. Figure *format* is taken from the file ending unless\n    the parameter `format` is given.\nbbox_inches\n    By default is set to 'tight' to avoid cropping of the legends.\nkwargs\n    Passed to :func:`matplotlib.pyplot.savefig`\n\nSee also\n--------\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`show()`: Renders and shows the plot\n\nExamples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').savefig('plot.pdf')",
        "description": "Save the current figure",
        "example": "Examples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').savefig('plot.pdf')",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.DotPlot.savefig(filename=@, bbox_inches=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot.show": {
        "Parameters": {
            "return_axes": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If true return a dictionary with the figure axes. When return_axes is true\nthen :func:`matplotlib.pyplot.show` is not called.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `return_axes=True`: Dict of :class:`matplotlib.axes.Axes`. The dict key\nindicates the type of ax (eg. `mainplot_ax`)\nSee also\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`savefig()`: Saves the plot."
        },
        "Docstring": "Show the figure\n\nParameters\n----------\nreturn_axes\n     If true return a dictionary with the figure axes. When return_axes is true\n     then :func:`matplotlib.pyplot.show` is not called.\n\nReturns\n-------\nIf `return_axes=True`: Dict of :class:`matplotlib.axes.Axes`. The dict key\nindicates the type of ax (eg. `mainplot_ax`)\n\nSee also\n--------\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`savefig()`: Saves the plot.\n\nExamples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.Plot(adata, markers, groupby='bulk_labels').show()",
        "description": "Show the figure",
        "example": "Examples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.Plot(adata, markers, groupby='bulk_labels').show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.DotPlot.show(return_axes=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.DotPlot.style": {
        "Parameters": {
            "cmap": {
                "type": "str",
                "default": "winter",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "color_on": {
                "type": "Optional[Literal[dot, square]]",
                "default": "dot",
                "optional": true,
                "description": "Options are 'dot' or 'square'. Be default the colomap is applied to\nthe color of the dot. Optionally, the colormap can be applied to an\nsquare behind the dot, in which case the dot is transparent and only\nthe edge is shown.",
                "optional_value": true
            },
            "dot_max": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If none, the maximum dot size is set to the maximum fraction value found\n(e.g. 0.6). If given, the value should be a number between 0 and 1.\nAll fractions larger than dot_max are clipped to this value.",
                "optional_value": false
            },
            "dot_min": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If none, the minimum dot size is set to 0. If given,\nthe value should be a number between 0 and 1.\nAll fractions smaller than dot_min are clipped to this value.",
                "optional_value": false
            },
            "smallest_dot": {
                "type": "Optional[float]",
                "default": "0.0",
                "optional": true,
                "description": "If none, the smallest dot has size 0.\nAll expression fractions with `dot_min` are plotted with this size.",
                "optional_value": false
            },
            "largest_dot": {
                "type": "Optional[float]",
                "default": "200.0",
                "optional": true,
                "description": "If none, the largest dot has size 200.\nAll expression fractions with `dot_max` are plotted with this size.",
                "optional_value": false
            },
            "dot_edge_color": {
                "type": "Optional[Union[str, tuple[float, Ellipsis]]]",
                "default": "black",
                "optional": true,
                "description": "Dot edge color. When `color_on='dot'` the default is no edge. When\n`color_on='square'`, edge color is white for darker colors and black\nfor lighter background square colors.",
                "optional_value": false
            },
            "dot_edge_lw": {
                "type": "Optional[float]",
                "default": "0.2",
                "optional": true,
                "description": "Dot edge line width. When `color_on='dot'` the default is no edge. When\n`color_on='square'`, line width = 1.5.",
                "optional_value": false
            },
            "size_exponent": {
                "type": "Optional[float]",
                "default": "1.5",
                "optional": true,
                "description": "Dot size is computed as:\nfraction  ** size exponent and afterwards scaled to match the\n`smallest_dot` and `largest_dot` size parameters.\nUsing a different size exponent changes the relative sizes of the dots\nto each other.",
                "optional_value": false
            },
            "grid": {
                "type": "Optional[float]",
                "default": "False",
                "optional": true,
                "description": "Set to true to show grid lines. By default grid lines are not shown.\nFurther configuration of the grid lines can be achieved directly on the\nreturned ax.",
                "optional_value": false
            },
            "x_padding": {
                "type": "Optional[float]",
                "default": "0.8",
                "optional": true,
                "description": "Space between the plot left/right borders and the dots center. A unit\nis the distance between the x ticks. Only applied when color_on = dot",
                "optional_value": false
            },
            "y_padding": {
                "type": "Optional[float]",
                "default": "1.0",
                "optional": true,
                "description": "Space between the plot top/bottom borders and the dots center. A unit is\nthe distance between the y ticks. Only applied when color_on = dot",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ":class:`~scanpy.pl.DotPlot`"
        },
        "Docstring": "Modifies plot visual parameters\n\nParameters\n----------\ncmap\n    String denoting matplotlib color map.\ncolor_on\n    Options are 'dot' or 'square'. Be default the colomap is applied to\n    the color of the dot. Optionally, the colormap can be applied to an\n    square behind the dot, in which case the dot is transparent and only\n    the edge is shown.\ndot_max\n    If none, the maximum dot size is set to the maximum fraction value found\n    (e.g. 0.6). If given, the value should be a number between 0 and 1.\n    All fractions larger than dot_max are clipped to this value.\ndot_min\n    If none, the minimum dot size is set to 0. If given,\n    the value should be a number between 0 and 1.\n    All fractions smaller than dot_min are clipped to this value.\nsmallest_dot\n    If none, the smallest dot has size 0.\n    All expression fractions with `dot_min` are plotted with this size.\nlargest_dot\n    If none, the largest dot has size 200.\n    All expression fractions with `dot_max` are plotted with this size.\ndot_edge_color\n    Dot edge color. When `color_on='dot'` the default is no edge. When\n    `color_on='square'`, edge color is white for darker colors and black\n    for lighter background square colors.\ndot_edge_lw\n    Dot edge line width. When `color_on='dot'` the default is no edge. When\n    `color_on='square'`, line width = 1.5.\nsize_exponent\n    Dot size is computed as:\n    fraction  ** size exponent and afterwards scaled to match the\n    `smallest_dot` and `largest_dot` size parameters.\n    Using a different size exponent changes the relative sizes of the dots\n    to each other.\ngrid\n    Set to true to show grid lines. By default grid lines are not shown.\n    Further configuration of the grid lines can be achieved directly on the\n    returned ax.\nx_padding\n    Space between the plot left/right borders and the dots center. A unit\n    is the distance between the x ticks. Only applied when color_on = dot\ny_padding\n    Space between the plot top/bottom borders and the dots center. A unit is\n    the distance between the y ticks. Only applied when color_on = dot\n\nReturns\n-------\n:class:`~scanpy.pl.DotPlot`\n\nExamples\n-------\n\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n\nChange color map and apply it to the square behind the dot\n\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels')        ...               .style(cmap='RdBu_r', color_on='square').show()\n\nAdd edge to dots and plot a grid\n\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels')        ...               .style(dot_edge_color='black', dot_edge_lw=1, grid=True)        ...               .show()",
        "description": "Modifies plot visual parameters",
        "example": "Examples\n-------\n\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n\nChange color map and apply it to the square behind the dot\n\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels')        ...               .style(cmap='RdBu_r', color_on='square').show()\n\nAdd edge to dots and plot a grid\n\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels')        ...               .style(dot_edge_color='black', dot_edge_lw=1, grid=True)        ...               .show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.DotPlot.style(cmap=@, color_on=$, dot_max=@, dot_min=@, smallest_dot=@, largest_dot=@, dot_edge_color=@, dot_edge_lw=@, size_exponent=@, grid=@, x_padding=@, y_padding=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot.make_figure": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Renders the image but does not call :func:`matplotlib.pyplot.show`. Useful\nwhen several plots are put together into one figure.\n\nSee also\n--------\n`show()`: Renders and shows the plot.\n`savefig()`: Saves the plot.\n\nExamples\n--------\n\n>>> import matplotlib.pyplot as plt\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> fig, (ax0, ax1) = plt.subplots(1, 2)\n>>> sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels', ax=ax0)        ...               .style(cmap='Blues', edge_color='none').make_figure()\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels', ax=ax1).make_figure()",
        "description": "Renders the image but does not call :func:`matplotlib.pyplot.show`. Usefulwhen several plots are put together into one figure.\n\nSee also\n--------\n`show()`: Renders and shows the plot.\n`savefig()`: Saves the plot.",
        "example": "Examples\n--------\n\n>>> import matplotlib.pyplot as plt\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> fig, (ax0, ax1) = plt.subplots(1, 2)\n>>> sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels', ax=ax0)        ...               .style(cmap='Blues', edge_color='none').make_figure()\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels', ax=ax1).make_figure()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.MatrixPlot.make_figure()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.set_figure_params": {
        "Parameters": {
            "scanpy": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Init default values for :obj:`matplotlib.rcParams` suited for Scanpy.",
                "optional_value": false
            },
            "dpi": {
                "type": "int",
                "default": "80",
                "optional": true,
                "description": "Resolution of rendered figures \u2013 this influences the size of figures in notebooks.",
                "optional_value": false
            },
            "dpi_save": {
                "type": "int",
                "default": "150",
                "optional": true,
                "description": "Resolution of saved figures. This should typically be higher to achieve\npublication quality.",
                "optional_value": false
            },
            "frameon": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Add frames and axes labels to scatter plots.",
                "optional_value": false
            },
            "vector_friendly": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Plot scatter plots using `png` backend even when exporting as `pdf` or `svg`.",
                "optional_value": false
            },
            "fontsize": {
                "type": "int",
                "default": "14",
                "optional": true,
                "description": "Set the fontsize for several `rcParams` entries. Ignored if `scanpy=False`.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Set plt.rcParams['figure.figsize'].",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Convenience method for setting the default color map. Ignored if `scanpy=False`.",
                "optional_value": false
            },
            "format": {
                "type": "Literal[png, jpg, tif, tiff, pdf, ps, eps, svg, svgz, pgf, raw, rgba]",
                "default": "pdf",
                "optional": true,
                "description": "This sets the default format for saving figures: `file_format_figs`.",
                "optional_value": true
            },
            "facecolor": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Sets backgrounds via `rcParams['figure.facecolor'] = facecolor` and\n`rcParams['axes.facecolor'] = facecolor`.",
                "optional_value": false
            },
            "transparent": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Save figures with transparent back ground. Sets\n`rcParams['savefig.transparent']`.",
                "optional_value": false
            },
            "ipython_format": {
                "type": "str",
                "default": "png2x",
                "optional": true,
                "description": "Only concerns the notebook/IPython environment; see\n:func:`~IPython.display.set_matplotlib_formats` for details.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Set resolution/size, styling and format of figures.\n\nParameters\n----------\nscanpy\n    Init default values for :obj:`matplotlib.rcParams` suited for Scanpy.\ndpi\n    Resolution of rendered figures \u2013 this influences the size of figures in notebooks.\ndpi_save\n    Resolution of saved figures. This should typically be higher to achieve\n    publication quality.\nframeon\n    Add frames and axes labels to scatter plots.\nvector_friendly\n    Plot scatter plots using `png` backend even when exporting as `pdf` or `svg`.\nfontsize\n    Set the fontsize for several `rcParams` entries. Ignored if `scanpy=False`.\nfigsize\n    Set plt.rcParams['figure.figsize'].\ncolor_map\n    Convenience method for setting the default color map. Ignored if `scanpy=False`.\nformat\n    This sets the default format for saving figures: `file_format_figs`.\nfacecolor\n    Sets backgrounds via `rcParams['figure.facecolor'] = facecolor` and\n    `rcParams['axes.facecolor'] = facecolor`.\ntransparent\n    Save figures with transparent back ground. Sets\n    `rcParams['savefig.transparent']`.\nipython_format\n    Only concerns the notebook/IPython environment; see\n    :func:`~IPython.display.set_matplotlib_formats` for details.",
        "description": "Set resolution/size, styling and format of figures.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "scanpy.set_figure_params(scanpy=@, dpi=@, dpi_save=@, frameon=@, vector_friendly=@, fontsize=@, figsize=@, color_map=@, format=$, facecolor=@, transparent=@, ipython_format=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read": {
        "Parameters": {
            "filename": {
                "type": "Union[Path, str]",
                "default": null,
                "optional": false,
                "description": "If the filename has no file extension, it is interpreted as a key for\ngenerating a filename via ``sc.settings.writedir / (filename +\nsc.settings.file_format_data)``.  This is the same behavior as in\n``sc.read(filename, ...)``.",
                "optional_value": false
            },
            "backed": {
                "type": "Optional[Literal[r, r+]]",
                "default": "None",
                "optional": true,
                "description": "If ``'r'``, load :class:`~anndata.AnnData` in ``backed`` mode instead\nof fully loading it into memory (`memory` mode). If you want to modify\nbacked attributes of the AnnData object, you need to choose ``'r+'``.",
                "optional_value": true
            },
            "sheet": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of sheet/table in hdf5 or Excel file.",
                "optional_value": false
            },
            "ext": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Extension that indicates the file type. If ``None``, uses extension of\nfilename.",
                "optional_value": false
            },
            "delimiter": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Delimiter that separates data within text file. If ``None``, will split at\narbitrary number of white spaces, which is different from enforcing\nsplitting at any single white space ``' '``.",
                "optional_value": false
            },
            "first_column_names": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Assume the first column stores row names. This is only necessary if\nthese are not strings: strings in the first column are automatically\nassumed to be row names.",
                "optional_value": false
            },
            "backup_url": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Retrieve the file from an URL if not present on disk.",
                "optional_value": false
            },
            "cache": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `False`, read from source, if `True`, read from fast 'h5ad' cache.",
                "optional_value": false
            },
            "cache_compression": {
                "type": "Optional[Union[Literal[gzip, lzf], Empty]]",
                "default": "Empty.token",
                "optional": true,
                "description": "See the h5py :ref:`dataset_compression`.\n(Default: `settings.cache_compression`)",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "An :class:`~anndata.AnnData` object"
        },
        "Docstring": "Read file and return :class:`~anndata.AnnData` object.\n\nTo speed up reading, consider passing ``cache=True``, which creates an hdf5\ncache file.\n\nParameters\n----------\nfilename\n    If the filename has no file extension, it is interpreted as a key for\n    generating a filename via ``sc.settings.writedir / (filename +\n    sc.settings.file_format_data)``.  This is the same behavior as in\n    ``sc.read(filename, ...)``.\nbacked\n    If ``'r'``, load :class:`~anndata.AnnData` in ``backed`` mode instead\n    of fully loading it into memory (`memory` mode). If you want to modify\n    backed attributes of the AnnData object, you need to choose ``'r+'``.\nsheet\n    Name of sheet/table in hdf5 or Excel file.\next\n    Extension that indicates the file type. If ``None``, uses extension of\n    filename.\ndelimiter\n    Delimiter that separates data within text file. If ``None``, will split at\n    arbitrary number of white spaces, which is different from enforcing\n    splitting at any single white space ``' '``.\nfirst_column_names\n    Assume the first column stores row names. This is only necessary if\n    these are not strings: strings in the first column are automatically\n    assumed to be row names.\nbackup_url\n    Retrieve the file from an URL if not present on disk.\ncache\n    If `False`, read from source, if `True`, read from fast 'h5ad' cache.\ncache_compression\n    See the h5py :ref:`dataset_compression`.\n    (Default: `settings.cache_compression`)\nkwargs\n    Parameters passed to :func:`~anndata.read_loom`.\n\nReturns\n-------\nAn :class:`~anndata.AnnData` object",
        "description": "Read file and return :class:`~anndata.AnnData` object.To speed up reading, consider passing ``cache=True``, which creates an hdf5\ncache file.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read(filename=@, backed=$, sheet=@, ext=@, delimiter=@, first_column_names=@, backup_url=@, cache=@, cache_compression=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.scatter": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "x": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "x coordinate.",
                "optional_value": false
            },
            "y": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "y coordinate.",
                "optional_value": false
            },
            "color": {
                "type": "Union[str, Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes,\nor a hex color specification, e.g.,\n`'ann1'`, `'#fe57a1'`, or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.",
                "optional_value": false
            },
            "layers": {
                "type": "Union[str, Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "Use the `layers` attribute of `adata` if present: specify the layer for\n`x`, `y` and `color`. If `layers` is a string, then it is expanded to\n`(layers, layers, layers)`.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "alpha": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "basis": {
                "type": "Optional[Literal[pca, tsne, umap, diffmap, draw_graph_fr]]",
                "default": "None",
                "optional": true,
                "description": "String that denotes a plotting tool that computed coordinates.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Optional[Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]]",
                "default": "None",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "float",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "color_map": {
                "type": "Union[str, Colormap]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "palette": {
                "type": "Union[Cycler, ListedColormap, str, tuple[float, Ellipsis], Sequence[Union[str, tuple[float, Ellipsis]]]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "right_margin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "left_margin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[int, float]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot along observations or variables axes.\n\nColor the plot using annotations of observations (`.obs`), variables\n(`.var`) or expression of genes (`.var_names`).\n\nParameters\n----------\nadata\n    Annotated data matrix.\nx\n    x coordinate.\ny\n    y coordinate.\ncolor\n    Keys for annotations of observations/cells or variables/genes,\n    or a hex color specification, e.g.,\n    `'ann1'`, `'#fe57a1'`, or `['ann1', 'ann2']`.\nuse_raw\n    Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\nlayers\n    Use the `layers` attribute of `adata` if present: specify the layer for\n    `x`, `y` and `color`. If `layers` is a string, then it is expanded to\n    `(layers, layers, layers)`.\nbasis\n    String that denotes a plotting tool that computed coordinates.\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.",
        "description": "Scatter plot along observations or variables axes.Color the plot using annotations of observations (`.obs`), variables\n(`.var`) or expression of genes (`.var_names`).",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.scatter(adata=$, x=@, y=@, color=@, use_raw=@, layers=@, sort_order=@, alpha=@, basis=$, groups=@, components=@, projection=$, legend_loc=@, legend_fontsize=@, legend_fontweight=@, legend_fontoutline=@, color_map=@, palette=@, frameon=@, right_margin=@, left_margin=@, size=@, marker=@, title=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.pca": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Union[str, tuple[float, Ellipsis]]",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "annotate_var_explained": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": null,
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, List[Axes]]]",
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot in PCA coordinates.\n\nUse the parameter `annotate_var_explained` to annotate the explained variance.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nannotate_var_explained\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc3k_processed()\n    sc.pl.pca(adata)\n\nColour points by discrete variable (Louvain clusters).\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.pca(adata, color=\"louvain\")\n\nColour points by gene expression.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.pca(adata, color=\"CST3\")\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.pca\npp.pca",
        "description": "Scatter plot in PCA coordinates.Use the parameter `annotate_var_explained` to annotate the explained variance.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc3k_processed()\n    sc.pl.pca(adata)\n\nColour points by discrete variable (Louvain clusters).\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.pca(adata, color=\"louvain\")\n\nColour points by gene expression.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.pca(adata, color=\"CST3\")\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.pca\npp.pca",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.pca(adata=$, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@, annotate_var_explained=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.palantir": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An AnnData object.",
                "optional_value": true
            },
            "n_components": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "Number of diffusion components.",
                "optional_value": false
            },
            "knn": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of nearest neighbors for graph construction.",
                "optional_value": false
            },
            "alpha": {
                "type": "float",
                "default": "0",
                "optional": true,
                "description": "Normalization parameter for the diffusion operator.",
                "optional_value": false
            },
            "use_adjacency_matrix": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Use adaptive anisotropic adjacency matrix, instead of PCA projections\n(default) to compute diffusion components.",
                "optional_value": false
            },
            "distances_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "With `use_adjacency_matrix=True`, use the indicated distances key for `.obsp`.\nIf `None`, `'distances'`.",
                "optional_value": false
            },
            "n_eigs": {
                "type": "int",
                "default": "None",
                "optional": true,
                "description": "Number of eigen vectors to use. If `None` specified, the number of eigen\nvectors will be determined using eigen gap. Passed to\n`palantir.utils.determine_multiscale_space`.",
                "optional_value": false
            },
            "impute_data": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Impute data using MAGIC.",
                "optional_value": false
            },
            "n_steps": {
                "type": "int",
                "default": "3",
                "optional": true,
                "description": "Number of steps in the diffusion operator. Passed to\n`palantir.utils.run_magic_imputation`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to `adata`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `adata` with the following fields:\n**Diffusion maps**,\nused for magic imputation, and to generate multi-scale data matrix,\n- X_palantir_diff_comp - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.obsm`, dtype `float`)\nArray of Diffusion components.\n- palantir_EigenValues - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.uns`, dtype `float`)\nArray of corresponding eigen values.\n- palantir_diff_op - :class:`~scipy.sparse.spmatrix` (:attr:`~anndata.AnnData.obsp`, dtype `float`)\nThe diffusion operator matrix.\n**Multi scale space results**,\nused to build tsne on diffusion components, and to compute branch probabilities\nand waypoints,\n- X_palantir_multiscale - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.obsm`, dtype `float`)\nMulti scale data matrix.\n**MAGIC imputation**,\nused for plotting gene expression on tsne, and gene expression trends,\n- palantir_imp - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.layers`, dtype `float`)\nImputed data matrix (MAGIC imputation)."
        },
        "Docstring": "Run Diffusion maps using the adaptive anisotropic kernel [Setty18]_.\n\nPalantir is an algorithm to align cells along differentiation trajectories.\nPalantir models differentiation as a stochastic process where stem cells\ndifferentiate to terminally differentiated cells by a series of steps through\na low dimensional phenotypic manifold. Palantir effectively captures the\ncontinuity in cell states and the stochasticity in cell fate determination.\nPalantir has been designed to work with multidimensional single cell data\nfrom diverse technologies such as Mass cytometry and single cell RNA-seq.\n\n.. note::\n   More information and bug reports `here <https://github.com/dpeerlab/Palantir>`__.\n\nParameters\n----------\nadata\n    An AnnData object.\nn_components\n    Number of diffusion components.\nknn\n    Number of nearest neighbors for graph construction.\nalpha\n    Normalization parameter for the diffusion operator.\nuse_adjacency_matrix\n    Use adaptive anisotropic adjacency matrix, instead of PCA projections\n    (default) to compute diffusion components.\ndistances_key\n    With `use_adjacency_matrix=True`, use the indicated distances key for `.obsp`.\n    If `None`, `'distances'`.\nn_eigs\n    Number of eigen vectors to use. If `None` specified, the number of eigen\n    vectors will be determined using eigen gap. Passed to\n    `palantir.utils.determine_multiscale_space`.\nimpute_data\n    Impute data using MAGIC.\nn_steps\n    Number of steps in the diffusion operator. Passed to\n    `palantir.utils.run_magic_imputation`.\ncopy\n    Return a copy instead of writing to `adata`.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields:\n\n**Diffusion maps**,\n    used for magic imputation, and to generate multi-scale data matrix,\n\n    - X_palantir_diff_comp - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.obsm`, dtype `float`)\n        Array of Diffusion components.\n    - palantir_EigenValues - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.uns`, dtype `float`)\n        Array of corresponding eigen values.\n    - palantir_diff_op - :class:`~scipy.sparse.spmatrix` (:attr:`~anndata.AnnData.obsp`, dtype `float`)\n        The diffusion operator matrix.\n\n**Multi scale space results**,\n    used to build tsne on diffusion components, and to compute branch probabilities\n    and waypoints,\n\n    - X_palantir_multiscale - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.obsm`, dtype `float`)\n        Multi scale data matrix.\n\n**MAGIC imputation**,\n    used for plotting gene expression on tsne, and gene expression trends,\n\n    - palantir_imp - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.layers`, dtype `float`)\n        Imputed data matrix (MAGIC imputation).\n\nExample\n-------\n>>> import scanpy.external as sce\n>>> import scanpy as sc\n\nA sample data is available `here <https://github.com/dpeerlab/Palantir/tree/master/data>`_.\n\n**Load sample data**\n\n>>> adata = sc.read_csv(filename=\"Palantir/data/marrow_sample_scseq_counts.csv.gz\")\n\n*Cleanup and normalize*\n\n>>> sc.pp.filter_cells(adata, min_counts=1000)\n>>> sc.pp.filter_genes(adata, min_counts=10)\n>>> sc.pp.normalize_per_cell(adata)\n>>> sc.pp.log1p(adata)\n\n**Data preprocessing**\n\nPalantir builds diffusion maps using one of two optional inputs:\n\n*Principal component analysis*\n\n>>> sc.tl.pca(adata, n_comps=300)\n\nor,\n\n*Nearist neighbors graph*\n\n>>> sc.pp.neighbors(adata, knn=30)\n\n*Diffusion maps*\n\nPalantir determines the diffusion maps of the data as an estimate of the low\ndimensional phenotypic manifold of the data.\n\n>>> sce.tl.palantir(adata, n_components=5, knn=30)\n\nif pre-computed distances are to be used,\n\n>>> sce.tl.palantir(\n...     adata,\n...     n_components=5,\n...     knn=30,\n...     use_adjacency_matrix=True,\n...     distances_key=\"distances\",\n... )\n\n**Visualizing Palantir results**\n\n*tSNE visualization*\n\nimportant for Palantir!\n\nPalantir constructs the tSNE map in the embedded space since these maps better\nrepresent the differentiation trajectories.\n\n>>> sc.tl.tsne(adata, n_pcs=2, use_rep='X_palantir_multiscale', perplexity=150)\n\n*tsne by cell size*\n\n>>> sc.pl.tsne(adata, color=\"n_counts\")\n\n*Imputed gene expression visualized on tSNE maps*\n\n>>> sc.pl.tsne(\n...     adata,\n...     gene_symbols=['CD34', 'MPO', 'GATA1', 'IRF8'],\n...     layer='palantir_imp',\n...     color=['CD34', 'MPO', 'GATA1', 'IRF8']\n... )\n\n**Running Palantir**\n\nPalantir can be run by specifying an approximate early cell. While Palantir\nautomatically determines the terminal states, they can also be specified using the\n`termine_states` parameter.\n\n>>> start_cell = 'Run5_164698952452459'\n>>> pr_res = sce.tl.palantir_results(\n...     adata,\n...     early_cell=start_cell,\n...     ms_data='X_palantir_multiscale',\n...     num_waypoints=500,\n... )\n\n.. note::\n   A `start_cell` must be defined for every data set. The start cell for\n   this dataset was chosen based on high expression of CD34.\n\nAt this point the returned Palantir object `pr_res` can be used for all downstream\nanalysis and plotting. Please consult this notebook\n`Palantir_sample_notebook.ipynb\n<https://github.com/dpeerlab/Palantir/blob/master/notebooks/Palantir_sample_notebook.ipynb>`_.\nIt provides a comprehensive guide to draw *gene expression trends*, amongst other\nthings.",
        "description": "Run Diffusion maps using the adaptive anisotropic kernel [Setty18]_.Palantir is an algorithm to align cells along differentiation trajectories.\nPalantir models differentiation as a stochastic process where stem cells\ndifferentiate to terminally differentiated cells by a series of steps through\na low dimensional phenotypic manifold. Palantir effectively captures the\ncontinuity in cell states and the stochasticity in cell fate determination.\nPalantir has been designed to work with multidimensional single cell data\nfrom diverse technologies such as Mass cytometry and single cell RNA-seq.\n\n.. note::\n   More information and bug reports `here <https://github.com/dpeerlab/Palantir>`__.",
        "example": "Example\n-------\n>>> import scanpy.external as sce\n>>> import scanpy as sc\n\nA sample data is available `here <https://github.com/dpeerlab/Palantir/tree/master/data>`_.\n\n**Load sample data**\n\n>>> adata = sc.read_csv(filename=\"Palantir/data/marrow_sample_scseq_counts.csv.gz\")\n\n*Cleanup and normalize*\n\n>>> sc.pp.filter_cells(adata, min_counts=1000)\n>>> sc.pp.filter_genes(adata, min_counts=10)\n>>> sc.pp.normalize_per_cell(adata)\n>>> sc.pp.log1p(adata)\n\n**Data preprocessing**\n\nPalantir builds diffusion maps using one of two optional inputs:\n\n*Principal component analysis*\n\n>>> sc.tl.pca(adata, n_comps=300)\n\nor,\n\n*Nearist neighbors graph*\n\n>>> sc.pp.neighbors(adata, knn=30)\n\n*Diffusion maps*\n\nPalantir determines the diffusion maps of the data as an estimate of the low\ndimensional phenotypic manifold of the data.\n\n>>> sce.tl.palantir(adata, n_components=5, knn=30)\n\nif pre-computed distances are to be used,\n\n>>> sce.tl.palantir(\n...     adata,\n...     n_components=5,\n...     knn=30,\n...     use_adjacency_matrix=True,\n...     distances_key=\"distances\",\n... )\n\n**Visualizing Palantir results**\n\n*tSNE visualization*\n\nimportant for Palantir!\n\nPalantir constructs the tSNE map in the embedded space since these maps better\nrepresent the differentiation trajectories.\n\n>>> sc.tl.tsne(adata, n_pcs=2, use_rep='X_palantir_multiscale', perplexity=150)\n\n*tsne by cell size*\n\n>>> sc.pl.tsne(adata, color=\"n_counts\")\n\n*Imputed gene expression visualized on tSNE maps*\n\n>>> sc.pl.tsne(\n...     adata,\n...     gene_symbols=['CD34', 'MPO', 'GATA1', 'IRF8'],\n...     layer='palantir_imp',\n...     color=['CD34', 'MPO', 'GATA1', 'IRF8']\n... )\n\n**Running Palantir**\n\nPalantir can be run by specifying an approximate early cell. While Palantir\nautomatically determines the terminal states, they can also be specified using the\n`termine_states` parameter.\n\n>>> start_cell = 'Run5_164698952452459'\n>>> pr_res = sce.tl.palantir_results(\n...     adata,\n...     early_cell=start_cell,\n...     ms_data='X_palantir_multiscale',\n...     num_waypoints=500,\n... )\n\n.. note::\n   A `start_cell` must be defined for every data set. The start cell for\n   this dataset was chosen based on high expression of CD34.\n\nAt this point the returned Palantir object `pr_res` can be used for all downstream\nanalysis and plotting. Please consult this notebook\n`Palantir_sample_notebook.ipynb\n<https://github.com/dpeerlab/Palantir/blob/master/notebooks/Palantir_sample_notebook.ipynb>`_.\nIt provides a comprehensive guide to draw *gene expression trends*, amongst other\nthings.",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.palantir(adata=$, n_components=@, knn=@, alpha=@, use_adjacency_matrix=@, distances_key=@, n_eigs=@, impute_data=@, n_steps=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.dpt": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "n_dcs": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "The number of diffusion components to use.",
                "optional_value": false
            },
            "n_branchings": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Number of branchings to detect.",
                "optional_value": false
            },
            "min_group_size": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "During recursive splitting of branches ('dpt groups') for `n_branchings`\n> 1, do not consider groups that contain less than `min_group_size` data\npoints. If a float, `min_group_size` refers to a fraction of the total\nnumber of data points.",
                "optional_value": false
            },
            "allow_kendall_tau_shift": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If a very small branch is detected upon splitting, shift away from\nmaximum correlation in Kendall tau criterion of [Haghverdi16]_ to\nstabilize the splitting.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, dpt looks .uns['neighbors'] for neighbors settings\nand .obsp['connectivities'], .obsp['distances'] for connectivities and\ndistances respectively (default storage places for pp.neighbors).\nIf specified, dpt looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key]['connectivities_key']],\n.obsp[.uns[neighbors_key]['distances_key']] for connectivities and distances\nrespectively.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Copy instance before computation and return a copy.\nOtherwise, perform computation inplace and return `None`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `adata` with the following fields.\nIf `n_branchings==0`, no field `dpt_groups` will be written.\n`dpt_pseudotime` : :class:`pandas.Series` (`adata.obs`, dtype `float`)\nArray of dim (number of samples) that stores the pseudotime of each\ncell, that is, the DPT distance with respect to the root cell.\n`dpt_groups` : :class:`pandas.Series` (`adata.obs`, dtype `category`)\nArray of dim (number of samples) that stores the subgroup id ('0',\n'1', ...) for each cell. The groups  typically correspond to\n'progenitor cells', 'undecided cells' or 'branches' of a process.\nNotes\nThe tool is similar to the R package `destiny` of [Angerer16]_."
        },
        "Docstring": "Infer progression of cells through geodesic distance along the graph\n[Haghverdi16]_ [Wolf19]_.\n\nReconstruct the progression of a biological process from snapshot\ndata. `Diffusion Pseudotime` has been introduced by [Haghverdi16]_ and\nimplemented within Scanpy [Wolf18]_. Here, we use a further developed\nversion, which is able to deal with disconnected graphs [Wolf19]_ and can\nbe run in a `hierarchical` mode by setting the parameter\n`n_branchings>1`. We recommend, however, to only use\n:func:`~scanpy.tl.dpt` for computing pseudotime (`n_branchings=0`) and\nto detect branchings via :func:`~scanpy.tl.paga`. For pseudotime, you need\nto annotate your data with a root cell. For instance::\n\n    adata.uns['iroot'] = np.flatnonzero(adata.obs['cell_types'] == 'Stem')[0]\n\nThis requires to run :func:`~scanpy.pp.neighbors`, first. In order to\nreproduce the original implementation of DPT, use `method=='gauss'` in\nthis. Using the default `method=='umap'` only leads to minor quantitative\ndifferences, though.\n\n.. versionadded:: 1.1\n\n:func:`~scanpy.tl.dpt` also requires to run\n:func:`~scanpy.tl.diffmap` first. As previously,\n:func:`~scanpy.tl.dpt` came with a default parameter of ``n_dcs=10`` but\n:func:`~scanpy.tl.diffmap` has a default parameter of ``n_comps=15``,\nyou need to pass ``n_comps=10`` in :func:`~scanpy.tl.diffmap` in order\nto exactly reproduce previous :func:`~scanpy.tl.dpt` results.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nn_dcs\n    The number of diffusion components to use.\nn_branchings\n    Number of branchings to detect.\nmin_group_size\n    During recursive splitting of branches ('dpt groups') for `n_branchings`\n    > 1, do not consider groups that contain less than `min_group_size` data\n    points. If a float, `min_group_size` refers to a fraction of the total\n    number of data points.\nallow_kendall_tau_shift\n    If a very small branch is detected upon splitting, shift away from\n    maximum correlation in Kendall tau criterion of [Haghverdi16]_ to\n    stabilize the splitting.\nneighbors_key\n    If not specified, dpt looks .uns['neighbors'] for neighbors settings\n    and .obsp['connectivities'], .obsp['distances'] for connectivities and\n    distances respectively (default storage places for pp.neighbors).\n    If specified, dpt looks .uns[neighbors_key] for neighbors settings and\n    .obsp[.uns[neighbors_key]['connectivities_key']],\n    .obsp[.uns[neighbors_key]['distances_key']] for connectivities and distances\n    respectively.\ncopy\n    Copy instance before computation and return a copy.\n    Otherwise, perform computation inplace and return `None`.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields.\n\nIf `n_branchings==0`, no field `dpt_groups` will be written.\n\n`dpt_pseudotime` : :class:`pandas.Series` (`adata.obs`, dtype `float`)\n    Array of dim (number of samples) that stores the pseudotime of each\n    cell, that is, the DPT distance with respect to the root cell.\n`dpt_groups` : :class:`pandas.Series` (`adata.obs`, dtype `category`)\n    Array of dim (number of samples) that stores the subgroup id ('0',\n    '1', ...) for each cell. The groups  typically correspond to\n    'progenitor cells', 'undecided cells' or 'branches' of a process.\n\nNotes\n-----\nThe tool is similar to the R package `destiny` of [Angerer16]_.",
        "description": "Infer progression of cells through geodesic distance along the graph[Haghverdi16]_ [Wolf19]_.\n\nReconstruct the progression of a biological process from snapshot\ndata. `Diffusion Pseudotime` has been introduced by [Haghverdi16]_ and\nimplemented within Scanpy [Wolf18]_. Here, we use a further developed\nversion, which is able to deal with disconnected graphs [Wolf19]_ and can\nbe run in a `hierarchical` mode by setting the parameter\n`n_branchings>1`. We recommend, however, to only use\n:func:`~scanpy.tl.dpt` for computing pseudotime (`n_branchings=0`) and\nto detect branchings via :func:`~scanpy.tl.paga`. For pseudotime, you need\nto annotate your data with a root cell. For instance::\n\n    adata.uns['iroot'] = np.flatnonzero(adata.obs['cell_types'] == 'Stem')[0]\n\nThis requires to run :func:`~scanpy.pp.neighbors`, first. In order to\nreproduce the original implementation of DPT, use `method=='gauss'` in\nthis. Using the default `method=='umap'` only leads to minor quantitative\ndifferences, though.\n\n.. versionadded:: 1.1\n\n:func:`~scanpy.tl.dpt` also requires to run\n:func:`~scanpy.tl.diffmap` first. As previously,\n:func:`~scanpy.tl.dpt` came with a default parameter of ``n_dcs=10`` but\n:func:`~scanpy.tl.diffmap` has a default parameter of ``n_comps=15``,\nyou need to pass ``n_comps=10`` in :func:`~scanpy.tl.diffmap` in order\nto exactly reproduce previous :func:`~scanpy.tl.dpt` results.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.dpt(adata=$, n_dcs=@, n_branchings=@, min_group_size=@, allow_kendall_tau_shift=@, neighbors_key=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin.make_figure": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Renders the image but does not call :func:`matplotlib.pyplot.show`. Useful\nwhen several plots are put together into one figure.\n\nSee also\n--------\n`show()`: Renders and shows the plot.\n`savefig()`: Saves the plot.\n\nExamples\n--------\n\n>>> import matplotlib.pyplot as plt\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> fig, (ax0, ax1) = plt.subplots(1, 2)\n>>> sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels', ax=ax0)        ...               .style(cmap='Blues', edge_color='none').make_figure()\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels', ax=ax1).make_figure()",
        "description": "Renders the image but does not call :func:`matplotlib.pyplot.show`. Usefulwhen several plots are put together into one figure.\n\nSee also\n--------\n`show()`: Renders and shows the plot.\n`savefig()`: Saves the plot.",
        "example": "Examples\n--------\n\n>>> import matplotlib.pyplot as plt\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> fig, (ax0, ax1) = plt.subplots(1, 2)\n>>> sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels', ax=ax0)        ...               .style(cmap='Blues', edge_color='none').make_figure()\n>>> sc.pl.DotPlot(adata, markers, groupby='bulk_labels', ax=ax1).make_figure()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.StackedViolin.make_figure()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.recipe_zheng17": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "n_top_genes": {
                "type": "int",
                "default": "1000",
                "optional": true,
                "description": "Number of genes to keep.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Take logarithm.",
                "optional_value": false
            },
            "plot": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show a plot of the gene dispersion vs. mean relation.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy of `adata` instead of updating it.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Returns or updates `adata` depending on `copy`."
        },
        "Docstring": "Normalization and filtering as of [Zheng17]_.\n\nReproduces the preprocessing of [Zheng17]_ \u2013 the Cell Ranger R Kit of 10x\nGenomics.\n\nExpects non-logarithmized data.\nIf using logarithmized data, pass `log=False`.\n\nThe recipe runs the following steps\n\n.. code:: python\n\n    sc.pp.filter_genes(adata, min_counts=1)         # only consider genes with more than 1 count\n    sc.pp.normalize_per_cell(                       # normalize with total UMI count per cell\n         adata, key_n_counts='n_counts_all'\n    )\n    filter_result = sc.pp.filter_genes_dispersion(  # select highly-variable genes\n        adata.X, flavor='cell_ranger', n_top_genes=n_top_genes, log=False\n    )\n    adata = adata[:, filter_result.gene_subset]     # subset the genes\n    sc.pp.normalize_per_cell(adata)                 # renormalize after filtering\n    if log: sc.pp.log1p(adata)                      # log transform: adata.X = log(adata.X + 1)\n    sc.pp.scale(adata)                              # scale to unit variance and shift to zero mean\n\n\nParameters\n----------\nadata\n    Annotated data matrix.\nn_top_genes\n    Number of genes to keep.\nlog\n    Take logarithm.\nplot\n    Show a plot of the gene dispersion vs. mean relation.\ncopy\n    Return a copy of `adata` instead of updating it.\n\nReturns\n-------\nReturns or updates `adata` depending on `copy`.",
        "description": "Normalization and filtering as of [Zheng17]_.Reproduces the preprocessing of [Zheng17]_ \u2013 the Cell Ranger R Kit of 10x\nGenomics.\n\nExpects non-logarithmized data.\nIf using logarithmized data, pass `log=False`.\n\nThe recipe runs the following steps\n\n.. code:: python\n\n    sc.pp.filter_genes(adata, min_counts=1)         # only consider genes with more than 1 count\n    sc.pp.normalize_per_cell(                       # normalize with total UMI count per cell\n         adata, key_n_counts='n_counts_all'\n    )\n    filter_result = sc.pp.filter_genes_dispersion(  # select highly-variable genes\n        adata.X, flavor='cell_ranger', n_top_genes=n_top_genes, log=False\n    )\n    adata = adata[:, filter_result.gene_subset]     # subset the genes\n    sc.pp.normalize_per_cell(adata)                 # renormalize after filtering\n    if log: sc.pp.log1p(adata)                      # log transform: adata.X = log(adata.X + 1)\n    sc.pp.scale(adata)                              # scale to unit variance and shift to zero mean",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.recipe_zheng17(adata=$, n_top_genes=@, log=@, plot=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.filter_rank_genes_groups": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": null,
                "optional_value": true
            },
            "key": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": true
            },
            "groupby": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": true
            },
            "use_raw": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": true
            },
            "key_added": {
                "type": null,
                "default": "rank_genes_groups_filtered",
                "optional": true,
                "description": null,
                "optional_value": true
            },
            "min_in_group_fraction": {
                "type": null,
                "default": "0.25",
                "optional": true,
                "description": null,
                "optional_value": true
            },
            "min_fold_change": {
                "type": null,
                "default": "1",
                "optional": true,
                "description": null,
                "optional_value": true
            },
            "max_out_group_fraction": {
                "type": null,
                "default": "0.5",
                "optional": true,
                "description": null,
                "optional_value": true
            },
            "compare_abs": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "If `True`, compare absolute values of log fold change with `min_fold_change`.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Same output as :func:`scanpy.tl.rank_genes_groups` but with filtered genes names set to",
            "description": "`nan`"
        },
        "Docstring": "Filters out genes based on log fold change and fraction of genes expressing the\ngene within and outside the `groupby` categories.\n\nSee :func:`~scanpy.tl.rank_genes_groups`.\n\nResults are stored in `adata.uns[key_added]`\n(default: 'rank_genes_groups_filtered').\n\nTo preserve the original structure of adata.uns['rank_genes_groups'],\nfiltered genes are set to `NaN`.\n\nParameters\n----------\nadata\nkey\ngroupby\nuse_raw\nkey_added\nmin_in_group_fraction\nmin_fold_change\nmax_out_group_fraction\ncompare_abs\n    If `True`, compare absolute values of log fold change with `min_fold_change`.\n\nReturns\n-------\nSame output as :func:`scanpy.tl.rank_genes_groups` but with filtered genes names set to\n`nan`\n\nExamples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(adata, 'bulk_labels', method='wilcoxon')\n>>> sc.tl.filter_rank_genes_groups(adata, min_fold_change=3)\n>>> # visualize results\n>>> sc.pl.rank_genes_groups(adata, key='rank_genes_groups_filtered')\n>>> # visualize results using dotplot\n>>> sc.pl.rank_genes_groups_dotplot(adata, key='rank_genes_groups_filtered')",
        "description": "Filters out genes based on log fold change and fraction of genes expressing thegene within and outside the `groupby` categories.\n\nSee :func:`~scanpy.tl.rank_genes_groups`.\n\nResults are stored in `adata.uns[key_added]`\n(default: 'rank_genes_groups_filtered').\n\nTo preserve the original structure of adata.uns['rank_genes_groups'],\nfiltered genes are set to `NaN`.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(adata, 'bulk_labels', method='wilcoxon')\n>>> sc.tl.filter_rank_genes_groups(adata, min_fold_change=3)\n>>> # visualize results\n>>> sc.pl.rank_genes_groups(adata, key='rank_genes_groups_filtered')\n>>> # visualize results using dotplot\n>>> sc.pl.rank_genes_groups_dotplot(adata, key='rank_genes_groups_filtered')",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.filter_rank_genes_groups(adata=$, key=$, groupby=$, use_raw=$, key_added=$, min_in_group_fraction=$, min_fold_change=$, max_out_group_fraction=$, compare_abs=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.combat": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix",
                "optional_value": true
            },
            "key": {
                "type": "str",
                "default": "batch",
                "optional": true,
                "description": "Key to a categorical annotation from :attr:`~anndata.AnnData.obs`\nthat will be used for batch effect removal.",
                "optional_value": false
            },
            "covariates": {
                "type": "Optional[Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "Additional covariates besides the batch variable such as adjustment\nvariables or biological condition. This parameter refers to the design\nmatrix `X` in Equation 2.1 in [Johnson07]_ and to the `mod` argument in\nthe original combat function in the sva R package.\nNote that not including covariates may introduce bias or lead to the\nremoval of biological signal in unbalanced designs.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to replace adata.X or to return the corrected data",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[AnnData, ndarray]]",
            "description": "Depending on the value of `inplace`, either returns the corrected matrix or\nor modifies `adata.X`."
        },
        "Docstring": "ComBat function for batch effect correction [Johnson07]_ [Leek12]_\n[Pedersen12]_.\n\nCorrects for batch effects by fitting linear models, gains statistical power\nvia an EB framework where information is borrowed across genes.\nThis uses the implementation `combat.py`_ [Pedersen12]_.\n\n.. _combat.py: https://github.com/brentp/combat.py\n\nParameters\n----------\nadata\n    Annotated data matrix\nkey\n    Key to a categorical annotation from :attr:`~anndata.AnnData.obs`\n    that will be used for batch effect removal.\ncovariates\n    Additional covariates besides the batch variable such as adjustment\n    variables or biological condition. This parameter refers to the design\n    matrix `X` in Equation 2.1 in [Johnson07]_ and to the `mod` argument in\n    the original combat function in the sva R package.\n    Note that not including covariates may introduce bias or lead to the\n    removal of biological signal in unbalanced designs.\ninplace\n    Whether to replace adata.X or to return the corrected data\n\nReturns\n-------\nDepending on the value of `inplace`, either returns the corrected matrix or\nor modifies `adata.X`.",
        "description": "ComBat function for batch effect correction [Johnson07]_ [Leek12]_[Pedersen12]_.\n\nCorrects for batch effects by fitting linear models, gains statistical power\nvia an EB framework where information is borrowed across genes.\nThis uses the implementation `combat.py`_ [Pedersen12]_.\n\n.. _combat.py: https://github.com/brentp/combat.py",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.combat(adata=$, key=@, covariates=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.pca_variance_ratio": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "n_pcs": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of PCs to show.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic scale..",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot the variance ratio.\n\nParameters\n----------\nn_pcs\n     Number of PCs to show.\nlog\n     Plot on logarithmic scale..\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
        "description": "Plot the variance ratio.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.pca_variance_ratio(adata=$, n_pcs=@, log=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.get.obs_df": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object to get values from.",
                "optional_value": true
            },
            "keys": {
                "type": "Iterable[str]",
                "default": "()",
                "optional": true,
                "description": "Keys from either `.var_names`, `.var[gene_symbols]`, or `.obs.columns`.",
                "optional_value": false
            },
            "obsm_keys": {
                "type": "Iterable[tuple[str, int]]",
                "default": "()",
                "optional": true,
                "description": "Tuple of `(key from obsm, column index of obsm[key])`.",
                "optional_value": false
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Layer of `adata` to use as expression values.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Column of `adata.var` to search for `keys` in.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to get expression values from `adata.raw`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": "A dataframe with `adata.obs_names` as index, and values specified by `keys`\nand `obsm_keys`."
        },
        "Docstring": "Return values for observations in adata.\n\nParams\n------\nadata\n    AnnData object to get values from.\nkeys\n    Keys from either `.var_names`, `.var[gene_symbols]`, or `.obs.columns`.\nobsm_keys\n    Tuple of `(key from obsm, column index of obsm[key])`.\nlayer\n    Layer of `adata` to use as expression values.\ngene_symbols\n    Column of `adata.var` to search for `keys` in.\nuse_raw\n    Whether to get expression values from `adata.raw`.\n\nReturns\n-------\nA dataframe with `adata.obs_names` as index, and values specified by `keys`\nand `obsm_keys`.\n\nExamples\n--------\nGetting value for plotting:\n\n>>> pbmc = sc.datasets.pbmc68k_reduced()\n>>> plotdf = sc.get.obs_df(\n        pbmc,\n        keys=[\"CD8B\", \"n_genes\"],\n        obsm_keys=[(\"X_umap\", 0), (\"X_umap\", 1)]\n    )\n>>> plotdf.plot.scatter(\"X_umap0\", \"X_umap1\", c=\"CD8B\")\n\nCalculating mean expression for marker genes by cluster:\n\n>>> pbmc = sc.datasets.pbmc68k_reduced()\n>>> marker_genes = ['CD79A', 'MS4A1', 'CD8A', 'CD8B', 'LYZ']\n>>> genedf = sc.get.obs_df(\n        pbmc,\n        keys=[\"louvain\", *marker_genes]\n    )\n>>> grouped = genedf.groupby(\"louvain\")\n>>> mean, var = grouped.mean(), grouped.var()",
        "description": "Return values for observations in adata.",
        "example": "Examples\n--------\nGetting value for plotting:\n\n>>> pbmc = sc.datasets.pbmc68k_reduced()\n>>> plotdf = sc.get.obs_df(\n        pbmc,\n        keys=[\"CD8B\", \"n_genes\"],\n        obsm_keys=[(\"X_umap\", 0), (\"X_umap\", 1)]\n    )\n>>> plotdf.plot.scatter(\"X_umap0\", \"X_umap1\", c=\"CD8B\")\n\nCalculating mean expression for marker genes by cluster:\n\n>>> pbmc = sc.datasets.pbmc68k_reduced()\n>>> marker_genes = ['CD79A', 'MS4A1', 'CD8A', 'CD8B', 'LYZ']\n>>> genedf = sc.get.obs_df(\n        pbmc,\n        keys=[\"louvain\", *marker_genes]\n    )\n>>> grouped = genedf.groupby(\"louvain\")\n>>> mean, var = grouped.mean(), grouped.var()",
        "api_type": "function",
        "api_calling": [
            "scanpy.get.obs_df(adata=$, keys=@, obsm_keys=@, layer=@, gene_symbols=@, use_raw=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.highly_variable_genes": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\nto cells and columns to genes.",
                "optional_value": true
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If provided, use `adata.layers[layer]` for expression values instead of `adata.X`.",
                "optional_value": false
            },
            "n_top_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of highly-variable genes to keep. Mandatory if `flavor='seurat_v3'`.",
                "optional_value": false
            },
            "min_disp": {
                "type": "Optional[float]",
                "default": "0.5",
                "optional": true,
                "description": "If `n_top_genes` unequals `None`, this and all other cutoffs for the means and the\nnormalized dispersions are ignored. Ignored if `flavor='seurat_v3'`.",
                "optional_value": false
            },
            "max_disp": {
                "type": "Optional[float]",
                "default": "inf",
                "optional": true,
                "description": "If `n_top_genes` unequals `None`, this and all other cutoffs for the means and the\nnormalized dispersions are ignored. Ignored if `flavor='seurat_v3'`.",
                "optional_value": false
            },
            "min_mean": {
                "type": "Optional[float]",
                "default": "0.0125",
                "optional": true,
                "description": "If `n_top_genes` unequals `None`, this and all other cutoffs for the means and the\nnormalized dispersions are ignored. Ignored if `flavor='seurat_v3'`.",
                "optional_value": false
            },
            "max_mean": {
                "type": "Optional[float]",
                "default": "3",
                "optional": true,
                "description": "If `n_top_genes` unequals `None`, this and all other cutoffs for the means and the\nnormalized dispersions are ignored. Ignored if `flavor='seurat_v3'`.",
                "optional_value": false
            },
            "span": {
                "type": "Optional[float]",
                "default": "0.3",
                "optional": true,
                "description": "The fraction of the data (cells) used when estimating the variance in the loess\nmodel fit if `flavor='seurat_v3'`.",
                "optional_value": false
            },
            "n_bins": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of bins for binning the mean gene expression. Normalization is\ndone with respect to each bin. If just a single gene falls into a bin,\nthe normalized dispersion is artificially set to 1. You'll be informed\nabout this if you set `settings.verbosity = 4`.",
                "optional_value": false
            },
            "flavor": {
                "type": "Literal[seurat, cell_ranger, seurat_v3]",
                "default": "seurat",
                "optional": true,
                "description": "Choose the flavor for identifying highly variable genes. For the dispersion\nbased methods in their default workflows, Seurat passes the cutoffs whereas\nCell Ranger passes `n_top_genes`.",
                "optional_value": true
            },
            "subset": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Inplace subset to highly-variable genes if `True` otherwise merely indicate\nhighly variable genes.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to place calculated metrics in `.var` or return them.",
                "optional_value": false
            },
            "batch_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If specified, highly-variable genes are selected within each batch separately and merged.\nThis simple process avoids the selection of batch-specific genes and acts as a\nlightweight batch correction method. For all flavors, genes are first sorted\nby how many batches they are a HVG. For dispersion-based flavors ties are broken\nby normalized dispersion. If `flavor = 'seurat_v3'`, ties are broken by the median\n(across batches) rank based on within-batch normalized variance.",
                "optional_value": false
            },
            "check_values": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Check if counts in selected layer are integers. A Warning is returned if set to True.\nOnly used if `flavor='seurat_v3'`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[DataFrame]",
            "description": "Depending on `inplace` returns calculated metrics (:class:`~pandas.DataFrame`) or\nupdates `.var` with the following fields\nhighly_variable : bool\nboolean indicator of highly-variable genes\n**means**\nmeans per gene\n**dispersions**\nFor dispersion-based flavors, dispersions per gene\n**dispersions_norm**\nFor dispersion-based flavors, normalized dispersions per gene\n**variances**\nFor `flavor='seurat_v3'`, variance per gene\n**variances_norm**\nFor `flavor='seurat_v3'`, normalized variance per gene, averaged in\nthe case of multiple batches\nhighly_variable_rank : float\nFor `flavor='seurat_v3'`, rank of the gene according to normalized\nvariance, median rank in the case of multiple batches\nhighly_variable_nbatches : int\nIf batch_key is given, this denotes in how many batches genes are detected as HVG\nhighly_variable_intersection : bool\nIf batch_key is given, this denotes the genes that are highly variable in all batches\nNotes\nThis function replaces :func:`~scanpy.pp.filter_genes_dispersion`."
        },
        "Docstring": "Annotate highly variable genes [Satija15]_ [Zheng17]_ [Stuart19]_.\n\nExpects logarithmized data, except when `flavor='seurat_v3'`, in which count\ndata is expected.\n\nDepending on `flavor`, this reproduces the R-implementations of Seurat\n[Satija15]_, Cell Ranger [Zheng17]_, and Seurat v3 [Stuart19]_. Seurat v3 flavor\nrequires `scikit-misc` package. If you plan to use this flavor, consider\ninstalling `scanpy` with this optional dependency: `scanpy[skmisc]`.\n\nFor the dispersion-based methods (`flavor='seurat'` [Satija15]_ and\n`flavor='cell_ranger'` [Zheng17]_), the normalized dispersion is obtained\nby scaling with the mean and standard deviation of the dispersions for genes\nfalling into a given bin for mean expression of genes. This means that for each\nbin of mean expression, highly variable genes are selected.\n\nFor `flavor='seurat_v3'` [Stuart19]_, a normalized variance for each gene\nis computed. First, the data are standardized (i.e., z-score normalization\nper feature) with a regularized standard deviation. Next, the normalized variance\nis computed as the variance of each gene after the transformation. Genes are ranked\nby the normalized variance.\n\nSee also `scanpy.experimental.pp._highly_variable_genes` for additional flavours\n(e.g. Pearson residuals).\n\nParameters\n----------\nadata\n    The annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\n    to cells and columns to genes.\nlayer\n    If provided, use `adata.layers[layer]` for expression values instead of `adata.X`.\nn_top_genes\n    Number of highly-variable genes to keep. Mandatory if `flavor='seurat_v3'`.\nmin_mean\n    If `n_top_genes` unequals `None`, this and all other cutoffs for the means and the\n    normalized dispersions are ignored. Ignored if `flavor='seurat_v3'`.\nmax_mean\n    If `n_top_genes` unequals `None`, this and all other cutoffs for the means and the\n    normalized dispersions are ignored. Ignored if `flavor='seurat_v3'`.\nmin_disp\n    If `n_top_genes` unequals `None`, this and all other cutoffs for the means and the\n    normalized dispersions are ignored. Ignored if `flavor='seurat_v3'`.\nmax_disp\n    If `n_top_genes` unequals `None`, this and all other cutoffs for the means and the\n    normalized dispersions are ignored. Ignored if `flavor='seurat_v3'`.\nspan\n    The fraction of the data (cells) used when estimating the variance in the loess\n    model fit if `flavor='seurat_v3'`.\nn_bins\n    Number of bins for binning the mean gene expression. Normalization is\n    done with respect to each bin. If just a single gene falls into a bin,\n    the normalized dispersion is artificially set to 1. You'll be informed\n    about this if you set `settings.verbosity = 4`.\nflavor\n    Choose the flavor for identifying highly variable genes. For the dispersion\n    based methods in their default workflows, Seurat passes the cutoffs whereas\n    Cell Ranger passes `n_top_genes`.\nsubset\n    Inplace subset to highly-variable genes if `True` otherwise merely indicate\n    highly variable genes.\ninplace\n    Whether to place calculated metrics in `.var` or return them.\nbatch_key\n    If specified, highly-variable genes are selected within each batch separately and merged.\n    This simple process avoids the selection of batch-specific genes and acts as a\n    lightweight batch correction method. For all flavors, genes are first sorted\n    by how many batches they are a HVG. For dispersion-based flavors ties are broken\n    by normalized dispersion. If `flavor = 'seurat_v3'`, ties are broken by the median\n    (across batches) rank based on within-batch normalized variance.\ncheck_values\n    Check if counts in selected layer are integers. A Warning is returned if set to True.\n    Only used if `flavor='seurat_v3'`.\n\nReturns\n-------\nDepending on `inplace` returns calculated metrics (:class:`~pandas.DataFrame`) or\nupdates `.var` with the following fields\n\nhighly_variable : bool\n    boolean indicator of highly-variable genes\n**means**\n    means per gene\n**dispersions**\n    For dispersion-based flavors, dispersions per gene\n**dispersions_norm**\n    For dispersion-based flavors, normalized dispersions per gene\n**variances**\n    For `flavor='seurat_v3'`, variance per gene\n**variances_norm**\n    For `flavor='seurat_v3'`, normalized variance per gene, averaged in\n    the case of multiple batches\nhighly_variable_rank : float\n    For `flavor='seurat_v3'`, rank of the gene according to normalized\n    variance, median rank in the case of multiple batches\nhighly_variable_nbatches : int\n    If batch_key is given, this denotes in how many batches genes are detected as HVG\nhighly_variable_intersection : bool\n    If batch_key is given, this denotes the genes that are highly variable in all batches\n\nNotes\n-----\nThis function replaces :func:`~scanpy.pp.filter_genes_dispersion`.",
        "description": "Annotate highly variable genes [Satija15]_ [Zheng17]_ [Stuart19]_.Expects logarithmized data, except when `flavor='seurat_v3'`, in which count\ndata is expected.\n\nDepending on `flavor`, this reproduces the R-implementations of Seurat\n[Satija15]_, Cell Ranger [Zheng17]_, and Seurat v3 [Stuart19]_. Seurat v3 flavor\nrequires `scikit-misc` package. If you plan to use this flavor, consider\ninstalling `scanpy` with this optional dependency: `scanpy[skmisc]`.\n\nFor the dispersion-based methods (`flavor='seurat'` [Satija15]_ and\n`flavor='cell_ranger'` [Zheng17]_), the normalized dispersion is obtained\nby scaling with the mean and standard deviation of the dispersions for genes\nfalling into a given bin for mean expression of genes. This means that for each\nbin of mean expression, highly variable genes are selected.\n\nFor `flavor='seurat_v3'` [Stuart19]_, a normalized variance for each gene\nis computed. First, the data are standardized (i.e., z-score normalization\nper feature) with a regularized standard deviation. Next, the normalized variance\nis computed as the variance of each gene after the transformation. Genes are ranked\nby the normalized variance.\n\nSee also `scanpy.experimental.pp._highly_variable_genes` for additional flavours\n(e.g. Pearson residuals).",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.highly_variable_genes(adata=$, layer=@, n_top_genes=@, min_disp=@, max_disp=@, min_mean=@, max_mean=@, span=@, n_bins=@, flavor=$, subset=@, inplace=@, batch_key=@, check_values=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot.add_dendrogram": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'add_dendrogram'",
                "optional_value": false
            },
            "dendrogram_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Needed if `sc.tl.dendrogram` saved the dendrogram using a key different\nthan the default name.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[float]",
                "default": "0.8",
                "optional": true,
                "description": "size of the dendrogram. Corresponds to width when dendrogram shown on\nthe right of the plot, or height when shown on top. The unit is the same\nas in matplotlib (inches).",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Show dendrogram based on the hierarchical clustering between the `groupby`\ncategories. Categories are reordered to match the dendrogram order.\n\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `sc.tl.dendrogram` has not been called previously the function is called\nwith default parameters.\n\nThe dendrogram is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n`var_names` are reordered to produce a more pleasing output if:\n    * The data contains `var_groups`\n    * the `var_groups` match the categories.\n\nThe previous conditions happen by default when using Plot\nto show the results from :func:`~scanpy.tl.rank_genes_groups` (aka gene markers), by\ncalling `scanpy.tl.rank_genes_groups_(plot_name)`.\n\n\nParameters\n----------\nshow\n    Boolean to turn on (True) or off (False) 'add_dendrogram'\ndendrogram_key\n    Needed if `sc.tl.dendrogram` saved the dendrogram using a key different\n    than the default name.\nsize\n    size of the dendrogram. Corresponds to width when dendrogram shown on\n    the right of the plot, or height when shown on top. The unit is the same\n    as in matplotlib (inches).\n\nReturns\n-------\nBasePlot\n\n\nExamples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_dendrogram().show()",
        "description": "Show dendrogram based on the hierarchical clustering between the `groupby`categories. Categories are reordered to match the dendrogram order.\n\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `sc.tl.dendrogram` has not been called previously the function is called\nwith default parameters.\n\nThe dendrogram is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n`var_names` are reordered to produce a more pleasing output if:\n    * The data contains `var_groups`\n    * the `var_groups` match the categories.\n\nThe previous conditions happen by default when using Plot\nto show the results from :func:`~scanpy.tl.rank_genes_groups` (aka gene markers), by\ncalling `scanpy.tl.rank_genes_groups_(plot_name)`.",
        "example": "Examples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_dendrogram().show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.MatrixPlot.add_dendrogram(show=@, dendrogram_key=@, size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.embedding_density": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "basis": {
                "type": "str",
                "default": "umap",
                "optional": true,
                "description": "The embedding over which the density was calculated. This embedded\nrepresentation should be found in `adata.obsm['X_[basis]']``.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the `.obs` covariate that contains the density estimates. Alternatively, pass `groupby`.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the condition used in `tl.embedding_density`. Alternatively, pass `key`.",
                "optional_value": false
            },
            "group": {
                "type": "Optional[Union[str, List[str]]]",
                "default": "all",
                "optional": true,
                "description": "The category in the categorical observation annotation to be plotted.\nFor example, 'G1' in the cell cycle 'phase' covariate. If all categories\nare to be plotted use group='all' (default), If multiple categories\nwant to be plotted use a list (e.g.: ['G1', 'S']. If the overall density\nwants to be ploted set group to 'None'.",
                "optional_value": false
            },
            "color_map": {
                "type": "Union[Colormap, str]",
                "default": "YlOrRd",
                "optional": true,
                "description": "Matplolib color map to use for density plotting.",
                "optional_value": false
            },
            "bg_dotsize": {
                "type": "Optional[int]",
                "default": "80",
                "optional": true,
                "description": "Dot size for background data points not in the `group`.",
                "optional_value": false
            },
            "fg_dotsize": {
                "type": "Optional[int]",
                "default": "180",
                "optional": true,
                "description": "Dot size for foreground data points in the `group`.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[int]",
                "default": "1",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[int]",
                "default": "0",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "ncols": {
                "type": "Optional[int]",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "Optional[float]",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "NoneType",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": true
            },
            "title": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Figure, Axes]]",
            "description": ""
        },
        "Docstring": "Plot the density of cells in an embedding (per condition).\n\nPlots the gaussian kernel density estimates (over condition) from the\n`sc.tl.embedding_density()` output.\n\nThis function was written by Sophie Tritschler and implemented into\nScanpy by Malte Luecken.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nbasis\n    The embedding over which the density was calculated. This embedded\n    representation should be found in `adata.obsm['X_[basis]']``.\nkey\n    Name of the `.obs` covariate that contains the density estimates. Alternatively, pass `groupby`.\ngroupby\n    Name of the condition used in `tl.embedding_density`. Alternatively, pass `key`.\ngroup\n    The category in the categorical observation annotation to be plotted.\n    For example, 'G1' in the cell cycle 'phase' covariate. If all categories\n    are to be plotted use group='all' (default), If multiple categories\n    want to be plotted use a list (e.g.: ['G1', 'S']. If the overall density\n    wants to be ploted set group to 'None'.\ncolor_map\n    Matplolib color map to use for density plotting.\nbg_dotsize\n    Dot size for background data points not in the `group`.\nfg_dotsize\n    Dot size for foreground data points in the `group`.\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.umap(adata)\n    sc.tl.embedding_density(adata, basis='umap', groupby='phase')\n\nPlot all categories be default\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.embedding_density(adata, basis='umap', key='umap_density_phase')\n\nPlot selected categories\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.embedding_density(\n        adata,\n        basis='umap',\n        key='umap_density_phase',\n        group=['G1', 'S'],\n    )\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.embedding_density",
        "description": "Plot the density of cells in an embedding (per condition).Plots the gaussian kernel density estimates (over condition) from the\n`sc.tl.embedding_density()` output.\n\nThis function was written by Sophie Tritschler and implemented into\nScanpy by Malte Luecken.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.umap(adata)\n    sc.tl.embedding_density(adata, basis='umap', groupby='phase')\n\nPlot all categories be default\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.embedding_density(adata, basis='umap', key='umap_density_phase')\n\nPlot selected categories\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.embedding_density(\n        adata,\n        basis='umap',\n        key='umap_density_phase',\n        group=['G1', 'S'],\n    )\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.embedding_density",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.embedding_density(adata=$, basis=@, key=@, groupby=@, group=@, color_map=@, bg_dotsize=@, fg_dotsize=@, vmax=@, vmin=@, vcenter=@, norm=$, ncols=@, hspace=@, wspace=$, title=@, show=@, save=@, ax=$, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.blobs": {
        "Parameters": {
            "n_variables": {
                "type": "int",
                "default": "11",
                "optional": true,
                "description": "Dimension of feature space.",
                "optional_value": false
            },
            "n_centers": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "Number of cluster centers.",
                "optional_value": false
            },
            "cluster_std": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Standard deviation of clusters.",
                "optional_value": false
            },
            "n_observations": {
                "type": "int",
                "default": "640",
                "optional": true,
                "description": "Number of observations. By default, this is the same observation number\nas in :func:`scanpy.datasets.krumsiek11`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix containing a observation annotation 'blobs' that\nindicates cluster identity."
        },
        "Docstring": "Gaussian Blobs.\n\nParameters\n----------\nn_variables\n    Dimension of feature space.\nn_centers\n    Number of cluster centers.\ncluster_std\n    Standard deviation of clusters.\nn_observations\n    Number of observations. By default, this is the same observation number\n    as in :func:`scanpy.datasets.krumsiek11`.\n\nReturns\n-------\nAnnotated data matrix containing a observation annotation 'blobs' that\nindicates cluster identity.",
        "description": "Gaussian Blobs.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.blobs(n_variables=@, n_centers=@, cluster_std=@, n_observations=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.experimental.pp.normalize_pearson_residuals": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "theta": {
                "type": "float",
                "default": "100",
                "optional": true,
                "description": "The negative binomial overdispersion parameter `theta` for Pearson residuals.\nHigher values correspond to less overdispersion     (`var = mean + mean^2/theta`), and `theta=np.Inf` corresponds to a Poisson model.",
                "optional_value": false
            },
            "clip": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Determines if and how residuals are clipped:\n\n* If `None`, residuals are clipped to the interval     `[-sqrt(n_obs), sqrt(n_obs)]`, where `n_obs` is the number of cells in the dataset (default behavior).\n* If any scalar `c`, residuals are clipped to the interval `[-c, c]`. Set     `clip=np.Inf` for no clipping.",
                "optional_value": false
            },
            "check_values": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, checks if counts in selected layer are integers as expected by this\nfunction, and return a warning if non-integers are found. Otherwise, proceed\nwithout checking. Setting this to `False` can speed up code for large datasets.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Layer to use as input instead of `X`. If `None`, `X` is used.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, update `adata` with results. Otherwise, return results. See below for\ndetails of what is returned.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, the function runs on a copy of the input object and returns the\nmodified copy. Otherwise, the input object is modified direcly. Not compatible\nwith `inplace=False`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Dict[str, ndarray]]",
            "description": "If `inplace=True`, `adata.X` or the selected layer in `adata.layers` is updated\nwith the normalized values. `adata.uns` is updated with the following fields.\nIf `inplace=False`, the same fields are returned as dictionary with the\nnormalized values in `results_dict['X']`.\n`.uns['pearson_residuals_normalization']['theta']`\nThe used value of the overdisperion parameter theta.\n`.uns['pearson_residuals_normalization']['clip']`\nThe used value of the clipping parameter.\n`.uns['pearson_residuals_normalization']['computed_on']`\nThe name of the layer on which the residuals were computed."
        },
        "Docstring": "Applies analytic Pearson residual normalization, based on [Lause21]_.\n\nThe residuals are based on a negative binomial offset model with overdispersion\n`theta` shared across genes. By default, residuals are clipped to `sqrt(n_obs)`\nand overdispersion `theta=100` is used.\n\nExpects raw count input.\n\nParams\n------\nadata\n    The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\n\ntheta\n    The negative binomial overdispersion parameter `theta` for Pearson residuals.\n    Higher values correspond to less overdispersion     (`var = mean + mean^2/theta`), and `theta=np.Inf` corresponds to a Poisson model.\nclip\n    Determines if and how residuals are clipped:\n\n    * If `None`, residuals are clipped to the interval     `[-sqrt(n_obs), sqrt(n_obs)]`, where `n_obs` is the number of cells in the dataset (default behavior).\n    * If any scalar `c`, residuals are clipped to the interval `[-c, c]`. Set     `clip=np.Inf` for no clipping.\n\ncheck_values\n    If `True`, checks if counts in selected layer are integers as expected by this\n    function, and return a warning if non-integers are found. Otherwise, proceed\n    without checking. Setting this to `False` can speed up code for large datasets.\n\nlayer\n    Layer to use as input instead of `X`. If `None`, `X` is used.\n\ninplace\n    If `True`, update `adata` with results. Otherwise, return results. See below for\n    details of what is returned.\n\ncopy\n    If `True`, the function runs on a copy of the input object and returns the\n    modified copy. Otherwise, the input object is modified direcly. Not compatible\n    with `inplace=False`.\n\n\nReturns\n-------\nIf `inplace=True`, `adata.X` or the selected layer in `adata.layers` is updated\nwith the normalized values. `adata.uns` is updated with the following fields.\nIf `inplace=False`, the same fields are returned as dictionary with the\nnormalized values in `results_dict['X']`.\n\n`.uns['pearson_residuals_normalization']['theta']`\n     The used value of the overdisperion parameter theta.\n`.uns['pearson_residuals_normalization']['clip']`\n     The used value of the clipping parameter.\n`.uns['pearson_residuals_normalization']['computed_on']`\n     The name of the layer on which the residuals were computed.",
        "description": "Applies analytic Pearson residual normalization, based on [Lause21]_.The residuals are based on a negative binomial offset model with overdispersion\n`theta` shared across genes. By default, residuals are clipped to `sqrt(n_obs)`\nand overdispersion `theta=100` is used.\n\nExpects raw count input.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.experimental.pp.normalize_pearson_residuals(adata=$, theta=@, clip=@, check_values=@, layer=@, inplace=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.magic": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An anndata file with `.raw` attribute representing raw counts.",
                "optional_value": true
            },
            "name_list": {
                "type": "Optional[Union[Literal[all_genes, pca_only], Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Denoised genes to return. The default `'all_genes'`/`None`\nmay require a large amount of memory if the input data is sparse.\nAnother possibility is `'pca_only'`.",
                "optional_value": false
            },
            "knn": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "number of nearest neighbors on which to build kernel.",
                "optional_value": false
            },
            "decay": {
                "type": "Optional[float]",
                "default": "1",
                "optional": true,
                "description": "sets decay rate of kernel tails.\nIf None, alpha decaying kernel is not used.",
                "optional_value": false
            },
            "knn_max": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "maximum number of nearest neighbors with nonzero connection.\nIf `None`, will be set to 3 * `knn`.",
                "optional_value": false
            },
            "t": {
                "type": "Union[Literal[auto], int]",
                "default": "3",
                "optional": true,
                "description": "power to which the diffusion operator is powered.\nThis sets the level of diffusion. If 'auto', t is selected\naccording to the Procrustes disparity of the diffused data.",
                "optional_value": false
            },
            "n_pca": {
                "type": "Optional[int]",
                "default": "100",
                "optional": true,
                "description": "Number of principal components to use for calculating\nneighborhoods. For extremely large datasets, using\nn_pca < 20 allows neighborhoods to be calculated in\nroughly log(n_samples) time. If `None`, no PCA is performed.",
                "optional_value": false
            },
            "solver": {
                "type": "Literal[exact, approximate]",
                "default": "exact",
                "optional": true,
                "description": "Which solver to use. \"exact\" uses the implementation described\nin van Dijk et al. (2018) [vanDijk18]_. \"approximate\" uses a faster\nimplementation that performs imputation in the PCA space and then\nprojects back to the gene space. Note, the \"approximate\" solver may\nreturn negative values.",
                "optional_value": true
            },
            "knn_dist": {
                "type": "str",
                "default": "euclidean",
                "optional": true,
                "description": "recommended values: 'euclidean', 'cosine', 'precomputed'\nAny metric from `scipy.spatial.distance` can be used\ndistance metric for building kNN graph. If 'precomputed',\n`data` should be an n_samples x n_samples distance or\naffinity matrix.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "None",
                "optional": true,
                "description": "Random seed. Defaults to the global `numpy` random number generator.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of threads to use in training. All cores are used by default.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True` or an integer `>= 2`, print status messages.\nIf `None`, `sc.settings.verbosity` is used.",
                "optional_value": false
            },
            "copy": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If true, a copy of anndata is returned. If `None`, `copy` is True if\n`genes` is not `'all_genes'` or `'pca_only'`. `copy` may only be False\nif `genes` is `'all_genes'` or `'pca_only'`, as the resultant data\nwill otherwise have different column names from the input data.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "If `copy` is True, AnnData object is returned.\nIf `subset_genes` is not `all_genes`, PCA on MAGIC values of cells are\nstored in `adata.obsm['X_magic']` and `adata.X` is not modified.\nThe raw counts are stored in `.raw` attribute of AnnData object."
        },
        "Docstring": "Markov Affinity-based Graph Imputation of Cells (MAGIC) API [vanDijk18]_.\n\nMAGIC is an algorithm for denoising and transcript recover of single cells\napplied to single-cell sequencing data. MAGIC builds a graph from the data\nand uses diffusion to smooth out noise and recover the data manifold.\n\nThe algorithm implemented here has changed primarily in two ways\ncompared to the algorithm described in [vanDijk18]_. Firstly, we use\nthe adaptive kernel described in Moon et al, 2019 [Moon17]_ for\nimproved stability. Secondly, data diffusion is applied\nin the PCA space, rather than the data space, for speed and\nmemory improvements.\n\nMore information and bug reports\n`here <https://github.com/KrishnaswamyLab/MAGIC>`__. For help, visit\n<https://krishnaswamylab.org/get-help>.\n\nParameters\n----------\nadata\n    An anndata file with `.raw` attribute representing raw counts.\nname_list\n    Denoised genes to return. The default `'all_genes'`/`None`\n    may require a large amount of memory if the input data is sparse.\n    Another possibility is `'pca_only'`.\nknn\n    number of nearest neighbors on which to build kernel.\ndecay\n    sets decay rate of kernel tails.\n    If None, alpha decaying kernel is not used.\nknn_max\n    maximum number of nearest neighbors with nonzero connection.\n    If `None`, will be set to 3 * `knn`.\nt\n    power to which the diffusion operator is powered.\n    This sets the level of diffusion. If 'auto', t is selected\n    according to the Procrustes disparity of the diffused data.\nn_pca\n    Number of principal components to use for calculating\n    neighborhoods. For extremely large datasets, using\n    n_pca < 20 allows neighborhoods to be calculated in\n    roughly log(n_samples) time. If `None`, no PCA is performed.\nsolver\n    Which solver to use. \"exact\" uses the implementation described\n    in van Dijk et al. (2018) [vanDijk18]_. \"approximate\" uses a faster\n    implementation that performs imputation in the PCA space and then\n    projects back to the gene space. Note, the \"approximate\" solver may\n    return negative values.\nknn_dist\n    recommended values: 'euclidean', 'cosine', 'precomputed'\n    Any metric from `scipy.spatial.distance` can be used\n    distance metric for building kNN graph. If 'precomputed',\n    `data` should be an n_samples x n_samples distance or\n    affinity matrix.\nrandom_state\n    Random seed. Defaults to the global `numpy` random number generator.\nn_jobs\n    Number of threads to use in training. All cores are used by default.\nverbose\n    If `True` or an integer `>= 2`, print status messages.\n    If `None`, `sc.settings.verbosity` is used.\ncopy\n    If true, a copy of anndata is returned. If `None`, `copy` is True if\n    `genes` is not `'all_genes'` or `'pca_only'`. `copy` may only be False\n    if `genes` is `'all_genes'` or `'pca_only'`, as the resultant data\n    will otherwise have different column names from the input data.\nkwargs\n    Additional arguments to `magic.MAGIC`.\n\nReturns\n-------\nIf `copy` is True, AnnData object is returned.\n\nIf `subset_genes` is not `all_genes`, PCA on MAGIC values of cells are\nstored in `adata.obsm['X_magic']` and `adata.X` is not modified.\n\nThe raw counts are stored in `.raw` attribute of AnnData object.\n\nExamples\n--------\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> adata = sc.datasets.paul15()\n>>> sc.pp.normalize_per_cell(adata)\n>>> sc.pp.sqrt(adata)  # or sc.pp.log1p(adata)\n>>> adata_magic = sce.pp.magic(adata, name_list=['Mpo', 'Klf1', 'Ifitm1'], knn=5)\n>>> adata_magic.shape\n(2730, 3)\n>>> sce.pp.magic(adata, name_list='pca_only', knn=5)\n>>> adata.obsm['X_magic'].shape\n(2730, 100)\n>>> sce.pp.magic(adata, name_list='all_genes', knn=5)\n>>> adata.X.shape\n(2730, 3451)",
        "description": "Markov Affinity-based Graph Imputation of Cells (MAGIC) API [vanDijk18]_.MAGIC is an algorithm for denoising and transcript recover of single cells\napplied to single-cell sequencing data. MAGIC builds a graph from the data\nand uses diffusion to smooth out noise and recover the data manifold.\n\nThe algorithm implemented here has changed primarily in two ways\ncompared to the algorithm described in [vanDijk18]_. Firstly, we use\nthe adaptive kernel described in Moon et al, 2019 [Moon17]_ for\nimproved stability. Secondly, data diffusion is applied\nin the PCA space, rather than the data space, for speed and\nmemory improvements.\n\nMore information and bug reports\n`here <https://github.com/KrishnaswamyLab/MAGIC>`__. For help, visit\n<https://krishnaswamylab.org/get-help>.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> adata = sc.datasets.paul15()\n>>> sc.pp.normalize_per_cell(adata)\n>>> sc.pp.sqrt(adata)  # or sc.pp.log1p(adata)\n>>> adata_magic = sce.pp.magic(adata, name_list=['Mpo', 'Klf1', 'Ifitm1'], knn=5)\n>>> adata_magic.shape\n(2730, 3)\n>>> sce.pp.magic(adata, name_list='pca_only', knn=5)\n>>> adata.obsm['X_magic'].shape\n(2730, 100)\n>>> sce.pp.magic(adata, name_list='all_genes', knn=5)\n>>> adata.X.shape\n(2730, 3451)",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.magic(adata=$, name_list=@, knn=@, decay=@, knn_max=@, t=@, n_pca=@, solver=$, knn_dist=@, random_state=@, n_jobs=@, verbose=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.pca_loadings": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "components": {
                "type": "Optional[Union[str, Sequence[int]]]",
                "default": "None",
                "optional": true,
                "description": "For example, ``'1,2,3'`` means ``[1, 2, 3]``, first, second, third\nprincipal component.",
                "optional_value": false
            },
            "include_lowest": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the variables with both highest and lowest loadings.",
                "optional_value": false
            },
            "n_points": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of variables to plot for each component.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Rank genes according to contributions to PCs.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncomponents\n    For example, ``'1,2,3'`` means ``[1, 2, 3]``, first, second, third\n    principal component.\ninclude_lowest\n    Whether to show the variables with both highest and lowest loadings.\nshow\n    Show the plot, do not return axis.\nn_points\n    Number of variables to plot for each component.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n\nExamples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc3k_processed()\n\nShow first 3 components loadings\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.pca_loadings(adata, components = '1,2,3')",
        "description": "Rank genes according to contributions to PCs.",
        "example": "Examples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc3k_processed()\n\nShow first 3 components loadings\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.pca_loadings(adata, components = '1,2,3')",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.pca_loadings(adata=$, components=@, include_lowest=@, n_points=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.metrics.gearys_c": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": null,
                "optional_value": true
            },
            "vals": {
                "type": "Optional[Union[ndarray, spmatrix]]",
                "default": "None",
                "optional": true,
                "description": "The values",
                "optional_value": true
            },
            "use_graph": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key to use for graph in anndata object. If not provided, default\nneighbors connectivities will be used instead.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `adata.layers` to choose `vals`.",
                "optional_value": false
            },
            "obsm": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `adata.obsm` to choose `vals`.",
                "optional_value": false
            },
            "obsp": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `adata.obsp` to choose `vals`.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use `adata.raw.X` for `vals`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Union[ndarray, float]",
            "description": "If vals is two dimensional, returns a 1 dimensional ndarray array. Returns\na scalar if `vals` is 1d."
        },
        "Docstring": "Calculate `Geary's C <https://en.wikipedia.org/wiki/Geary's_C>`_, as used\nby `VISION <https://doi.org/10.1038/s41467-019-12235-0>`_.\n\nGeary's C is a measure of autocorrelation for some measure on a graph. This\ncan be to whether measures are correlated between neighboring cells. Lower\nvalues indicate greater correlation.\n\n.. math::\n\n    C =\n    \\frac{\n        (N - 1)\\sum_{i,j} w_{i,j} (x_i - x_j)^2\n    }{\n        2W \\sum_i (x_i - \\bar{x})^2\n    }\n\nParams\n------\nadata\nvals\n    Values to calculate Geary's C for. If this is two dimensional, should\n    be of shape `(n_features, n_cells)`. Otherwise should be of shape\n    `(n_cells,)`. This matrix can be selected from elements of the anndata\n    object by using key word arguments: `layer`, `obsm`, `obsp`, or\n    `use_raw`.\nuse_graph\n    Key to use for graph in anndata object. If not provided, default\n    neighbors connectivities will be used instead.\nlayer\n    Key for `adata.layers` to choose `vals`.\nobsm\n    Key for `adata.obsm` to choose `vals`.\nobsp\n    Key for `adata.obsp` to choose `vals`.\nuse_raw\n    Whether to use `adata.raw.X` for `vals`.\n\n\nThis function can also be called on the graph and values directly. In this case\nthe signature looks like:\n\nParams\n------\ng\n    The graph\nvals\n    The values\n\n\nSee the examples for more info.\n\nReturns\n-------\nIf vals is two dimensional, returns a 1 dimensional ndarray array. Returns\na scalar if `vals` is 1d.\n\n\nExamples\n--------\n\nCalculate Gearys C for each components of a dimensionality reduction:\n\n.. code:: python\n\n    import scanpy as sc, numpy as np\n\n    pbmc = sc.datasets.pbmc68k_processed()\n    pc_c = sc.metrics.gearys_c(pbmc, obsm=\"X_pca\")\n\n\nIt's equivalent to call the function directly on the underlying arrays:\n\n.. code:: python\n\n    alt = sc.metrics.gearys_c(pbmc.obsp[\"connectivities\"], pbmc.obsm[\"X_pca\"].T)\n    np.testing.assert_array_equal(pc_c, alt)",
        "description": "Calculate `Geary's C <https://en.wikipedia.org/wiki/Geary's_C>`_, as usedby `VISION <https://doi.org/10.1038/s41467-019-12235-0>`_.\n\nGeary's C is a measure of autocorrelation for some measure on a graph. This\ncan be to whether measures are correlated between neighboring cells. Lower\nvalues indicate greater correlation.\n\n.. math::\n\n    C =\n    \\frac{\n        (N - 1)\\sum_{i,j} w_{i,j} (x_i - x_j)^2\n    }{\n        2W \\sum_i (x_i - \\bar{x})^2\n    }",
        "example": "Examples\n--------\n\nCalculate Gearys C for each components of a dimensionality reduction:\n\n.. code:: python\n\n    import scanpy as sc, numpy as np\n\n    pbmc = sc.datasets.pbmc68k_processed()\n    pc_c = sc.metrics.gearys_c(pbmc, obsm=\"X_pca\")\n\n\nIt's equivalent to call the function directly on the underlying arrays:\n\n.. code:: python\n\n    alt = sc.metrics.gearys_c(pbmc.obsp[\"connectivities\"], pbmc.obsm[\"X_pca\"].T)\n    np.testing.assert_array_equal(pc_c, alt)",
        "api_type": "function",
        "api_calling": [
            "scanpy.metrics.gearys_c(adata=$, vals=$, use_graph=@, layer=@, obsm=@, obsp=@, use_raw=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.exporting.spring_project": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix: `adata.uns['neighbors']` needs to\nbe present.",
                "optional_value": true
            },
            "project_dir": {
                "type": "Union[Path, str]",
                "default": null,
                "optional": false,
                "description": "Path to directory for exported SPRING files.",
                "optional_value": false
            },
            "embedding_method": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Name of a 2-D embedding in `adata.obsm`",
                "optional_value": false
            },
            "subplot_name": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of subplot folder to be created at `project_dir+\"/\"+subplot_name`",
                "optional_value": false
            },
            "cell_groupings": {
                "type": "Optional[Union[str, Iterable[str]]]",
                "default": "None",
                "optional": true,
                "description": "Instead of importing all categorical annotations when `None`,\npass a list of keys for `adata.obs`.",
                "optional_value": false
            },
            "custom_color_tracks": {
                "type": "Optional[Union[str, Iterable[str]]]",
                "default": "None",
                "optional": true,
                "description": "Specify specific `adata.obs` keys for continuous coloring.",
                "optional_value": false
            },
            "total_counts_key": {
                "type": "str",
                "default": "n_counts",
                "optional": true,
                "description": "Name of key for total transcript counts in `adata.obs`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "overwrite": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "When `True`, existing counts matrices in `project_dir` are overwritten.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Exports to a SPRING project directory [Weinreb17]_.\n\nVisualize annotation present in `adata`. By default, export all gene expression data\nfrom `adata.raw` and categorical and continuous annotations present in `adata.obs`.\n\nSee `SPRING <https://github.com/AllonKleinLab/SPRING>`__ or [Weinreb17]_ for details.\n\nParameters\n----------\nadata\n    Annotated data matrix: `adata.uns['neighbors']` needs to\n    be present.\nproject_dir\n    Path to directory for exported SPRING files.\nembedding_method\n    Name of a 2-D embedding in `adata.obsm`\nsubplot_name\n    Name of subplot folder to be created at `project_dir+\"/\"+subplot_name`\ncell_groupings\n    Instead of importing all categorical annotations when `None`,\n    pass a list of keys for `adata.obs`.\ncustom_color_tracks\n    Specify specific `adata.obs` keys for continuous coloring.\ntotal_counts_key\n    Name of key for total transcript counts in `adata.obs`.\noverwrite\n    When `True`, existing counts matrices in `project_dir` are overwritten.\n\nExamples\n--------\nSee this `tutorial <https://github.com/scverse/scanpy_usage/tree/master/171111_SPRING_export>`__.",
        "description": "Exports to a SPRING project directory [Weinreb17]_.Visualize annotation present in `adata`. By default, export all gene expression data\nfrom `adata.raw` and categorical and continuous annotations present in `adata.obs`.\n\nSee `SPRING <https://github.com/AllonKleinLab/SPRING>`__ or [Weinreb17]_ for details.",
        "example": "Examples\n--------\nSee this `tutorial <https://github.com/scverse/scanpy_usage/tree/master/171111_SPRING_export>`__.",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.exporting.spring_project(adata=$, project_dir=@, embedding_method=@, subplot_name=@, cell_groupings=@, custom_color_tracks=@, total_counts_key=@, neighbors_key=@, overwrite=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.rank_genes_groups_heatmap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The groups for which to show the gene ranking.",
                "optional_value": false
            },
            "n_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\n`gene_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
                "optional_value": false
            },
            "key": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Key used to store the ranking results in `adata.uns`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes using heatmap plot (see :func:`~scanpy.pl.heatmap`)\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroups\n    The groups for which to show the gene ranking.\nn_genes\n    Number of genes to show. This can be a negative number to show for\n    example the down regulated genes. eg: num_genes=-10. Is ignored if\n    `gene_names` is passed.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\ngroupby\n    The key of the observation grouping to consider. By default,\n    the groupby is chosen from the rank genes groups parameter but\n    other groupby options can be used.  It is expected that\n    groupby is a categorical. If groupby is not a categorical observation,\n    it would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).\nmin_logfoldchange\n    Value to filter genes in groups if their logfoldchange is less than the\n    min_logfoldchange\nkey\n    Key used to store the ranking results in `adata.uns`.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n**kwds\n    Are passed to :func:`~scanpy.pl.heatmap`.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.rank_genes_groups(adata, 'bulk_labels')\n    sc.pl.rank_genes_groups_heatmap(adata)\n\nShow gene names per group on the heatmap\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_heatmap(adata, show_gene_labels=True)\n\nPlot top 5 genes per group (default 10 genes)\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_heatmap(adata, n_genes=5, show_gene_labels=True)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.rank_genes_groups\ntl.dendrogram",
        "description": "Plot ranking of genes using heatmap plot (see :func:`~scanpy.pl.heatmap`)",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.rank_genes_groups(adata, 'bulk_labels')\n    sc.pl.rank_genes_groups_heatmap(adata)\n\nShow gene names per group on the heatmap\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_heatmap(adata, show_gene_labels=True)\n\nPlot top 5 genes per group (default 10 genes)\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_heatmap(adata, n_genes=5, show_gene_labels=True)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.rank_genes_groups\ntl.dendrogram",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.rank_genes_groups_heatmap(adata=$, groups=@, n_genes=@, groupby=@, gene_symbols=@, var_names=@, min_logfoldchange=@, key=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_10x_h5": {
        "Parameters": {
            "filename": {
                "type": "Union[str, Path]",
                "default": null,
                "optional": false,
                "description": "Path to a 10x hdf5 file.",
                "optional_value": false
            },
            "genome": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Filter expression to genes within this genome. For legacy 10x h5\nfiles, this must be provided if the data contains more than one genome.",
                "optional_value": false
            },
            "gex_only": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Only keep 'Gene Expression' data and ignore other feature types,\ne.g. 'Antibody Capture', 'CRISPR Guide Capture', or 'Custom'",
                "optional_value": false
            },
            "backup_url": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Retrieve the file from an URL if not present on disk.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix, where observations/cells are named by their\nbarcode and variables/genes by gene name. Stores the following information:\n:attr:`~anndata.AnnData.X`\nThe data matrix is stored\n:attr:`~anndata.AnnData.obs_names`\nCell names\n:attr:`~anndata.AnnData.var_names`\nGene names for a feature barcode matrix, probe names for a probe bc matrix\n:attr:`~anndata.AnnData.var`\\ `['gene_ids']`\nGene IDs\n:attr:`~anndata.AnnData.var`\\ `['feature_types']`\nFeature types\n:attr:`~anndata.AnnData.obs`\\ `[filtered_barcodes]`\nfiltered barcodes if present in the matrix\n:attr:`~anndata.AnnData.var`\nAny additional metadata present in /matrix/features is read in."
        },
        "Docstring": "Read 10x-Genomics-formatted hdf5 file.\n\nParameters\n----------\nfilename\n    Path to a 10x hdf5 file.\ngenome\n    Filter expression to genes within this genome. For legacy 10x h5\n    files, this must be provided if the data contains more than one genome.\ngex_only\n    Only keep 'Gene Expression' data and ignore other feature types,\n    e.g. 'Antibody Capture', 'CRISPR Guide Capture', or 'Custom'\nbackup_url\n    Retrieve the file from an URL if not present on disk.\n\nReturns\n-------\nAnnotated data matrix, where observations/cells are named by their\nbarcode and variables/genes by gene name. Stores the following information:\n\n:attr:`~anndata.AnnData.X`\n    The data matrix is stored\n:attr:`~anndata.AnnData.obs_names`\n    Cell names\n:attr:`~anndata.AnnData.var_names`\n    Gene names for a feature barcode matrix, probe names for a probe bc matrix\n:attr:`~anndata.AnnData.var`\\ `['gene_ids']`\n    Gene IDs\n:attr:`~anndata.AnnData.var`\\ `['feature_types']`\n    Feature types\n:attr:`~anndata.AnnData.obs`\\ `[filtered_barcodes]`\n    filtered barcodes if present in the matrix\n:attr:`~anndata.AnnData.var`\n    Any additional metadata present in /matrix/features is read in.",
        "description": "Read 10x-Genomics-formatted hdf5 file.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_10x_h5(filename=@, genome=@, gex_only=@, backup_url=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.neighbors": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "n_neighbors": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "The size of local neighborhood (in terms of number of neighboring data\npoints) used for manifold approximation. Larger values result in more\nglobal views of the manifold, while smaller values result in more local\ndata being preserved. In general values should be in the range 2 to 100.\nIf `knn` is `True`, number of nearest neighbors to be searched. If `knn`\nis `False`, a Gaussian kernel width is set to the distance of the\n`n_neighbors` neighbor.",
                "optional_value": false
            },
            "n_pcs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use the indicated representation. `'X'` or any key for `.obsm` is valid.\nIf `None`, the representation is chosen automatically:\nFor `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\nIf 'X_pca' is not present, it\u2019s computed with default parameters.",
                "optional_value": false
            },
            "knn": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, use a hard threshold to restrict the number of neighbors to\n`n_neighbors`, that is, consider a knn graph. Otherwise, use a Gaussian\nKernel to assign low weights to neighbors more distant than the\n`n_neighbors` nearest neighbor.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "A numpy random seed.",
                "optional_value": false
            },
            "method": {
                "type": "Optional[Literal[umap, gauss, rapids]]",
                "default": "umap",
                "optional": true,
                "description": "Use 'umap' [McInnes18]_ or 'gauss' (Gauss kernel following [Coifman05]_\nwith adaptive width [Haghverdi16]_) for computing connectivities.\nUse 'rapids' for the RAPIDS implementation of UMAP (experimental, GPU\nonly).",
                "optional_value": true
            },
            "metric": {
                "type": "Union[Literal[cityblock, cosine, euclidean, l1, l2, manhattan], Literal[braycurtis, canberra, chebyshev, correlation, dice, hamming, jaccard, kulsinski, mahalanobis, minkowski, rogerstanimoto, russellrao, seuclidean, sokalmichener, sokalsneath, sqeuclidean, yule], Callable[ndarray, ndarray, float]]",
                "default": "euclidean",
                "optional": true,
                "description": "A known metric\u2019s name or a callable that returns a distance.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, the neighbors data is stored in .uns['neighbors'],\ndistances and connectivities are stored in .obsp['distances'] and\n.obsp['connectivities'] respectively.\nIf specified, the neighbors data is added to .uns[key_added],\ndistances are stored in .obsp[key_added+'_distances'] and\nconnectivities in .obsp[key_added+'_connectivities'].",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to adata.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, updates or returns `adata` with the following:\nSee `key_added` parameter description for the storage path of\nconnectivities and distances.\n**connectivities** : sparse matrix of dtype `float32`.\nWeighted adjacency matrix of the neighborhood graph of data\npoints. Weights should be interpreted as connectivities.\n**distances** : sparse matrix of dtype `float32`.\nInstead of decaying weights, this stores distances for each pair of\nneighbors.\nNotes\nIf `method='umap'`, it's highly recommended to install pynndescent ``pip install pynndescent``.\nInstalling `pynndescent` can significantly increase performance,\nand in later versions it will become a hard dependency."
        },
        "Docstring": "Compute a neighborhood graph of observations [McInnes18]_.\n\nThe neighbor search efficiency of this heavily relies on UMAP [McInnes18]_,\nwhich also provides a method for estimating connectivities of data points -\nthe connectivity of the manifold (`method=='umap'`). If `method=='gauss'`,\nconnectivities are computed according to [Coifman05]_, in the adaption of\n[Haghverdi16]_.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nn_neighbors\n    The size of local neighborhood (in terms of number of neighboring data\n    points) used for manifold approximation. Larger values result in more\n    global views of the manifold, while smaller values result in more local\n    data being preserved. In general values should be in the range 2 to 100.\n    If `knn` is `True`, number of nearest neighbors to be searched. If `knn`\n    is `False`, a Gaussian kernel width is set to the distance of the\n    `n_neighbors` neighbor.\nn_pcs\n    Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.\nuse_rep\n    Use the indicated representation. `'X'` or any key for `.obsm` is valid.\n    If `None`, the representation is chosen automatically:\n    For `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\n    If 'X_pca' is not present, it\u2019s computed with default parameters.\nknn\n    If `True`, use a hard threshold to restrict the number of neighbors to\n    `n_neighbors`, that is, consider a knn graph. Otherwise, use a Gaussian\n    Kernel to assign low weights to neighbors more distant than the\n    `n_neighbors` nearest neighbor.\nrandom_state\n    A numpy random seed.\nmethod\n    Use 'umap' [McInnes18]_ or 'gauss' (Gauss kernel following [Coifman05]_\n    with adaptive width [Haghverdi16]_) for computing connectivities.\n    Use 'rapids' for the RAPIDS implementation of UMAP (experimental, GPU\n    only).\nmetric\n    A known metric\u2019s name or a callable that returns a distance.\nmetric_kwds\n    Options for the metric.\nkey_added\n    If not specified, the neighbors data is stored in .uns['neighbors'],\n    distances and connectivities are stored in .obsp['distances'] and\n    .obsp['connectivities'] respectively.\n    If specified, the neighbors data is added to .uns[key_added],\n    distances are stored in .obsp[key_added+'_distances'] and\n    connectivities in .obsp[key_added+'_connectivities'].\ncopy\n    Return a copy instead of writing to adata.\n\nReturns\n-------\nDepending on `copy`, updates or returns `adata` with the following:\n\nSee `key_added` parameter description for the storage path of\nconnectivities and distances.\n\n**connectivities** : sparse matrix of dtype `float32`.\n    Weighted adjacency matrix of the neighborhood graph of data\n    points. Weights should be interpreted as connectivities.\n**distances** : sparse matrix of dtype `float32`.\n    Instead of decaying weights, this stores distances for each pair of\n    neighbors.\n\nNotes\n-----\nIf `method='umap'`, it's highly recommended to install pynndescent ``pip install pynndescent``.\nInstalling `pynndescent` can significantly increase performance,\nand in later versions it will become a hard dependency.",
        "description": "Compute a neighborhood graph of observations [McInnes18]_.The neighbor search efficiency of this heavily relies on UMAP [McInnes18]_,\nwhich also provides a method for estimating connectivities of data points -\nthe connectivity of the manifold (`method=='umap'`). If `method=='gauss'`,\nconnectivities are computed according to [Coifman05]_, in the adaption of\n[Haghverdi16]_.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.neighbors(adata=$, n_neighbors=@, n_pcs=@, use_rep=@, knn=@, random_state=@, method=$, metric=@, key_added=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
                "optional_value": false
            },
            "categories_order": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Order in which to show the categories. Note: add_dendrogram or add_totals\ncan change the categories order.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`.\nOtherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Literal[var, group]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize a dimension between 0 and 1,\nmeaning for each variable or observation,\nsubtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Stacked violin plots.\n\nMakes a compact image composed of individual violin plots\n(from :func:`~seaborn.violinplot`) stacked on top of each other.\nUseful to visualize gene expression per cluster.\n\nWraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nvar_names\n    `var_names` should be a valid subset of `adata.var_names`.\n    If `var_names` is a mapping, then the key is used as label\n    to group the values (see `var_group_labels`). The mapping values\n    should be sequences of valid `adata.var_names`. In this\n    case either coloring or 'brackets' are used for the grouping\n    of var names depending on the plot. When `var_names` is a mapping,\n    then the `var_group_labels` and `var_group_positions` are set.\ngroupby\n    The key of the observation grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlog\n    Plot on logarithmic axis.\nnum_categories\n    Only used if groupby observation is not categorical. This value\n    determines the number of groups into which the groupby observation\n    should be subdivided.\ncategories_order\n    Order in which to show the categories. Note: add_dendrogram or add_totals\n    can change the categories order.\nfigsize\n    Figure size when `multi_panel=True`.\n    Otherwise the `rcParam['figure.figsize]` value is used.\n    Format is (width, height)\ndendrogram\n    If True or a valid dendrogram key, a dendrogram based on the hierarchical\n    clustering between the `groupby` categories is added.\n    The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n    If `tl.dendrogram` has not been called previously the function is called\n    with default parameters.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols.\n    By default `var_names` refer to the index column of the `.var` DataFrame.\n    Setting this option allows alternative names to be used.\nvar_group_positions\n    Use this parameter to highlight groups of `var_names`.\n    This will draw a 'bracket' or a color block between the given start and end\n    positions. If the parameter `var_group_labels` is set, the corresponding\n    labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n    will add a bracket between the fourth `var_name` and the tenth `var_name`.\n    By giving more positions, more brackets/color blocks are drawn.\nvar_group_labels\n    Labels for each of the `var_group_positions` that want to be highlighted.\nvar_group_rotation\n    Label rotation degrees.\n    By default, labels larger than 4 characters are rotated 90 degrees.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n    If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\ntitle\n    Title for the figure\nstripplot\n    Add a stripplot on top of the violin plot.\n    See :func:`~seaborn.stripplot`.\njitter\n    Add jitter to the stripplot (only when stripplot is True)\n    See :func:`~seaborn.stripplot`.\nsize\n    Size of the jitter points.\norder\n    Order in which to show the categories. Note: if `dendrogram=True`\n    the categories order will be given by the dendrogram and `order`\n    will be ignored.\nscale\n    The method used to scale the width of each violin.\n    If 'width' (the default), each violin will have the same width.\n    If 'area', each violin will have the same area.\n    If 'count', a violin\u2019s width corresponds to the number of observations.\nrow_palette\n    The row palette determines the colors to use for the stacked violins.\n    The value should be a valid seaborn or matplotlib palette name\n    (see :func:`~seaborn.color_palette`).\n    Alternatively, a single color name or hex value can be passed,\n    e.g. `'red'` or `'#cc33ff'`.\nstandard_scale\n    Whether or not to standardize a dimension between 0 and 1,\n    meaning for each variable or observation,\n    subtract the minimum and divide each by its maximum.\nswap_axes\n     By default, the x axis contains `var_names` (e.g. genes) and the y axis\n     the `groupby` categories. By setting `swap_axes` then x are the `groupby`\n     categories and y the `var_names`. When swapping\n     axes var_group_positions are no longer used\nkwds\n    Are passed to :func:`~seaborn.violinplot`.\n\n\nSee also\n--------\n:func:`~scanpy.pl.stacked_violin`: simpler way to call StackedViolin but with less\n    options.\n:func:`~scanpy.pl.violin` and :func:`~scanpy.pl.rank_genes_groups_stacked_violin`:\n    to plot marker genes identified using :func:`~scanpy.tl.rank_genes_groups`\n\nExamples\n-------\n\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.StackedViolin(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nUsing var_names as dict:\n\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.StackedViolin(adata, markers, groupby='bulk_labels', dendrogram=True)",
        "description": "Stacked violin plots.Makes a compact image composed of individual violin plots\n(from :func:`~seaborn.violinplot`) stacked on top of each other.\nUseful to visualize gene expression per cluster.\n\nWraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.",
        "example": "Examples\n-------\n\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.StackedViolin(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nUsing var_names as dict:\n\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.StackedViolin(adata, markers, groupby='bulk_labels', dendrogram=True)",
        "api_type": "class",
        "api_calling": [
            "scanpy.pl.StackedViolin(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, categories_order=@, title=@, figsize=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, standard_scale=$, ax=$, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin.add_dendrogram": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'add_dendrogram'",
                "optional_value": false
            },
            "dendrogram_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Needed if `sc.tl.dendrogram` saved the dendrogram using a key different\nthan the default name.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[float]",
                "default": "0.8",
                "optional": true,
                "description": "size of the dendrogram. Corresponds to width when dendrogram shown on\nthe right of the plot, or height when shown on top. The unit is the same\nas in matplotlib (inches).",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Show dendrogram based on the hierarchical clustering between the `groupby`\ncategories. Categories are reordered to match the dendrogram order.\n\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `sc.tl.dendrogram` has not been called previously the function is called\nwith default parameters.\n\nThe dendrogram is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n`var_names` are reordered to produce a more pleasing output if:\n    * The data contains `var_groups`\n    * the `var_groups` match the categories.\n\nThe previous conditions happen by default when using Plot\nto show the results from :func:`~scanpy.tl.rank_genes_groups` (aka gene markers), by\ncalling `scanpy.tl.rank_genes_groups_(plot_name)`.\n\n\nParameters\n----------\nshow\n    Boolean to turn on (True) or off (False) 'add_dendrogram'\ndendrogram_key\n    Needed if `sc.tl.dendrogram` saved the dendrogram using a key different\n    than the default name.\nsize\n    size of the dendrogram. Corresponds to width when dendrogram shown on\n    the right of the plot, or height when shown on top. The unit is the same\n    as in matplotlib (inches).\n\nReturns\n-------\nBasePlot\n\n\nExamples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_dendrogram().show()",
        "description": "Show dendrogram based on the hierarchical clustering between the `groupby`categories. Categories are reordered to match the dendrogram order.\n\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `sc.tl.dendrogram` has not been called previously the function is called\nwith default parameters.\n\nThe dendrogram is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n`var_names` are reordered to produce a more pleasing output if:\n    * The data contains `var_groups`\n    * the `var_groups` match the categories.\n\nThe previous conditions happen by default when using Plot\nto show the results from :func:`~scanpy.tl.rank_genes_groups` (aka gene markers), by\ncalling `scanpy.tl.rank_genes_groups_(plot_name)`.",
        "example": "Examples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_dendrogram().show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.StackedViolin.add_dendrogram(show=@, dendrogram_key=@, size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin.add_totals": {
        "Parameters": {
            "show": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "Boolean to turn on (True) or off (False) 'add_totals'",
                "optional_value": false
            },
            "sort": {
                "type": "Literal[ascending, descending]",
                "default": "None",
                "optional": true,
                "description": "Set to either 'ascending' or 'descending' to reorder the categories\nby cell number",
                "optional_value": true
            },
            "size": {
                "type": "Optional[float]",
                "default": "0.8",
                "optional": true,
                "description": "size of the barplot. Corresponds to width when shown on\nthe right of the plot, or height when shown on top. The unit is the same\nas in matplotlib (inches).",
                "optional_value": false
            },
            "color": {
                "type": "Optional[Union[str, tuple[float, Ellipsis], Sequence[Union[str, tuple[float, Ellipsis]]]]]",
                "default": "None",
                "optional": true,
                "description": "Color for the bar plots or list of colors for each of the bar plots.\nBy default, each bar plot uses the colors assigned in\n`adata.uns[{groupby}_colors]`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "BasePlot"
        },
        "Docstring": "Show barplot for the number of cells in in `groupby` category.\n\nThe barplot is by default shown on the right side of the plot or on top\nif the axes are swapped.\n\n\nParameters\n----------\nshow\n    Boolean to turn on (True) or off (False) 'add_totals'\nsort\n    Set to either 'ascending' or 'descending' to reorder the categories\n    by cell number\nsize\n    size of the barplot. Corresponds to width when shown on\n    the right of the plot, or height when shown on top. The unit is the same\n    as in matplotlib (inches).\ncolor\n    Color for the bar plots or list of colors for each of the bar plots.\n    By default, each bar plot uses the colors assigned in\n    `adata.uns[{groupby}_colors]`.\n\n\nReturns\n-------\nBasePlot\n\n\nExamples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_totals().show()",
        "description": "Show barplot for the number of cells in in `groupby` category.The barplot is by default shown on the right side of the plot or on top\nif the axes are swapped.",
        "example": "Examples\n--------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').add_totals().show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.StackedViolin.add_totals(show=@, sort=$, size=@, color=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin.savefig": {
        "Parameters": {
            "filename": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Figure filename. Figure *format* is taken from the file ending unless\nthe parameter `format` is given.",
                "optional_value": false
            },
            "bbox_inches": {
                "type": "Optional[str]",
                "default": "tight",
                "optional": true,
                "description": "By default is set to 'tight' to avoid cropping of the legends.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Save the current figure\n\nParameters\n----------\nfilename\n    Figure filename. Figure *format* is taken from the file ending unless\n    the parameter `format` is given.\nbbox_inches\n    By default is set to 'tight' to avoid cropping of the legends.\nkwargs\n    Passed to :func:`matplotlib.pyplot.savefig`\n\nSee also\n--------\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`show()`: Renders and shows the plot\n\nExamples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').savefig('plot.pdf')",
        "description": "Save the current figure",
        "example": "Examples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').savefig('plot.pdf')",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.StackedViolin.savefig(filename=@, bbox_inches=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.StackedViolin.show": {
        "Parameters": {
            "return_axes": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If true return a dictionary with the figure axes. When return_axes is true\nthen :func:`matplotlib.pyplot.show` is not called.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `return_axes=True`: Dict of :class:`matplotlib.axes.Axes`. The dict key\nindicates the type of ax (eg. `mainplot_ax`)\nSee also\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`savefig()`: Saves the plot."
        },
        "Docstring": "Show the figure\n\nParameters\n----------\nreturn_axes\n     If true return a dictionary with the figure axes. When return_axes is true\n     then :func:`matplotlib.pyplot.show` is not called.\n\nReturns\n-------\nIf `return_axes=True`: Dict of :class:`matplotlib.axes.Axes`. The dict key\nindicates the type of ax (eg. `mainplot_ax`)\n\nSee also\n--------\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`savefig()`: Saves the plot.\n\nExamples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.Plot(adata, markers, groupby='bulk_labels').show()",
        "description": "Show the figure",
        "example": "Examples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.Plot(adata, markers, groupby='bulk_labels').show()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.StackedViolin.show(return_axes=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.sim": {
        "Parameters": {
            "adata": {
                "type": null,
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "tmax_realization": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of observations in one realization of the time series. The data matrix\nadata.X consists in concatenated realizations.",
                "optional_value": false
            },
            "as_heatmap": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot the timeseries as heatmap.",
                "optional_value": false
            },
            "shuffle": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Shuffle the data.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {{`'.pdf'`, `'.png'`, `'.svg'`}}.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot results of simulation.\n\nParameters\n----------\ntmax_realization\n    Number of observations in one realization of the time series. The data matrix\n    adata.X consists in concatenated realizations.\nas_heatmap\n    Plot the timeseries as heatmap.\nshuffle\n    Shuffle the data.\nshow\n    Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {{`'.pdf'`, `'.png'`, `'.svg'`}}.",
        "description": "Plot results of simulation.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.sim(adata=$, tmax_realization=@, as_heatmap=@, shuffle=@, show=@, save=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.dendrogram": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix",
                "optional_value": true
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": false
            },
            "n_pcs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use the indicated representation. `'X'` or any key for `.obsm` is valid.\nIf `None`, the representation is chosen automatically:\nFor `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\nIf 'X_pca' is not present, it\u2019s computed with default parameters.",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of var_names to use for computing the hierarchical clustering.\nIf `var_names` is given, then `use_rep` and `n_pcs` is ignored.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Only when `var_names` is not None.\nUse `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "cor_method": {
                "type": "str",
                "default": "pearson",
                "optional": true,
                "description": "correlation method to use.\nOptions are 'pearson', 'kendall', and 'spearman'",
                "optional_value": false
            },
            "linkage_method": {
                "type": "str",
                "default": "complete",
                "optional": true,
                "description": "linkage method to use. See :func:`scipy.cluster.hierarchy.linkage`\nfor more information.",
                "optional_value": false
            },
            "optimal_ordering": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Same as the optimal_ordering argument of :func:`scipy.cluster.hierarchy.linkage`\nwhich reorders the linkage matrix so that the distance between successive\nleaves is minimal.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "By default, the dendrogram information is added to\n`.uns[f'dendrogram_{groupby}']`.\nNotice that the `groupby` information is added to the dendrogram.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, adds dendrogram information to `adata.uns[key_added]`,\nelse this function returns the information.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Dict[str, Any]]",
            "description": "If `inplace=False`, returns dendrogram information,\nelse `adata.uns[key_added]` is updated with it."
        },
        "Docstring": "Computes a hierarchical clustering for the given `groupby` categories.\n\nBy default, the PCA representation is used unless `.X`\nhas less than 50 variables.\n\nAlternatively, a list of `var_names` (e.g. genes) can be given.\n\nAverage values of either `var_names` or components are used\nto compute a correlation matrix.\n\nThe hierarchical clustering can be visualized using\n:func:`scanpy.pl.dendrogram` or multiple other visualizations that can\ninclude a dendrogram: :func:`~scanpy.pl.matrixplot`,\n:func:`~scanpy.pl.heatmap`, :func:`~scanpy.pl.dotplot`,\nand :func:`~scanpy.pl.stacked_violin`.\n\n.. note::\n    The computation of the hierarchical clustering is based on predefined\n    groups and not per cell. The correlation matrix is computed using by\n    default pearson but other methods are available.\n\nParameters\n----------\nadata\n    Annotated data matrix\nn_pcs\n    Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.\nuse_rep\n    Use the indicated representation. `'X'` or any key for `.obsm` is valid.\n    If `None`, the representation is chosen automatically:\n    For `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\n    If 'X_pca' is not present, it\u2019s computed with default parameters.\nvar_names\n    List of var_names to use for computing the hierarchical clustering.\n    If `var_names` is given, then `use_rep` and `n_pcs` is ignored.\nuse_raw\n    Only when `var_names` is not None.\n    Use `raw` attribute of `adata` if present.\ncor_method\n    correlation method to use.\n    Options are 'pearson', 'kendall', and 'spearman'\nlinkage_method\n    linkage method to use. See :func:`scipy.cluster.hierarchy.linkage`\n    for more information.\noptimal_ordering\n    Same as the optimal_ordering argument of :func:`scipy.cluster.hierarchy.linkage`\n    which reorders the linkage matrix so that the distance between successive\n    leaves is minimal.\nkey_added\n    By default, the dendrogram information is added to\n    `.uns[f'dendrogram_{groupby}']`.\n    Notice that the `groupby` information is added to the dendrogram.\ninplace\n    If `True`, adds dendrogram information to `adata.uns[key_added]`,\n    else this function returns the information.\n\nReturns\n-------\nIf `inplace=False`, returns dendrogram information,\nelse `adata.uns[key_added]` is updated with it.\n\nExamples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.dendrogram(adata, groupby='bulk_labels')\n>>> sc.pl.dendrogram(adata)\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.dotplot(adata, markers, groupby='bulk_labels', dendrogram=True)",
        "description": "Computes a hierarchical clustering for the given `groupby` categories.By default, the PCA representation is used unless `.X`\nhas less than 50 variables.\n\nAlternatively, a list of `var_names` (e.g. genes) can be given.\n\nAverage values of either `var_names` or components are used\nto compute a correlation matrix.\n\nThe hierarchical clustering can be visualized using\n:func:`scanpy.pl.dendrogram` or multiple other visualizations that can\ninclude a dendrogram: :func:`~scanpy.pl.matrixplot`,\n:func:`~scanpy.pl.heatmap`, :func:`~scanpy.pl.dotplot`,\nand :func:`~scanpy.pl.stacked_violin`.\n\n.. note::\n    The computation of the hierarchical clustering is based on predefined\n    groups and not per cell. The correlation matrix is computed using by\n    default pearson but other methods are available.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.dendrogram(adata, groupby='bulk_labels')\n>>> sc.pl.dendrogram(adata)\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.dotplot(adata, markers, groupby='bulk_labels', dendrogram=True)",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.dendrogram(adata=$, groupby=@, n_pcs=@, use_rep=@, var_names=@, use_raw=@, cor_method=@, linkage_method=@, optimal_ordering=@, key_added=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.score_genes_cell_cycle": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "s_genes": {
                "type": "Sequence[str]",
                "default": null,
                "optional": false,
                "description": "List of genes associated with S phase.",
                "optional_value": false
            },
            "g2m_genes": {
                "type": "Sequence[str]",
                "default": null,
                "optional": false,
                "description": "List of genes associated with G2M phase.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Copy `adata` or modify it inplace.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `adata` with the following fields.\n**S_score** : `adata.obs`, dtype `object`\nThe score for S phase for each cell.\n**G2M_score** : `adata.obs`, dtype `object`\nThe score for G2M phase for each cell.\n**phase** : `adata.obs`, dtype `object`\nThe cell cycle phase (`S`, `G2M` or `G1`) for each cell.\nSee also\nscore_genes"
        },
        "Docstring": "Score cell cycle genes [Satija15]_.\n\nGiven two lists of genes associated to S phase and G2M phase, calculates\nscores and assigns a cell cycle phase (G1, S or G2M). See\n:func:`~scanpy.tl.score_genes` for more explanation.\n\nParameters\n----------\nadata\n    The annotated data matrix.\ns_genes\n    List of genes associated with S phase.\ng2m_genes\n    List of genes associated with G2M phase.\ncopy\n    Copy `adata` or modify it inplace.\n**kwargs\n    Are passed to :func:`~scanpy.tl.score_genes`. `ctrl_size` is not\n    possible, as it's set as `min(len(s_genes), len(g2m_genes))`.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields.\n\n**S_score** : `adata.obs`, dtype `object`\n    The score for S phase for each cell.\n**G2M_score** : `adata.obs`, dtype `object`\n    The score for G2M phase for each cell.\n**phase** : `adata.obs`, dtype `object`\n    The cell cycle phase (`S`, `G2M` or `G1`) for each cell.\n\nSee also\n--------\nscore_genes\n\nExamples\n--------\nSee this `notebook <https://github.com/scverse/scanpy_usage/tree/master/180209_cell_cycle>`__.",
        "description": "Score cell cycle genes [Satija15]_.Given two lists of genes associated to S phase and G2M phase, calculates\nscores and assigns a cell cycle phase (G1, S or G2M). See\n:func:`~scanpy.tl.score_genes` for more explanation.",
        "example": "Examples\n--------\nSee this `notebook <https://github.com/scverse/scanpy_usage/tree/master/180209_cell_cycle>`__.",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.score_genes_cell_cycle(adata=$, s_genes=@, g2m_genes=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.matrixplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`.\nOtherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called\nwith default parameters.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[str]",
                "default": "viridis",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "colorbar_title": {
                "type": "Optional[str]",
                "default": "Mean expression\nin group",
                "optional": true,
                "description": "Title for the color bar. New line character (\\n) can be used.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Literal[var, group]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "values_df": {
                "type": "Optional[DataFrame]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "swap_axes": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "By default, the x axis contains `var_names` (e.g. genes) and the y axis\nthe `groupby` categories. By setting `swap_axes` then x are the\n`groupby` categories and y the `var_names`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`DotPlot` object. Useful for fine-tuning\nthe plot. Takes precedence over `show=False`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. Values larger than vmax are plotted\nwith the same color as vmax.",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "Custom color normalization object from matplotlib. See\n`https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[MatrixPlot, dict]]",
            "description": "If `return_fig` is `True`, returns a :class:`~scanpy.pl.MatrixPlot` object,\nelse if `show` is false, return axes dict\nSee also\n:class:`~scanpy.pl.MatrixPlot`: The MatrixPlot class can be used to to control\nseveral visual parameters not available in this function.\n:func:`~scanpy.pl.rank_genes_groups_matrixplot`: to plot marker genes\nidentified using the :func:`~scanpy.tl.rank_genes_groups` function."
        },
        "Docstring": "Creates a heatmap of the mean expression values per group of each var_names.\n\nThis function provides a convenient interface to the :class:`~scanpy.pl.MatrixPlot`\nclass. If you need more flexibility, you should use :class:`~scanpy.pl.MatrixPlot`\ndirectly.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nvar_names\n    `var_names` should be a valid subset of `adata.var_names`.\n    If `var_names` is a mapping, then the key is used as label\n    to group the values (see `var_group_labels`). The mapping values\n    should be sequences of valid `adata.var_names`. In this\n    case either coloring or 'brackets' are used for the grouping\n    of var names depending on the plot. When `var_names` is a mapping,\n    then the `var_group_labels` and `var_group_positions` are set.\ngroupby\n    The key of the observation grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlog\n    Plot on logarithmic axis.\nnum_categories\n    Only used if groupby observation is not categorical. This value\n    determines the number of groups into which the groupby observation\n    should be subdivided.\ncategories_order\n    Order in which to show the categories. Note: add_dendrogram or add_totals\n    can change the categories order.\nfigsize\n    Figure size when `multi_panel=True`.\n    Otherwise the `rcParam['figure.figsize]` value is used.\n    Format is (width, height)\ndendrogram\n    If True or a valid dendrogram key, a dendrogram based on the hierarchical\n    clustering between the `groupby` categories is added.\n    The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n    If `tl.dendrogram` has not been called previously the function is called\n    with default parameters.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols.\n    By default `var_names` refer to the index column of the `.var` DataFrame.\n    Setting this option allows alternative names to be used.\nvar_group_positions\n    Use this parameter to highlight groups of `var_names`.\n    This will draw a 'bracket' or a color block between the given start and end\n    positions. If the parameter `var_group_labels` is set, the corresponding\n    labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n    will add a bracket between the fourth `var_name` and the tenth `var_name`.\n    By giving more positions, more brackets/color blocks are drawn.\nvar_group_labels\n    Labels for each of the `var_group_positions` that want to be highlighted.\nvar_group_rotation\n    Label rotation degrees.\n    By default, labels larger than 4 characters are rotated 90 degrees.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n    If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\ntitle\n    Title for the figure\ncolorbar_title\n    Title for the color bar. New line character (\\n) can be used.\ncmap\n    String denoting matplotlib color map.\nstandard_scale\n    Whether or not to standardize the given dimension between 0 and 1, meaning for\n    each variable or group, subtract the minimum and divide each by its maximum.\nswap_axes\n     By default, the x axis contains `var_names` (e.g. genes) and the y axis\n     the `groupby` categories. By setting `swap_axes` then x are the\n     `groupby` categories and y the `var_names`.\nreturn_fig\n    Returns :class:`DotPlot` object. Useful for fine-tuning\n    the plot. Takes precedence over `show=False`.\n\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin.\nvmax\n    The value representing the upper limit of the color scale. Values larger than vmax are plotted\n    with the same color as vmax.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\nnorm\n    Custom color normalization object from matplotlib. See\n    `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.\nkwds\n    Are passed to :func:`matplotlib.pyplot.pcolor`.\n\nReturns\n-------\nIf `return_fig` is `True`, returns a :class:`~scanpy.pl.MatrixPlot` object,\nelse if `show` is false, return axes dict\n\nSee also\n--------\n:class:`~scanpy.pl.MatrixPlot`: The MatrixPlot class can be used to to control\n    several visual parameters not available in this function.\n:func:`~scanpy.pl.rank_genes_groups_matrixplot`: to plot marker genes\n    identified using the :func:`~scanpy.tl.rank_genes_groups` function.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.matrixplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nUsing var_names as dict:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.matrixplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nGet Matrix object for fine tuning:\n\n.. plot::\n    :context: close-figs\n\n    mp = sc.pl.matrixplot(adata, markers, 'bulk_labels', return_fig=True)\n    mp.add_totals().style(edge_color='black').show()\n\nThe axes used can be obtained using the get_axes() method\n\n.. plot::\n    :context: close-figs\n\n    axes_dict = mp.get_axes()",
        "description": "Creates a heatmap of the mean expression values per group of each var_names.This function provides a convenient interface to the :class:`~scanpy.pl.MatrixPlot`\nclass. If you need more flexibility, you should use :class:`~scanpy.pl.MatrixPlot`\ndirectly.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.matrixplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nUsing var_names as dict:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.matrixplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nGet Matrix object for fine tuning:\n\n.. plot::\n    :context: close-figs\n\n    mp = sc.pl.matrixplot(adata, markers, 'bulk_labels', return_fig=True)\n    mp.add_totals().style(edge_color='black').show()\n\nThe axes used can be obtained using the get_axes() method\n\n.. plot::\n    :context: close-figs\n\n    axes_dict = mp.get_axes()",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.matrixplot(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, figsize=@, dendrogram=@, title=@, cmap=@, colorbar_title=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, standard_scale=$, values_df=$, swap_axes=@, show=@, save=@, ax=$, return_fig=@, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.dendrogram": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Categorical data column used to create the dendrogram",
                "optional_value": false
            },
            "dendrogram_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key under with the dendrogram information was stored.\nBy default the dendrogram information is stored under\n`.uns[f'dendrogram_{groupby}']`.",
                "optional_value": false
            },
            "orientation": {
                "type": "Literal[top, bottom, left, right]",
                "default": "top",
                "optional": true,
                "description": "Origin of the tree. Will grow into the opposite direction.",
                "optional_value": true
            },
            "remove_labels": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Don\u2019t draw labels. Used e.g. by :func:`scanpy.pl.matrixplot`\nto annotate matrix columns/rows.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ":class:`matplotlib.axes.Axes`"
        },
        "Docstring": "Plots a dendrogram of the categories defined in `groupby`.\n\nSee :func:`~scanpy.tl.dendrogram`.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroupby\n    Categorical data column used to create the dendrogram\ndendrogram_key\n    Key under with the dendrogram information was stored.\n    By default the dendrogram information is stored under\n    `.uns[f'dendrogram_{groupby}']`.\norientation\n    Origin of the tree. Will grow into the opposite direction.\nremove_labels\n    Don\u2019t draw labels. Used e.g. by :func:`scanpy.pl.matrixplot`\n    to annotate matrix columns/rows.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\n:class:`matplotlib.axes.Axes`\n\nExamples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.dendrogram(adata, 'bulk_labels')\n    sc.pl.dendrogram(adata, 'bulk_labels')\n\n.. currentmodule:: scanpy",
        "description": "Plots a dendrogram of the categories defined in `groupby`.See :func:`~scanpy.tl.dendrogram`.",
        "example": "Examples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.dendrogram(adata, 'bulk_labels')\n    sc.pl.dendrogram(adata, 'bulk_labels')\n\n.. currentmodule:: scanpy",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.dendrogram(adata=$, groupby=@, dendrogram_key=@, orientation=$, remove_labels=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.umap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show edges.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Width of edges.",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Union[str, tuple[float, Ellipsis]]",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, List[Axes]]]",
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot in UMAP basis.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nedges\n    Show edges.\nedges_width\n    Width of edges.\nedges_color\n    Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\nneighbors_key\n    Where to look for neighbors connectivities.\n    If not specified, this looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, this looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\narrows\n    Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\narrows_kwds\n    Passed to :meth:`~matplotlib.axes.Axes.quiver`\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.pl.umap(adata)\n\nColour points by discrete variable (Louvain clusters).\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.umap(adata, color=\"louvain\")\n\nColour points by gene expression.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.umap(adata, color=\"HES4\")\n\nPlot muliple umaps for different gene expressions.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.umap(adata, color=[\"HES4\", \"TNFRSF4\"])\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.umap",
        "description": "Scatter plot in UMAP basis.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.pl.umap(adata)\n\nColour points by discrete variable (Louvain clusters).\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.umap(adata, color=\"louvain\")\n\nColour points by gene expression.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.umap(adata, color=\"HES4\")\n\nPlot muliple umaps for different gene expressions.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.umap(adata, color=[\"HES4\", \"TNFRSF4\"])\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.umap",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.umap(adata=$, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.exporting.cellbrowser": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix",
                "optional_value": true
            },
            "data_dir": {
                "type": "Union[Path, str]",
                "default": null,
                "optional": false,
                "description": "Path to directory for exported Cell Browser files.\nUsually these are the files `exprMatrix.tsv.gz`, `meta.tsv`,\ncoordinate files like `tsne.coords.tsv`,\nand cluster marker gene lists like `markers.tsv`.\nA file `cellbrowser.conf` is also created with pointers to these files.\nAs a result, each adata object should have its own project_dir.",
                "optional_value": false
            },
            "data_name": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Name of dataset in Cell Browser, a string without special characters.\nThis is written to `data_dir/cellbrowser.conf`.\nIdeally this is a short unique name for the dataset,\nlike `\"pbmc3k\"` or `\"tabulamuris\"`.",
                "optional_value": false
            },
            "embedding_keys": {
                "type": "Optional[Union[Iterable[str], Mapping[str, str], str]]",
                "default": "None",
                "optional": true,
                "description": "2-D embeddings in `adata.obsm` to export.\nThe prefix `X_` or `X_draw_graph_` is not necessary.\nCoordinates missing from `adata` are skipped.\nBy default (or when specifying `'all'` or `None`), these keys are tried:\n[`\"tsne\"`, `\"umap\"`, `\"pagaFa\"`, `\"pagaFr\"`, `\"pagaUmap\"`, `\"phate\"`,\n`\"fa\"`, `\"fr\"`, `\"kk\"`, `\"drl\"`, `\"rt\"`, `\"trimap\"`].\nFor these, default display labels are automatically used.\nFor other values, you can specify a mapping from coordinate name to\ndisplay label, e.g. `{\"tsne\": \"t-SNE by Scanpy\"}`.",
                "optional_value": false
            },
            "annot_keys": {
                "type": "Optional[Union[Iterable[str], Mapping[str, str]]]",
                "default": "('louvain', 'percent_mito', 'n_genes', 'n_counts')",
                "optional": true,
                "description": "Annotations in `adata.obsm` to export.\nCan be a mapping from annotation column name to display label.\nSpecify `None` for all available columns in `.obs`.",
                "optional_value": false
            },
            "cluster_field": {
                "type": "str",
                "default": "louvain",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "nb_marker": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "skip_matrix": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Do not export the matrix.\nIf you had previously exported this adata into the same `data_dir`,\nthen there is no need to export the whole matrix again.\nThis option will make the export a lot faster,\ne.g. when only coordinates or meta data were changed.",
                "optional_value": false
            },
            "html_dir": {
                "type": "Optional[Union[Path, str]]",
                "default": "None",
                "optional": true,
                "description": "If this variable is set, the export will build html\nfiles from `data_dir` to `html_dir`, creating html/js/json files.\nUsually there is one global html output directory for all datasets.\nOften, `html_dir` is located under a webserver's (like Apache)\nhtdocs directory or is copied to one.\nA directory `html_dir`/`project_name` will be created and\nan index.html will be created under `html_dir` for all subdirectories.\nExisting files will be overwritten.\nIf do not to use html_dir,\nyou can use the command line tool `cbBuild` to build the html directory.",
                "optional_value": false
            },
            "port": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "If this variable and `html_dir` are set,\nPython's built-in web server will be spawned as a daemon in the\nbackground and serve the files under `html_dir`.\nTo kill the process, call `cellbrowser.cellbrowser.stop()`.",
                "optional_value": false
            },
            "do_debug": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Activate debugging output",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Export adata to a UCSC Cell Browser project directory. If `html_dir` is\nset, subsequently build the html files from the project directory into\n`html_dir`. If `port` is set, start an HTTP server in the background and\nserve `html_dir` on `port`.\n\nBy default, export all gene expression data from `adata.raw`, the\nannotations `louvain`, `percent_mito`, `n_genes` and `n_counts` and the top\n`nb_marker` cluster markers. All existing files in data_dir are\noverwritten, except `cellbrowser.conf`.\n\nSee `UCSC Cellbrowser <https://github.com/maximilianh/cellBrowser>`__ for\ndetails.\n\nParameters\n----------\nadata\n    Annotated data matrix\ndata_dir\n    Path to directory for exported Cell Browser files.\n    Usually these are the files `exprMatrix.tsv.gz`, `meta.tsv`,\n    coordinate files like `tsne.coords.tsv`,\n    and cluster marker gene lists like `markers.tsv`.\n    A file `cellbrowser.conf` is also created with pointers to these files.\n    As a result, each adata object should have its own project_dir.\ndata_name\n    Name of dataset in Cell Browser, a string without special characters.\n    This is written to `data_dir/cellbrowser.conf`.\n    Ideally this is a short unique name for the dataset,\n    like `\"pbmc3k\"` or `\"tabulamuris\"`.\nembedding_keys\n    2-D embeddings in `adata.obsm` to export.\n    The prefix `X_` or `X_draw_graph_` is not necessary.\n    Coordinates missing from `adata` are skipped.\n    By default (or when specifying `'all'` or `None`), these keys are tried:\n    [`\"tsne\"`, `\"umap\"`, `\"pagaFa\"`, `\"pagaFr\"`, `\"pagaUmap\"`, `\"phate\"`,\n    `\"fa\"`, `\"fr\"`, `\"kk\"`, `\"drl\"`, `\"rt\"`, `\"trimap\"`].\n    For these, default display labels are automatically used.\n    For other values, you can specify a mapping from coordinate name to\n    display label, e.g. `{\"tsne\": \"t-SNE by Scanpy\"}`.\nannot_keys\n    Annotations in `adata.obsm` to export.\n    Can be a mapping from annotation column name to display label.\n    Specify `None` for all available columns in `.obs`.\nskip_matrix\n    Do not export the matrix.\n    If you had previously exported this adata into the same `data_dir`,\n    then there is no need to export the whole matrix again.\n    This option will make the export a lot faster,\n    e.g. when only coordinates or meta data were changed.\nhtml_dir\n    If this variable is set, the export will build html\n    files from `data_dir` to `html_dir`, creating html/js/json files.\n    Usually there is one global html output directory for all datasets.\n    Often, `html_dir` is located under a webserver's (like Apache)\n    htdocs directory or is copied to one.\n    A directory `html_dir`/`project_name` will be created and\n    an index.html will be created under `html_dir` for all subdirectories.\n    Existing files will be overwritten.\n    If do not to use html_dir,\n    you can use the command line tool `cbBuild` to build the html directory.\nport\n    If this variable and `html_dir` are set,\n    Python's built-in web server will be spawned as a daemon in the\n    background and serve the files under `html_dir`.\n    To kill the process, call `cellbrowser.cellbrowser.stop()`.\ndo_debug\n    Activate debugging output\n\nExamples\n--------\nSee this\n`tutorial <https://github.com/scverse/scanpy_usage/tree/master/181126_Cellbrowser_exports>`__.",
        "description": "Export adata to a UCSC Cell Browser project directory. If `html_dir` isset, subsequently build the html files from the project directory into\n`html_dir`. If `port` is set, start an HTTP server in the background and\nserve `html_dir` on `port`.\n\nBy default, export all gene expression data from `adata.raw`, the\nannotations `louvain`, `percent_mito`, `n_genes` and `n_counts` and the top\n`nb_marker` cluster markers. All existing files in data_dir are\noverwritten, except `cellbrowser.conf`.\n\nSee `UCSC Cellbrowser <https://github.com/maximilianh/cellBrowser>`__ for\ndetails.",
        "example": "Examples\n--------\nSee this\n`tutorial <https://github.com/scverse/scanpy_usage/tree/master/181126_Cellbrowser_exports>`__.",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.exporting.cellbrowser(adata=$, data_dir=@, data_name=@, embedding_keys=@, annot_keys=@, cluster_field=@, nb_marker=@, skip_matrix=@, html_dir=@, port=@, do_debug=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.hashsolo": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "cell_hashing_columns": {
                "type": "list",
                "default": null,
                "optional": false,
                "description": "A list specifying `.obs` columns that contain cell hashing counts.",
                "optional_value": false
            },
            "priors": {
                "type": "list",
                "default": "[0.01, 0.8, 0.19]",
                "optional": true,
                "description": "A list specifying the prior probability of each hypothesis, in\nthe order `[negative, singlet, doublet]`. The default is set to\n`[0.01, 0.8, 0.19]` assuming barcode counts are from cells that\nhave passed QC in the transcriptome space, e.g. UMI counts, pct\nmito reads, etc.",
                "optional_value": false
            },
            "pre_existing_clusters": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "The column in `.obs` containing pre-existing cluster assignments\n(e.g. Leiden clusters or cell types, but not batch assignments).\nIf provided, demultiplexing will be performed separately for each\ncluster.",
                "optional_value": false
            },
            "number_of_noise_barcodes": {
                "type": "int",
                "default": "None",
                "optional": true,
                "description": "The number of barcodes used to create the noise distribution.\nDefaults to `len(cell_hashing_columns) - 2`.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to update `adata` in-place or return a copy.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "adata : anndata.AnnData\nA copy of the input `adata` if `inplace=False`, otherwise the input\n`adata`. The following fields are added:\n`.obs[\"most_likely_hypothesis\"]`\nIndex of the most likely hypothesis, where `0` corresponds to negative,\n`1` to singlet, and `2` to doublet.\n`.obs[\"cluster_feature\"]`\nThe cluster assignments used for demultiplexing.\n`.obs[\"negative_hypothesis_probability\"]`\nProbability of the negative hypothesis.\n`.obs[\"singlet_hypothesis_probability\"]`\nProbability of the singlet hypothesis.\n`.obs[\"doublet_hypothesis_probability\"]`\nProbability of the doublet hypothesis.\n`.obs[\"Classification\"]`:\nClassification of the cell, one of the barcodes in `cell_hashing_columns`,\n`\"Negative\"`, or `\"Doublet\"`."
        },
        "Docstring": "Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein20]_.\n\n.. note::\n    More information and bug reports `here <https://github.com/calico/solo>`__.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\ncell_hashing_columns\n    A list specifying `.obs` columns that contain cell hashing counts.\npriors\n    A list specifying the prior probability of each hypothesis, in\n    the order `[negative, singlet, doublet]`. The default is set to\n    `[0.01, 0.8, 0.19]` assuming barcode counts are from cells that\n    have passed QC in the transcriptome space, e.g. UMI counts, pct\n    mito reads, etc.\npre_existing_clusters\n    The column in `.obs` containing pre-existing cluster assignments\n    (e.g. Leiden clusters or cell types, but not batch assignments).\n    If provided, demultiplexing will be performed separately for each\n    cluster.\nnumber_of_noise_barcodes\n    The number of barcodes used to create the noise distribution.\n    Defaults to `len(cell_hashing_columns) - 2`.\ninplace\n    Whether to update `adata` in-place or return a copy.\n\nReturns\n-------\nadata : anndata.AnnData\n    A copy of the input `adata` if `inplace=False`, otherwise the input\n    `adata`. The following fields are added:\n\n    `.obs[\"most_likely_hypothesis\"]`\n        Index of the most likely hypothesis, where `0` corresponds to negative,\n        `1` to singlet, and `2` to doublet.\n    `.obs[\"cluster_feature\"]`\n        The cluster assignments used for demultiplexing.\n    `.obs[\"negative_hypothesis_probability\"]`\n        Probability of the negative hypothesis.\n    `.obs[\"singlet_hypothesis_probability\"]`\n        Probability of the singlet hypothesis.\n    `.obs[\"doublet_hypothesis_probability\"]`\n        Probability of the doublet hypothesis.\n    `.obs[\"Classification\"]`:\n        Classification of the cell, one of the barcodes in `cell_hashing_columns`,\n        `\"Negative\"`, or `\"Doublet\"`.\n\nExamples\n-------\n>>> import anndata\n>>> import scanpy.external as sce\n>>> adata = anndata.read(\"data.h5ad\")\n>>> sce.pp.hashsolo(adata, ['Hash1', 'Hash2', 'Hash3'])\n>>> adata.obs.head()",
        "description": "Probabilistic demultiplexing of cell hashing data using HashSolo [Bernstein20]_... note::\n    More information and bug reports `here <https://github.com/calico/solo>`__.",
        "example": "Examples\n-------\n>>> import anndata\n>>> import scanpy.external as sce\n>>> adata = anndata.read(\"data.h5ad\")\n>>> sce.pp.hashsolo(adata, ['Hash1', 'Hash2', 'Hash3'])\n>>> adata.obs.head()",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.hashsolo(adata=$, cell_hashing_columns=@, priors=@, pre_existing_clusters=@, number_of_noise_barcodes=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.umap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "min_dist": {
                "type": "float",
                "default": "0.5",
                "optional": true,
                "description": "The effective minimum distance between embedded points. Smaller values\nwill result in a more clustered/clumped embedding where nearby points on\nthe manifold are drawn closer together, while larger values will result\non a more even dispersal of points. The value should be set relative to\nthe ``spread`` value, which determines the scale at which embedded\npoints will be spread out. The default of in the `umap-learn` package is\n0.1.",
                "optional_value": false
            },
            "spread": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "The effective scale of embedded points. In combination with `min_dist`\nthis determines how clustered/clumped the embedded points are.",
                "optional_value": false
            },
            "n_components": {
                "type": "int",
                "default": "2",
                "optional": true,
                "description": "The number of dimensions of the embedding.",
                "optional_value": false
            },
            "maxiter": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of iterations (epochs) of the optimization. Called `n_epochs`\nin the original UMAP.",
                "optional_value": false
            },
            "alpha": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "The initial learning rate for the embedding optimization.",
                "optional_value": false
            },
            "gamma": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Weighting applied to negative samples in low dimensional embedding\noptimization. Values higher than one will result in greater weight\nbeing given to negative samples.",
                "optional_value": false
            },
            "negative_sample_rate": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "The number of negative edge/1-simplex samples to use per positive\nedge/1-simplex sample in optimizing the low dimensional embedding.",
                "optional_value": false
            },
            "init_pos": {
                "type": "Optional[Union[Literal[paga, spectral, random], ndarray]]",
                "default": "spectral",
                "optional": true,
                "description": "How to initialize the low dimensional embedding. Called `init` in the\noriginal UMAP. Options are:\n\n* Any key for `adata.obsm`.\n* 'paga': positions from :func:`~scanpy.pl.paga`.\n* 'spectral': use a spectral embedding of the graph.\n* 'random': assign initial embedding positions at random.\n* A numpy array of initial embedding positions.",
                "optional_value": true
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "If `int`, `random_state` is the seed used by the random number generator;\nIf `RandomState` or `Generator`, `random_state` is the random number generator;\nIf `None`, the random number generator is the `RandomState` instance used\nby `np.random`.",
                "optional_value": false
            },
            "a": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "More specific parameters controlling the embedding. If `None` these\nvalues are set automatically as determined by `min_dist` and\n`spread`.",
                "optional_value": false
            },
            "b": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "More specific parameters controlling the embedding. If `None` these\nvalues are set automatically as determined by `min_dist` and\n`spread`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to adata.",
                "optional_value": false
            },
            "method": {
                "type": "Literal[umap, rapids]",
                "default": "umap",
                "optional": true,
                "description": "Use the original 'umap' implementation, or 'rapids' (experimental, GPU only)",
                "optional_value": true
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, umap looks .uns['neighbors'] for neighbors settings\nand .obsp['connectivities'] for connectivities\n(default storage places for pp.neighbors).\nIf specified, umap looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `adata` with the following fields.\n**X_umap** : `adata.obsm` field\nUMAP coordinates of data."
        },
        "Docstring": "Embed the neighborhood graph using UMAP [McInnes18]_.\n\nUMAP (Uniform Manifold Approximation and Projection) is a manifold learning\ntechnique suitable for visualizing high-dimensional data. Besides tending to\nbe faster than tSNE, it optimizes the embedding such that it best reflects\nthe topology of the data, which we represent throughout Scanpy using a\nneighborhood graph. tSNE, by contrast, optimizes the distribution of\nnearest-neighbor distances in the embedding such that these best match the\ndistribution of distances in the high-dimensional space.  We use the\nimplementation of `umap-learn <https://github.com/lmcinnes/umap>`__\n[McInnes18]_. For a few comparisons of UMAP with tSNE, see this `preprint\n<https://doi.org/10.1101/298430>`__.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nmin_dist\n    The effective minimum distance between embedded points. Smaller values\n    will result in a more clustered/clumped embedding where nearby points on\n    the manifold are drawn closer together, while larger values will result\n    on a more even dispersal of points. The value should be set relative to\n    the ``spread`` value, which determines the scale at which embedded\n    points will be spread out. The default of in the `umap-learn` package is\n    0.1.\nspread\n    The effective scale of embedded points. In combination with `min_dist`\n    this determines how clustered/clumped the embedded points are.\nn_components\n    The number of dimensions of the embedding.\nmaxiter\n    The number of iterations (epochs) of the optimization. Called `n_epochs`\n    in the original UMAP.\nalpha\n    The initial learning rate for the embedding optimization.\ngamma\n    Weighting applied to negative samples in low dimensional embedding\n    optimization. Values higher than one will result in greater weight\n    being given to negative samples.\nnegative_sample_rate\n    The number of negative edge/1-simplex samples to use per positive\n    edge/1-simplex sample in optimizing the low dimensional embedding.\ninit_pos\n    How to initialize the low dimensional embedding. Called `init` in the\n    original UMAP. Options are:\n\n    * Any key for `adata.obsm`.\n    * 'paga': positions from :func:`~scanpy.pl.paga`.\n    * 'spectral': use a spectral embedding of the graph.\n    * 'random': assign initial embedding positions at random.\n    * A numpy array of initial embedding positions.\nrandom_state\n    If `int`, `random_state` is the seed used by the random number generator;\n    If `RandomState` or `Generator`, `random_state` is the random number generator;\n    If `None`, the random number generator is the `RandomState` instance used\n    by `np.random`.\na\n    More specific parameters controlling the embedding. If `None` these\n    values are set automatically as determined by `min_dist` and\n    `spread`.\nb\n    More specific parameters controlling the embedding. If `None` these\n    values are set automatically as determined by `min_dist` and\n    `spread`.\ncopy\n    Return a copy instead of writing to adata.\nmethod\n    Use the original 'umap' implementation, or 'rapids' (experimental, GPU only)\nneighbors_key\n    If not specified, umap looks .uns['neighbors'] for neighbors settings\n    and .obsp['connectivities'] for connectivities\n    (default storage places for pp.neighbors).\n    If specified, umap looks .uns[neighbors_key] for neighbors settings and\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields.\n\n**X_umap** : `adata.obsm` field\n    UMAP coordinates of data.",
        "description": "Embed the neighborhood graph using UMAP [McInnes18]_.UMAP (Uniform Manifold Approximation and Projection) is a manifold learning\ntechnique suitable for visualizing high-dimensional data. Besides tending to\nbe faster than tSNE, it optimizes the embedding such that it best reflects\nthe topology of the data, which we represent throughout Scanpy using a\nneighborhood graph. tSNE, by contrast, optimizes the distribution of\nnearest-neighbor distances in the embedding such that these best match the\ndistribution of distances in the high-dimensional space.  We use the\nimplementation of `umap-learn <https://github.com/lmcinnes/umap>`__\n[McInnes18]_. For a few comparisons of UMAP with tSNE, see this `preprint\n<https://doi.org/10.1101/298430>`__.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.umap(adata=$, min_dist=@, spread=@, n_components=@, maxiter=@, alpha=@, gamma=@, negative_sample_rate=@, init_pos=$, random_state=@, a=@, b=@, copy=@, method=$, neighbors_key=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.dpt_groups_pseudotime": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "color_map": {
                "type": "Optional[Union[str, Colormap]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot groups and pseudotime.",
        "description": "Plot groups and pseudotime.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.dpt_groups_pseudotime(adata=$, color_map=@, palette=@, show=@, save=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_umi_tools": {
        "Parameters": {
            "filename": {
                "type": "PathLike",
                "default": null,
                "optional": false,
                "description": "File name to read from.",
                "optional_value": true
            },
            "dtype": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Read a gzipped condensed count matrix from umi_tools.\n\nParameters\n----------\nfilename\n    File name to read from.",
        "description": "Read a gzipped condensed count matrix from umi_tools.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_umi_tools(filename=$, dtype=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.louvain": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "resolution": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "For the default flavor (``'vtraag'``) or for ```RAPIDS```, you can provide a\nresolution (higher resolution means finding more and smaller clusters),\nwhich defaults to 1.0.\nSee \u201cTime as a resolution parameter\u201d in [Lambiotte09]_.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Change the initialization of the optimization.",
                "optional_value": false
            },
            "restrict_to": {
                "type": "Optional[tuple[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Restrict the clustering to the categories within the key for sample\nannotation, tuple needs to contain ``(obs_key, list_of_categories)``.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "louvain",
                "optional": true,
                "description": "Key under which to add the cluster labels. (default: ``'louvain'``)",
                "optional_value": false
            },
            "adjacency": {
                "type": "Optional[spmatrix]",
                "default": "None",
                "optional": true,
                "description": "Sparse adjacency matrix of the graph, defaults to neighbors connectivities.",
                "optional_value": true
            },
            "flavor": {
                "type": "Literal[vtraag, igraph, rapids]",
                "default": "vtraag",
                "optional": true,
                "description": "Choose between to packages for computing the clustering.\n``'vtraag'`` is much more powerful, and the default.",
                "optional_value": true
            },
            "directed": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Interpret the ``adjacency`` matrix as directed graph?",
                "optional_value": false
            },
            "use_weights": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Use weights from knn graph.",
                "optional_value": false
            },
            "partition_type": {
                "type": "Optional[type[MutableVertexPartition]]",
                "default": "None",
                "optional": true,
                "description": "Type of partition to use.\nOnly a valid argument if ``flavor`` is ``'vtraag'``.",
                "optional_value": true
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use neighbors connectivities as adjacency.\nIf not specified, louvain looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, louvain looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "obsp": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use .obsp[obsp] as adjacency. You can't specify both\n`obsp` and `neighbors_key` at the same time.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Copy adata or modify it inplace.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ":obj:`None`\nBy default (``copy=False``), updates ``adata`` with the following fields:\n``adata.obs['louvain']`` (:class:`pandas.Series`, dtype ``category``)\nArray of dim (number of samples) that stores the subgroup id\n(``'0'``, ``'1'``, ...) for each cell.\n:class:`~anndata.AnnData`\nWhen ``copy=True`` is set, a copy of ``adata`` with those fields is returned."
        },
        "Docstring": "Cluster cells into subgroups [Blondel08]_ [Levine15]_ [Traag17]_.\n\nCluster cells using the Louvain algorithm [Blondel08]_ in the implementation\nof [Traag17]_. The Louvain algorithm has been proposed for single-cell\nanalysis by [Levine15]_.\n\nThis requires having ran :func:`~scanpy.pp.neighbors` or\n:func:`~scanpy.external.pp.bbknn` first,\nor explicitly passing a ``adjacency`` matrix.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nresolution\n    For the default flavor (``'vtraag'``) or for ```RAPIDS```, you can provide a\n    resolution (higher resolution means finding more and smaller clusters),\n    which defaults to 1.0.\n    See \u201cTime as a resolution parameter\u201d in [Lambiotte09]_.\nrandom_state\n    Change the initialization of the optimization.\nrestrict_to\n    Restrict the clustering to the categories within the key for sample\n    annotation, tuple needs to contain ``(obs_key, list_of_categories)``.\nkey_added\n    Key under which to add the cluster labels. (default: ``'louvain'``)\nadjacency\n    Sparse adjacency matrix of the graph, defaults to neighbors connectivities.\nflavor\n    Choose between to packages for computing the clustering.\n    ``'vtraag'`` is much more powerful, and the default.\ndirected\n    Interpret the ``adjacency`` matrix as directed graph?\nuse_weights\n    Use weights from knn graph.\npartition_type\n    Type of partition to use.\n    Only a valid argument if ``flavor`` is ``'vtraag'``.\npartition_kwargs\n    Key word arguments to pass to partitioning,\n    if ``vtraag`` method is being used.\nneighbors_key\n    Use neighbors connectivities as adjacency.\n    If not specified, louvain looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, louvain looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\nobsp\n    Use .obsp[obsp] as adjacency. You can't specify both\n    `obsp` and `neighbors_key` at the same time.\ncopy\n    Copy adata or modify it inplace.\n\nReturns\n-------\n:obj:`None`\n    By default (``copy=False``), updates ``adata`` with the following fields:\n\n    ``adata.obs['louvain']`` (:class:`pandas.Series`, dtype ``category``)\n        Array of dim (number of samples) that stores the subgroup id\n        (``'0'``, ``'1'``, ...) for each cell.\n\n:class:`~anndata.AnnData`\n    When ``copy=True`` is set, a copy of ``adata`` with those fields is returned.",
        "description": "Cluster cells into subgroups [Blondel08]_ [Levine15]_ [Traag17]_.Cluster cells using the Louvain algorithm [Blondel08]_ in the implementation\nof [Traag17]_. The Louvain algorithm has been proposed for single-cell\nanalysis by [Levine15]_.\n\nThis requires having ran :func:`~scanpy.pp.neighbors` or\n:func:`~scanpy.external.pp.bbknn` first,\nor explicitly passing a ``adjacency`` matrix.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.louvain(adata=$, resolution=@, random_state=@, restrict_to=@, key_added=@, adjacency=$, flavor=$, directed=@, use_weights=@, partition_type=$, neighbors_key=@, obsp=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
                "optional_value": false
            },
            "categories_order": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Order in which to show the categories. Note: add_dendrogram or add_totals\ncan change the categories order.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`.\nOtherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Literal[var, group]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize that dimension between 0 and 1,\nmeaning for each variable or group,\nsubtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "values_df": {
                "type": "Optional[DataFrame]",
                "default": "None",
                "optional": true,
                "description": "Optionally, a dataframe with the values to plot can be given. The\nindex should be the grouby categories and the columns the genes names.",
                "optional_value": true
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Allows the visualization of values using a color map.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nvar_names\n    `var_names` should be a valid subset of `adata.var_names`.\n    If `var_names` is a mapping, then the key is used as label\n    to group the values (see `var_group_labels`). The mapping values\n    should be sequences of valid `adata.var_names`. In this\n    case either coloring or 'brackets' are used for the grouping\n    of var names depending on the plot. When `var_names` is a mapping,\n    then the `var_group_labels` and `var_group_positions` are set.\ngroupby\n    The key of the observation grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlog\n    Plot on logarithmic axis.\nnum_categories\n    Only used if groupby observation is not categorical. This value\n    determines the number of groups into which the groupby observation\n    should be subdivided.\ncategories_order\n    Order in which to show the categories. Note: add_dendrogram or add_totals\n    can change the categories order.\nfigsize\n    Figure size when `multi_panel=True`.\n    Otherwise the `rcParam['figure.figsize]` value is used.\n    Format is (width, height)\ndendrogram\n    If True or a valid dendrogram key, a dendrogram based on the hierarchical\n    clustering between the `groupby` categories is added.\n    The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n    If `tl.dendrogram` has not been called previously the function is called\n    with default parameters.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols.\n    By default `var_names` refer to the index column of the `.var` DataFrame.\n    Setting this option allows alternative names to be used.\nvar_group_positions\n    Use this parameter to highlight groups of `var_names`.\n    This will draw a 'bracket' or a color block between the given start and end\n    positions. If the parameter `var_group_labels` is set, the corresponding\n    labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n    will add a bracket between the fourth `var_name` and the tenth `var_name`.\n    By giving more positions, more brackets/color blocks are drawn.\nvar_group_labels\n    Labels for each of the `var_group_positions` that want to be highlighted.\nvar_group_rotation\n    Label rotation degrees.\n    By default, labels larger than 4 characters are rotated 90 degrees.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n    If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\ntitle\n    Title for the figure.\nexpression_cutoff\n    Expression cutoff that is used for binarizing the gene expression and\n    determining the fraction of cells expressing given genes. A gene is\n    expressed only if the expression value is greater than this threshold.\nmean_only_expressed\n    If True, gene expression is averaged only over the cells\n    expressing the given genes.\nstandard_scale\n    Whether or not to standardize that dimension between 0 and 1,\n    meaning for each variable or group,\n    subtract the minimum and divide each by its maximum.\nvalues_df\n    Optionally, a dataframe with the values to plot can be given. The\n    index should be the grouby categories and the columns the genes names.\n\nkwds\n    Are passed to :func:`matplotlib.pyplot.scatter`.\n\nSee also\n--------\n:func:`~scanpy.pl.matrixplot`: Simpler way to call MatrixPlot but with less options.\n:func:`~scanpy.pl.rank_genes_groups_matrixplot`: to plot marker genes identified\n    using the :func:`~scanpy.tl.rank_genes_groups` function.\n\nExamples\n--------\n\nSimple visualization of the average expression of a few genes grouped by\nthe category 'bulk_labels'.\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels').show()\n\nSame visualization but passing var_names as dict, which adds a grouping of\nthe genes on top of the image:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels').show()",
        "description": "Allows the visualization of values using a color map.",
        "example": "Examples\n--------\n\nSimple visualization of the average expression of a few genes grouped by\nthe category 'bulk_labels'.\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels').show()\n\nSame visualization but passing var_names as dict, which adds a grouping of\nthe genes on top of the image:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels').show()",
        "api_type": "class",
        "api_calling": [
            "scanpy.pl.MatrixPlot(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, categories_order=@, title=@, figsize=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, standard_scale=$, ax=$, values_df=$, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot.savefig": {
        "Parameters": {
            "filename": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Figure filename. Figure *format* is taken from the file ending unless\nthe parameter `format` is given.",
                "optional_value": false
            },
            "bbox_inches": {
                "type": "Optional[str]",
                "default": "tight",
                "optional": true,
                "description": "By default is set to 'tight' to avoid cropping of the legends.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Save the current figure\n\nParameters\n----------\nfilename\n    Figure filename. Figure *format* is taken from the file ending unless\n    the parameter `format` is given.\nbbox_inches\n    By default is set to 'tight' to avoid cropping of the legends.\nkwargs\n    Passed to :func:`matplotlib.pyplot.savefig`\n\nSee also\n--------\n`render()`: Renders the plot but does not call :func:`matplotlib.pyplot.show`\n`show()`: Renders and shows the plot\n\nExamples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').savefig('plot.pdf')",
        "description": "Save the current figure",
        "example": "Examples\n-------\n>>> adata = sc.datasets.pbmc68k_reduced()\n>>> markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n>>> sc.pl.BasePlot(adata, markers, groupby='bulk_labels').savefig('plot.pdf')",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.MatrixPlot.savefig(filename=@, bbox_inches=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.MatrixPlot.style": {
        "Parameters": {
            "cmap": {
                "type": "str",
                "default": "viridis",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "edge_color": {
                "type": "Optional[Union[str, tuple[float, Ellipsis]]]",
                "default": "gray",
                "optional": true,
                "description": "Edge color between the squares of matrix plot. Default is gray",
                "optional_value": false
            },
            "edge_lw": {
                "type": "Optional[float]",
                "default": "0.1",
                "optional": true,
                "description": "Edge line width.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ":class:`~scanpy.pl.MatrixPlot`"
        },
        "Docstring": "Modifies plot visual parameters.\n\nParameters\n----------\ncmap\n    String denoting matplotlib color map.\nedge_color\n    Edge color between the squares of matrix plot. Default is gray\nedge_lw\n    Edge line width.\n\nReturns\n-------\n:class:`~scanpy.pl.MatrixPlot`\n\nExamples\n-------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n\nChange color map and turn off edges:\n\n\n.. plot::\n    :context: close-figs\n\n    (\n        sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels')\n        .style(cmap='Blues', edge_color='none')\n        .show()\n    )",
        "description": "Modifies plot visual parameters.",
        "example": "Examples\n-------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n\nChange color map and turn off edges:\n\n\n.. plot::\n    :context: close-figs\n\n    (\n        sc.pl.MatrixPlot(adata, markers, groupby='bulk_labels')\n        .style(cmap='Blues', edge_color='none')\n        .show()\n    )",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.MatrixPlot.style(cmap=@, edge_color=@, edge_lw=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.paga": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "threshold": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Do not draw edges for weights below this threshold. Set to 0 if you want\nall edges. Discarding low-connectivity edges helps in getting a much\nclearer picture of the graph.",
                "optional_value": false
            },
            "color": {
                "type": "Optional[Union[str, Mapping[Union[str, int], Mapping[Any, float]]]]",
                "default": "None",
                "optional": true,
                "description": "Gene name or `obs` annotation defining the node colors.\nAlso plots the degree of the abstracted graph when\npassing {`'degree_dashed'`, `'degree_solid'`}.\n\nCan be also used to visualize pie chart at each node in the following form:\n`{<group name or index>: {<color>: <fraction>, ...}, ...}`. If the fractions\ndo not sum to 1, a new category called `'rest'` colored grey will be created.",
                "optional_value": false
            },
            "layout": {
                "type": "Optional[Literal[fa, fr, rt, rt_circular, drl, eq_tree, Ellipsis]]",
                "default": "None",
                "optional": true,
                "description": "Plotting layout that computes positions.\n`'fa'` stands for \u201cForceAtlas2\u201d,\n`'fr'` stands for \u201cFruchterman-Reingold\u201d,\n`'rt'` stands for \u201cReingold-Tilford\u201d,\n`'eq_tree'` stands for \u201ceqally spaced tree\u201d.\nAll but `'fa'` and `'eq_tree'` are igraph layouts.\nAll other igraph layouts are also permitted.\nSee also parameter `pos` and :func:`~scanpy.tl.draw_graph`.",
                "optional_value": true
            },
            "init_pos": {
                "type": "Optional[ndarray]",
                "default": "None",
                "optional": true,
                "description": "Two-column array storing the x and y coordinates for initializing the\nlayout.",
                "optional_value": true
            },
            "root": {
                "type": "Optional[Union[int, str, Sequence[int]]]",
                "default": "0",
                "optional": true,
                "description": "If choosing a tree layout, this is the index of the root node or a list\nof root node indices. If this is a non-empty vector then the supplied\nnode IDs are used as the roots of the trees (or a single tree if the\ngraph is connected). If this is `None` or an empty list, the root\nvertices are automatically calculated based on topological sorting.",
                "optional_value": false
            },
            "labels": {
                "type": "Optional[Union[str, Sequence[str], Mapping[str, str]]]",
                "default": "None",
                "optional": true,
                "description": "The node labels. If `None`, this defaults to the group labels stored in\nthe categorical for which :func:`~scanpy.tl.paga` has been computed.",
                "optional_value": false
            },
            "single_component": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Restrict to largest connected component.",
                "optional_value": false
            },
            "solid_edges": {
                "type": "str",
                "default": "connectivities",
                "optional": true,
                "description": "Key for `.uns['paga']` that specifies the matrix that stores the edges\nto be drawn solid black.",
                "optional_value": false
            },
            "dashed_edges": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `.uns['paga']` that specifies the matrix that stores the edges\nto be drawn dashed grey. If `None`, no dashed edges are drawn.",
                "optional_value": false
            },
            "transitions": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `.uns['paga']` that specifies the matrix that stores the\narrows, for instance `'transitions_confidence'`.",
                "optional_value": false
            },
            "fontsize": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Font size for node labels.",
                "optional_value": false
            },
            "fontweight": {
                "type": "str",
                "default": "bold",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Width of the white outline around fonts.",
                "optional_value": false
            },
            "node_size_scale": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Increase or decrease the size of the nodes.",
                "optional_value": false
            },
            "node_size_power": {
                "type": "float",
                "default": "0.5",
                "optional": true,
                "description": "The power with which groups sizes influence the radius of the nodes.",
                "optional_value": false
            },
            "edge_width_scale": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Edge with scale in units of `rcParams['lines.linewidth']`.",
                "optional_value": false
            },
            "min_edge_width": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Min width of solid edges.",
                "optional_value": false
            },
            "max_edge_width": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Max width of solid and dashed edges.",
                "optional_value": false
            },
            "arrowsize": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "For directed graphs, choose the size of the arrow head head's length and\nwidth. See :py:class: `matplotlib.patches.FancyArrowPatch` for attribute\n`mutation_scale` for more info.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Provide a title.",
                "optional_value": false
            },
            "left_margin": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[int]",
                "default": "0",
                "optional": true,
                "description": "For layouts with random initialization like `'fr'`, change this to use\ndifferent intial states for the optimization. If `None`, the initial\nstate is not reproducible.",
                "optional_value": false
            },
            "pos": {
                "type": "Optional[Union[ndarray, str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Two-column array-like storing the x and y coordinates for drawing.\nOtherwise, path to a `.gdf` file that has been exported from Gephi or\na similar graph visualization software.",
                "optional_value": false
            },
            "normalize_to_color": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to normalize categorical plots to `color` or the underlying\ngrouping.",
                "optional_value": false
            },
            "cmap": {
                "type": "Union[str, Colormap]",
                "default": "None",
                "optional": true,
                "description": "The color map.",
                "optional_value": false
            },
            "cax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object for a potential colorbar.",
                "optional_value": true
            },
            "colorbar": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the PAGA graph.",
                "optional_value": false
            },
            "add_pos": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Add the positions to `adata.uns['paga']`.",
                "optional_value": false
            },
            "export_to_gexf": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Export to gexf format to be read by graph visualization programs such as\nGephi.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "colors": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "groups": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "plot": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `False`, do not create the figure, simply compute the layout.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on \\{`'.pdf'`, `'.png'`, `'.svg'`\\}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, List[Axes]]]",
            "description": "If `show==False`, one or more :class:`~matplotlib.axes.Axes` objects.\nAdds `'pos'` to `adata.uns['paga']` if `add_pos` is `True`."
        },
        "Docstring": "Plot the PAGA graph through thresholding low-connectivity edges.\n\nCompute a coarse-grained layout of the data. Reuse this by passing\n`init_pos='paga'` to :func:`~scanpy.tl.umap` or\n:func:`~scanpy.tl.draw_graph` and obtain embeddings with more meaningful\nglobal topology [Wolf19]_.\n\nThis uses ForceAtlas2 or igraph's layout algorithms for most layouts [Csardi06]_.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nthreshold\n    Do not draw edges for weights below this threshold. Set to 0 if you want\n    all edges. Discarding low-connectivity edges helps in getting a much\n    clearer picture of the graph.\ncolor\n    Gene name or `obs` annotation defining the node colors.\n    Also plots the degree of the abstracted graph when\n    passing {`'degree_dashed'`, `'degree_solid'`}.\n\n    Can be also used to visualize pie chart at each node in the following form:\n    `{<group name or index>: {<color>: <fraction>, ...}, ...}`. If the fractions\n    do not sum to 1, a new category called `'rest'` colored grey will be created.\nlabels\n    The node labels. If `None`, this defaults to the group labels stored in\n    the categorical for which :func:`~scanpy.tl.paga` has been computed.\npos\n    Two-column array-like storing the x and y coordinates for drawing.\n    Otherwise, path to a `.gdf` file that has been exported from Gephi or\n    a similar graph visualization software.\nlayout\n    Plotting layout that computes positions.\n    `'fa'` stands for \u201cForceAtlas2\u201d,\n    `'fr'` stands for \u201cFruchterman-Reingold\u201d,\n    `'rt'` stands for \u201cReingold-Tilford\u201d,\n    `'eq_tree'` stands for \u201ceqally spaced tree\u201d.\n    All but `'fa'` and `'eq_tree'` are igraph layouts.\n    All other igraph layouts are also permitted.\n    See also parameter `pos` and :func:`~scanpy.tl.draw_graph`.\nlayout_kwds\n    Keywords for the layout.\ninit_pos\n    Two-column array storing the x and y coordinates for initializing the\n    layout.\nrandom_state\n    For layouts with random initialization like `'fr'`, change this to use\n    different intial states for the optimization. If `None`, the initial\n    state is not reproducible.\nroot\n    If choosing a tree layout, this is the index of the root node or a list\n    of root node indices. If this is a non-empty vector then the supplied\n    node IDs are used as the roots of the trees (or a single tree if the\n    graph is connected). If this is `None` or an empty list, the root\n    vertices are automatically calculated based on topological sorting.\ntransitions\n    Key for `.uns['paga']` that specifies the matrix that stores the\n    arrows, for instance `'transitions_confidence'`.\nsolid_edges\n    Key for `.uns['paga']` that specifies the matrix that stores the edges\n    to be drawn solid black.\ndashed_edges\n    Key for `.uns['paga']` that specifies the matrix that stores the edges\n    to be drawn dashed grey. If `None`, no dashed edges are drawn.\nsingle_component\n    Restrict to largest connected component.\nfontsize\n    Font size for node labels.\nfontoutline\n    Width of the white outline around fonts.\ntext_kwds\n    Keywords for :meth:`~matplotlib.axes.Axes.text`.\nnode_size_scale\n    Increase or decrease the size of the nodes.\nnode_size_power\n    The power with which groups sizes influence the radius of the nodes.\nedge_width_scale\n    Edge with scale in units of `rcParams['lines.linewidth']`.\nmin_edge_width\n    Min width of solid edges.\nmax_edge_width\n    Max width of solid and dashed edges.\narrowsize\n   For directed graphs, choose the size of the arrow head head's length and\n   width. See :py:class: `matplotlib.patches.FancyArrowPatch` for attribute\n   `mutation_scale` for more info.\nexport_to_gexf\n    Export to gexf format to be read by graph visualization programs such as\n    Gephi.\nnormalize_to_color\n    Whether to normalize categorical plots to `color` or the underlying\n    grouping.\ncmap\n    The color map.\ncax\n    A matplotlib axes object for a potential colorbar.\ncb_kwds\n    Keyword arguments for :class:`~matplotlib.colorbar.Colorbar`,\n    for instance, `ticks`.\nadd_pos\n    Add the positions to `adata.uns['paga']`.\ntitle\n    Provide a title.\nframeon\n    Draw a frame around the PAGA graph.\nplot\n    If `False`, do not create the figure, simply compute the layout.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on \\{`'.pdf'`, `'.png'`, `'.svg'`\\}.\nax\n    A matplotlib axes object.\n\nReturns\n-------\nIf `show==False`, one or more :class:`~matplotlib.axes.Axes` objects.\nAdds `'pos'` to `adata.uns['paga']` if `add_pos` is `True`.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc3k_processed()\n    sc.tl.paga(adata, groups='louvain')\n    sc.pl.paga(adata)\n\nYou can increase node and edge sizes by specifying additional arguments.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.paga(adata, node_size_scale=10, edge_width_scale=2)\n\nNotes\n-----\nWhen initializing the positions, note that \u2013 for some reason \u2013 igraph\nmirrors coordinates along the x axis... that is, you should increase the\n`maxiter` parameter by 1 if the layout is flipped.\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.paga\npl.paga_compare\npl.paga_path",
        "description": "Plot the PAGA graph through thresholding low-connectivity edges.Compute a coarse-grained layout of the data. Reuse this by passing\n`init_pos='paga'` to :func:`~scanpy.tl.umap` or\n:func:`~scanpy.tl.draw_graph` and obtain embeddings with more meaningful\nglobal topology [Wolf19]_.\n\nThis uses ForceAtlas2 or igraph's layout algorithms for most layouts [Csardi06]_.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc3k_processed()\n    sc.tl.paga(adata, groups='louvain')\n    sc.pl.paga(adata)\n\nYou can increase node and edge sizes by specifying additional arguments.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.paga(adata, node_size_scale=10, edge_width_scale=2)\n\nNotes\n-----\nWhen initializing the positions, note that \u2013 for some reason \u2013 igraph\nmirrors coordinates along the x axis... that is, you should increase the\n`maxiter` parameter by 1 if the layout is flipped.\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.paga\npl.paga_compare\npl.paga_path",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.paga(adata=$, threshold=@, color=@, layout=$, init_pos=$, root=@, labels=@, single_component=@, solid_edges=@, dashed_edges=@, transitions=@, fontsize=@, fontweight=@, fontoutline=@, node_size_scale=@, node_size_power=@, edge_width_scale=@, min_edge_width=@, max_edge_width=@, arrowsize=@, title=@, left_margin=@, random_state=@, pos=@, normalize_to_color=@, cmap=@, cax=$, colorbar=$, frameon=@, add_pos=@, export_to_gexf=@, use_raw=@, colors=$, groups=$, plot=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.krumsiek11": {
        "Parameters": {},
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "Simulated myeloid progenitors [Krumsiek11]_.\n\nThe literature-curated boolean network from [Krumsiek11]_ was used to\nsimulate the data. It describes development to four cell fates: 'monocyte',\n'erythrocyte', 'megakaryocyte' and 'neutrophil'.\n\nSee also the discussion of this data in [Wolf19]_.\n\nSimulate via :func:`~scanpy.tl.sim`.\n\nReturns\n-------\nAnnotated data matrix.",
        "description": "Simulated myeloid progenitors [Krumsiek11]_.The literature-curated boolean network from [Krumsiek11]_ was used to\nsimulate the data. It describes development to four cell fates: 'monocyte',\n'erythrocyte', 'megakaryocyte' and 'neutrophil'.\n\nSee also the discussion of this data in [Wolf19]_.\n\nSimulate via :func:`~scanpy.tl.sim`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.krumsiek11()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.queries.gene_coordinates": {
        "Parameters": {
            "org": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Organism to query. Must be an organism in ensembl biomart. \"hsapiens\",\n\"mmusculus\", \"drerio\", etc.",
                "optional_value": false
            },
            "gene_name": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "The gene symbol (e.g. \"hgnc_symbol\" for human) for which to retrieve\ncoordinates.",
                "optional_value": false
            },
            "gene_attr": {
                "type": "str",
                "default": "external_gene_name",
                "optional": true,
                "description": "The biomart attribute the gene symbol should show up for.",
                "optional_value": false
            },
            "chr_exclude": {
                "type": "Iterable[str]",
                "default": "()",
                "optional": true,
                "description": "A list of chromosomes to exclude from query.",
                "optional_value": false
            },
            "host": {
                "type": "str",
                "default": "www.ensembl.org",
                "optional": true,
                "description": "A valid BioMart host URL. Alternative values include archive urls (like\n\"grch37.ensembl.org\") or regional mirrors (like \"useast.ensembl.org\").",
                "optional_value": false
            },
            "use_cache": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether pybiomart should use a cache for requests. Will create a\n`.pybiomart.sqlite` file in current directory if used.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": "Dataframe containing gene coordinates for the specified gene symbol."
        },
        "Docstring": "Retrieve gene coordinates for specific organism through BioMart.\n\nParameters\n----------\norg\n    Organism to query. Must be an organism in ensembl biomart. \"hsapiens\",\n    \"mmusculus\", \"drerio\", etc.\ngene_name\n    The gene symbol (e.g. \"hgnc_symbol\" for human) for which to retrieve\n    coordinates.\ngene_attr\n    The biomart attribute the gene symbol should show up for.\nchr_exclude\n    A list of chromosomes to exclude from query.\nhost\n    A valid BioMart host URL. Alternative values include archive urls (like\n    \"grch37.ensembl.org\") or regional mirrors (like \"useast.ensembl.org\").\nuse_cache\n    Whether pybiomart should use a cache for requests. Will create a\n    `.pybiomart.sqlite` file in current directory if used.\n\nReturns\n-------\nDataframe containing gene coordinates for the specified gene symbol.\n\nExamples\n--------\n>>> import scanpy as sc\n>>> sc.queries.gene_coordinates(\"hsapiens\", \"MT-TF\")",
        "description": "Retrieve gene coordinates for specific organism through BioMart.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> sc.queries.gene_coordinates(\"hsapiens\", \"MT-TF\")",
        "api_type": "function",
        "api_calling": [
            "scanpy.queries.gene_coordinates(org=@, gene_name=@, gene_attr=@, chr_exclude=@, host=@, use_cache=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.stacked_violin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure",
                "optional_value": false
            },
            "colorbar_title": {
                "type": "Optional[str]",
                "default": "Median expression\nin group",
                "optional": true,
                "description": "Title for the color bar. New line character (\\n) can be used.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`.\nOtherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called\nwith default parameters.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Optional[Literal[var, obs]]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "stripplot": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Add a stripplot on top of the violin plot.\nSee :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "jitter": {
                "type": "Union[float, bool]",
                "default": "False",
                "optional": true,
                "description": "Add jitter to the stripplot (only when stripplot is True)\nSee :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "size": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Size of the jitter points.",
                "optional_value": false
            },
            "scale": {
                "type": "Literal[area, count, width]",
                "default": "width",
                "optional": true,
                "description": "The method used to scale the width of each violin.\nIf 'width' (the default), each violin will have the same width.\nIf 'area', each violin will have the same area.\nIf 'count', a violin\u2019s width corresponds to the number of observations.",
                "optional_value": true
            },
            "yticklabels": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Set to true to view the y tick labels.",
                "optional_value": false
            },
            "order": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Order in which to show the categories. Note: if `dendrogram=True`\nthe categories order will be given by the dendrogram and `order`\nwill be ignored.",
                "optional_value": false
            },
            "swap_axes": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "By default, the x axis contains `var_names` (e.g. genes) and the y axis\nthe `groupby` categories. By setting `swap_axes` then x are the\n`groupby` categories and y the `var_names`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`DotPlot` object. Useful for fine-tuning\nthe plot. Takes precedence over `show=False`.",
                "optional_value": false
            },
            "row_palette": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Be default, median values are mapped to the violin color using a\ncolor map (see `cmap` argument). Alternatively, a 'row_palette` can\nbe given to color each violin plot row using a different colors.\nThe value should be a valid seaborn or matplotlib palette name\n(see :func:`~seaborn.color_palette`).\nAlternatively, a single color name or hex value can be passed,\ne.g. `'red'` or `'#cc33ff'`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[str]",
                "default": "Blues",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. Values larger than vmax are plotted\nwith the same color as vmax.",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "Custom color normalization object from matplotlib. See\n`https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[StackedViolin, dict]]",
            "description": "If `return_fig` is `True`, returns a :class:`~scanpy.pl.StackedViolin` object,\nelse if `show` is false, return axes dict\nSee also\n:class:`~scanpy.pl.StackedViolin`: The StackedViolin class can be used to to control\nseveral visual parameters not available in this function.\n:func:`~scanpy.pl.rank_genes_groups_stacked_violin` to plot marker genes identified\nusing the :func:`~scanpy.tl.rank_genes_groups` function."
        },
        "Docstring": "Stacked violin plots.\n\nMakes a compact image composed of individual violin plots\n(from :func:`~seaborn.violinplot`) stacked on top of each other.\nUseful to visualize gene expression per cluster.\n\nWraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.\n\nThis function provides a convenient interface to the\n:class:`~scanpy.pl.StackedViolin` class. If you need more flexibility,\nyou should use :class:`~scanpy.pl.StackedViolin` directly.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nvar_names\n    `var_names` should be a valid subset of `adata.var_names`.\n    If `var_names` is a mapping, then the key is used as label\n    to group the values (see `var_group_labels`). The mapping values\n    should be sequences of valid `adata.var_names`. In this\n    case either coloring or 'brackets' are used for the grouping\n    of var names depending on the plot. When `var_names` is a mapping,\n    then the `var_group_labels` and `var_group_positions` are set.\ngroupby\n    The key of the observation grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlog\n    Plot on logarithmic axis.\nnum_categories\n    Only used if groupby observation is not categorical. This value\n    determines the number of groups into which the groupby observation\n    should be subdivided.\ncategories_order\n    Order in which to show the categories. Note: add_dendrogram or add_totals\n    can change the categories order.\nfigsize\n    Figure size when `multi_panel=True`.\n    Otherwise the `rcParam['figure.figsize]` value is used.\n    Format is (width, height)\ndendrogram\n    If True or a valid dendrogram key, a dendrogram based on the hierarchical\n    clustering between the `groupby` categories is added.\n    The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n    If `tl.dendrogram` has not been called previously the function is called\n    with default parameters.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols.\n    By default `var_names` refer to the index column of the `.var` DataFrame.\n    Setting this option allows alternative names to be used.\nvar_group_positions\n    Use this parameter to highlight groups of `var_names`.\n    This will draw a 'bracket' or a color block between the given start and end\n    positions. If the parameter `var_group_labels` is set, the corresponding\n    labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n    will add a bracket between the fourth `var_name` and the tenth `var_name`.\n    By giving more positions, more brackets/color blocks are drawn.\nvar_group_labels\n    Labels for each of the `var_group_positions` that want to be highlighted.\nvar_group_rotation\n    Label rotation degrees.\n    By default, labels larger than 4 characters are rotated 90 degrees.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n    If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\ntitle\n    Title for the figure\ncolorbar_title\n    Title for the color bar. New line character (\\n) can be used.\ncmap\n    String denoting matplotlib color map.\nstandard_scale\n    Whether or not to standardize the given dimension between 0 and 1, meaning for\n    each variable or group, subtract the minimum and divide each by its maximum.\nswap_axes\n     By default, the x axis contains `var_names` (e.g. genes) and the y axis\n     the `groupby` categories. By setting `swap_axes` then x are the\n     `groupby` categories and y the `var_names`.\nreturn_fig\n    Returns :class:`DotPlot` object. Useful for fine-tuning\n    the plot. Takes precedence over `show=False`.\n\nstripplot\n    Add a stripplot on top of the violin plot.\n    See :func:`~seaborn.stripplot`.\njitter\n    Add jitter to the stripplot (only when stripplot is True)\n    See :func:`~seaborn.stripplot`.\nsize\n    Size of the jitter points.\norder\n    Order in which to show the categories. Note: if `dendrogram=True`\n    the categories order will be given by the dendrogram and `order`\n    will be ignored.\nscale\n    The method used to scale the width of each violin.\n    If 'width' (the default), each violin will have the same width.\n    If 'area', each violin will have the same area.\n    If 'count', a violin\u2019s width corresponds to the number of observations.\nyticklabels\n    Set to true to view the y tick labels.\nrow_palette\n    Be default, median values are mapped to the violin color using a\n    color map (see `cmap` argument). Alternatively, a 'row_palette` can\n    be given to color each violin plot row using a different colors.\n    The value should be a valid seaborn or matplotlib palette name\n    (see :func:`~seaborn.color_palette`).\n    Alternatively, a single color name or hex value can be passed,\n    e.g. `'red'` or `'#cc33ff'`.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin.\nvmax\n    The value representing the upper limit of the color scale. Values larger than vmax are plotted\n    with the same color as vmax.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\nnorm\n    Custom color normalization object from matplotlib. See\n    `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.\nkwds\n    Are passed to :func:`~seaborn.violinplot`.\n\nReturns\n-------\nIf `return_fig` is `True`, returns a :class:`~scanpy.pl.StackedViolin` object,\nelse if `show` is false, return axes dict\n\nSee also\n--------\n:class:`~scanpy.pl.StackedViolin`: The StackedViolin class can be used to to control\n    several visual parameters not available in this function.\n:func:`~scanpy.pl.rank_genes_groups_stacked_violin` to plot marker genes identified\n    using the :func:`~scanpy.tl.rank_genes_groups` function.\n\nExamples\n-------\n\nVisualization of violin plots of a few genes grouped by the category `bulk_labels`:\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.stacked_violin(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nSame visualization but passing var_names as dict, which adds a grouping of\nthe genes on top of the image:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.stacked_violin(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nGet StackedViolin object for fine tuning\n\n.. plot::\n    :context: close-figs\n\n    vp = sc.pl.stacked_violin(adata, markers, 'bulk_labels', return_fig=True)\n    vp.add_totals().style(ylim=(0,5)).show()\n\nThe axes used can be obtained using the get_axes() method:\n\n.. code-block:: python\n\n    axes_dict = vp.get_axes()\n    print(axes_dict)",
        "description": "Stacked violin plots.Makes a compact image composed of individual violin plots\n(from :func:`~seaborn.violinplot`) stacked on top of each other.\nUseful to visualize gene expression per cluster.\n\nWraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.\n\nThis function provides a convenient interface to the\n:class:`~scanpy.pl.StackedViolin` class. If you need more flexibility,\nyou should use :class:`~scanpy.pl.StackedViolin` directly.",
        "example": "Examples\n-------\n\nVisualization of violin plots of a few genes grouped by the category `bulk_labels`:\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.stacked_violin(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nSame visualization but passing var_names as dict, which adds a grouping of\nthe genes on top of the image:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.stacked_violin(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nGet StackedViolin object for fine tuning\n\n.. plot::\n    :context: close-figs\n\n    vp = sc.pl.stacked_violin(adata, markers, 'bulk_labels', return_fig=True)\n    vp.add_totals().style(ylim=(0,5)).show()\n\nThe axes used can be obtained using the get_axes() method:\n\n.. code-block:: python\n\n    axes_dict = vp.get_axes()\n    print(axes_dict)",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.stacked_violin(adata=$, var_names=@, groupby=@, log=@, use_raw=@, num_categories=@, title=@, colorbar_title=@, figsize=@, dendrogram=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, standard_scale=$, var_group_rotation=@, layer=@, stripplot=@, jitter=@, size=@, scale=$, yticklabels=@, order=@, swap_axes=@, show=@, save=@, return_fig=@, row_palette=@, cmap=@, ax=$, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.metrics.morans_i": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": null,
                "optional_value": true
            },
            "vals": {
                "type": "Optional[Union[ndarray, spmatrix]]",
                "default": "None",
                "optional": true,
                "description": "The values",
                "optional_value": true
            },
            "use_graph": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key to use for graph in anndata object. If not provided, default\nneighbors connectivities will be used instead.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `adata.layers` to choose `vals`.",
                "optional_value": false
            },
            "obsm": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `adata.obsm` to choose `vals`.",
                "optional_value": false
            },
            "obsp": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `adata.obsp` to choose `vals`.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use `adata.raw.X` for `vals`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Union[ndarray, float]",
            "description": "If vals is two dimensional, returns a 1 dimensional ndarray array. Returns\na scalar if `vals` is 1d."
        },
        "Docstring": "Calculate Moran\u2019s I Global Autocorrelation Statistic.\n\nMoran\u2019s I is a global autocorrelation statistic for some measure on a graph. It is commonly used in\nspatial data analysis to assess autocorrelation on a 2D grid. It is closely related to Geary's C,\nbut not identical. More info can be found `here <https://en.wikipedia.org/wiki/Moran%27s_I>`_.\n\n.. math::\n\n    I =\n        \\frac{\n            N \\sum_{i, j} w_{i, j} z_{i} z_{j}\n        }{\n            S_{0} \\sum_{i} z_{i}^{2}\n        }\n\nParams\n------\nadata\nvals\n    Values to calculate Moran's I for. If this is two dimensional, should\n    be of shape `(n_features, n_cells)`. Otherwise should be of shape\n    `(n_cells,)`. This matrix can be selected from elements of the anndata\n    object by using key word arguments: `layer`, `obsm`, `obsp`, or\n    `use_raw`.\nuse_graph\n    Key to use for graph in anndata object. If not provided, default\n    neighbors connectivities will be used instead.\nlayer\n    Key for `adata.layers` to choose `vals`.\nobsm\n    Key for `adata.obsm` to choose `vals`.\nobsp\n    Key for `adata.obsp` to choose `vals`.\nuse_raw\n    Whether to use `adata.raw.X` for `vals`.\n\n\nThis function can also be called on the graph and values directly. In this case\nthe signature looks like:\n\nParams\n------\ng\n    The graph\nvals\n    The values\n\n\nSee the examples for more info.\n\nReturns\n-------\nIf vals is two dimensional, returns a 1 dimensional ndarray array. Returns\na scalar if `vals` is 1d.\n\n\nExamples\n--------\n\nCalculate Morans I for each components of a dimensionality reduction:\n\n.. code:: python\n\n    import scanpy as sc, numpy as np\n\n    pbmc = sc.datasets.pbmc68k_processed()\n    pc_c = sc.metrics.morans_i(pbmc, obsm=\"X_pca\")\n\n\nIt's equivalent to call the function directly on the underlying arrays:\n\n.. code:: python\n\n    alt = sc.metrics.morans_i(pbmc.obsp[\"connectivities\"], pbmc.obsm[\"X_pca\"].T)\n    np.testing.assert_array_equal(pc_c, alt)",
        "description": "Calculate Moran\u2019s I Global Autocorrelation Statistic.Moran\u2019s I is a global autocorrelation statistic for some measure on a graph. It is commonly used in\nspatial data analysis to assess autocorrelation on a 2D grid. It is closely related to Geary's C,\nbut not identical. More info can be found `here <https://en.wikipedia.org/wiki/Moran%27s_I>`_.\n\n.. math::\n\n    I =\n        \\frac{\n            N \\sum_{i, j} w_{i, j} z_{i} z_{j}\n        }{\n            S_{0} \\sum_{i} z_{i}^{2}\n        }",
        "example": "Examples\n--------\n\nCalculate Morans I for each components of a dimensionality reduction:\n\n.. code:: python\n\n    import scanpy as sc, numpy as np\n\n    pbmc = sc.datasets.pbmc68k_processed()\n    pc_c = sc.metrics.morans_i(pbmc, obsm=\"X_pca\")\n\n\nIt's equivalent to call the function directly on the underlying arrays:\n\n.. code:: python\n\n    alt = sc.metrics.morans_i(pbmc.obsp[\"connectivities\"], pbmc.obsm[\"X_pca\"].T)\n    np.testing.assert_array_equal(pc_c, alt)",
        "api_type": "function",
        "api_calling": [
            "scanpy.metrics.morans_i(adata=$, vals=$, use_graph=@, layer=@, obsm=@, obsp=@, use_raw=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.tracksplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called\nwith default parameters.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`.\nOtherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "A list of :class:`~matplotlib.axes.Axes`."
        },
        "Docstring": "In this type of plot each var_name is plotted as a filled line plot where the\ny values correspond to the var_name values and x is each of the cells. Best results\nare obtained when using raw counts that are not log.\n\n`groupby` is required to sort and order the values using the respective group\nand should be a categorical value.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nvar_names\n    `var_names` should be a valid subset of `adata.var_names`.\n    If `var_names` is a mapping, then the key is used as label\n    to group the values (see `var_group_labels`). The mapping values\n    should be sequences of valid `adata.var_names`. In this\n    case either coloring or 'brackets' are used for the grouping\n    of var names depending on the plot. When `var_names` is a mapping,\n    then the `var_group_labels` and `var_group_positions` are set.\ngroupby\n    The key of the observation grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlog\n    Plot on logarithmic axis.\nnum_categories\n    Only used if groupby observation is not categorical. This value\n    determines the number of groups into which the groupby observation\n    should be subdivided.\ncategories_order\n    Order in which to show the categories. Note: add_dendrogram or add_totals\n    can change the categories order.\nfigsize\n    Figure size when `multi_panel=True`.\n    Otherwise the `rcParam['figure.figsize]` value is used.\n    Format is (width, height)\ndendrogram\n    If True or a valid dendrogram key, a dendrogram based on the hierarchical\n    clustering between the `groupby` categories is added.\n    The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n    If `tl.dendrogram` has not been called previously the function is called\n    with default parameters.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols.\n    By default `var_names` refer to the index column of the `.var` DataFrame.\n    Setting this option allows alternative names to be used.\nvar_group_positions\n    Use this parameter to highlight groups of `var_names`.\n    This will draw a 'bracket' or a color block between the given start and end\n    positions. If the parameter `var_group_labels` is set, the corresponding\n    labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n    will add a bracket between the fourth `var_name` and the tenth `var_name`.\n    By giving more positions, more brackets/color blocks are drawn.\nvar_group_labels\n    Labels for each of the `var_group_positions` that want to be highlighted.\nvar_group_rotation\n    Label rotation degrees.\n    By default, labels larger than 4 characters are rotated 90 degrees.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n    If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n**kwds\n    Are passed to :func:`~seaborn.heatmap`.\n\nReturns\n-------\nA list of :class:`~matplotlib.axes.Axes`.\n\nExamples\n--------\n\nUsing var_names as list:\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.tracksplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nUsing var_names as dict:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.tracksplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\npl.rank_genes_groups_tracksplot: to plot marker genes identified using the :func:`~scanpy.tl.rank_genes_groups` function.",
        "description": "In this type of plot each var_name is plotted as a filled line plot where they values correspond to the var_name values and x is each of the cells. Best results\nare obtained when using raw counts that are not log.\n\n`groupby` is required to sort and order the values using the respective group\nand should be a categorical value.",
        "example": "Examples\n--------\n\nUsing var_names as list:\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.tracksplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nUsing var_names as dict:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.tracksplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\npl.rank_genes_groups_tracksplot: to plot marker genes identified using the :func:`~scanpy.tl.rank_genes_groups` function.",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.tracksplot(adata=$, var_names=@, groupby=@, use_raw=@, log=@, dendrogram=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, layer=@, show=@, save=@, figsize=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.harmony_integrate": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "The name of the column in ``adata.obs`` that differentiates\namong experiments/batches.",
                "optional_value": false
            },
            "basis": {
                "type": "str",
                "default": "X_pca",
                "optional": true,
                "description": "The name of the field in ``adata.obsm`` where the PCA table is\nstored. Defaults to ``'X_pca'``, which is the default for\n``sc.tl.pca()``.",
                "optional_value": false
            },
            "adjusted_basis": {
                "type": "str",
                "default": "X_pca_harmony",
                "optional": true,
                "description": "The name of the field in ``adata.obsm`` where the adjusted PCA\ntable will be stored after running this function. Defaults to\n``X_pca_harmony``.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Updates adata with the field ``adata.obsm[obsm_out_field]``,\ncontaining principal components adjusted by Harmony such that\ndifferent experiments are integrated."
        },
        "Docstring": "Use harmonypy [Korunsky19]_ to integrate different experiments.\n\nHarmony [Korunsky19]_ is an algorithm for integrating single-cell\ndata from multiple experiments. This function uses the python\nport of Harmony, ``harmonypy``, to integrate single-cell data\nstored in an AnnData object. As Harmony works by adjusting the\nprincipal components, this function should be run after performing\nPCA but before computing the neighbor graph, as illustrated in the\nexample below.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nkey\n    The name of the column in ``adata.obs`` that differentiates\n    among experiments/batches.\nbasis\n    The name of the field in ``adata.obsm`` where the PCA table is\n    stored. Defaults to ``'X_pca'``, which is the default for\n    ``sc.tl.pca()``.\nadjusted_basis\n    The name of the field in ``adata.obsm`` where the adjusted PCA\n    table will be stored after running this function. Defaults to\n    ``X_pca_harmony``.\nkwargs\n    Any additional arguments will be passed to\n    ``harmonypy.run_harmony()``.\n\nReturns\n-------\nUpdates adata with the field ``adata.obsm[obsm_out_field]``,\ncontaining principal components adjusted by Harmony such that\ndifferent experiments are integrated.\n\nExample\n-------\nFirst, load libraries and example dataset, and preprocess.\n\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> adata = sc.datasets.pbmc3k()\n>>> sc.pp.recipe_zheng17(adata)\n>>> sc.tl.pca(adata)\n\nWe now arbitrarily assign a batch metadata variable to each cell\nfor the sake of example, but during real usage there would already\nbe a column in ``adata.obs`` giving the experiment each cell came\nfrom.\n\n>>> adata.obs['batch'] = 1350*['a'] + 1350*['b']\n\nFinally, run harmony. Afterwards, there will be a new table in\n``adata.obsm`` containing the adjusted PC's.\n\n>>> sce.pp.harmony_integrate(adata, 'batch')\n>>> 'X_pca_harmony' in adata.obsm\nTrue",
        "description": "Use harmonypy [Korunsky19]_ to integrate different experiments.Harmony [Korunsky19]_ is an algorithm for integrating single-cell\ndata from multiple experiments. This function uses the python\nport of Harmony, ``harmonypy``, to integrate single-cell data\nstored in an AnnData object. As Harmony works by adjusting the\nprincipal components, this function should be run after performing\nPCA but before computing the neighbor graph, as illustrated in the\nexample below.",
        "example": "Example\n-------\nFirst, load libraries and example dataset, and preprocess.\n\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> adata = sc.datasets.pbmc3k()\n>>> sc.pp.recipe_zheng17(adata)\n>>> sc.tl.pca(adata)\n\nWe now arbitrarily assign a batch metadata variable to each cell\nfor the sake of example, but during real usage there would already\nbe a column in ``adata.obs`` giving the experiment each cell came\nfrom.\n\n>>> adata.obs['batch'] = 1350*['a'] + 1350*['b']\n\nFinally, run harmony. Afterwards, there will be a new table in\n``adata.obsm`` containing the adjusted PC's.\n\n>>> sce.pp.harmony_integrate(adata, 'batch')\n>>> 'X_pca_harmony' in adata.obsm\nTrue",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.harmony_integrate(adata=$, key=@, basis=@, adjusted_basis=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.pbmc3k_processed": {
        "Parameters": {},
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "Processed 3k PBMCs from 10x Genomics.\n\nProcessed using the `basic tutorial <https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html>`__.\n\nReturns\n-------\nAnnotated data matrix.",
        "description": "Processed 3k PBMCs from 10x Genomics.Processed using the `basic tutorial <https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html>`__.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.pbmc3k_processed()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.violin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "keys": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "Keys for accessing variables of `.var_names` or fields of `.obs`.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.",
                "optional_value": false
            },
            "stripplot": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Add a stripplot on top of the violin plot.\nSee :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "jitter": {
                "type": "Union[float, bool]",
                "default": "True",
                "optional": true,
                "description": "Add jitter to the stripplot (only when stripplot is True)\nSee :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "size": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Size of the jitter points.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By\ndefault adata.raw.X is plotted. If `use_raw=False` is set,\nthen `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "scale": {
                "type": "Literal[area, count, width]",
                "default": "width",
                "optional": true,
                "description": "The method used to scale the width of each violin.\nIf 'width' (the default), each violin will have the same width.\nIf 'area', each violin will have the same area.\nIf 'count', a violin\u2019s width corresponds to the number of observations.",
                "optional_value": true
            },
            "order": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Order in which to show the categories.",
                "optional_value": false
            },
            "multi_panel": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Display keys in multiple panels also when `groupby is not None`.",
                "optional_value": false
            },
            "xlabel": {
                "type": "str",
                "default": "",
                "optional": true,
                "description": "Label of the x axis. Defaults to `groupby` if `rotation` is `None`,\notherwise, no label is shown.",
                "optional_value": false
            },
            "ylabel": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Label of the y axis. If `None` and `groupby` is `None`, defaults\nto `'value'`. If `None` and `groubpy` is not `None`, defaults to `keys`.",
                "optional_value": false
            },
            "rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Rotation of xtick labels.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "A :class:`~matplotlib.axes.Axes` object if `ax` is `None` else `None`."
        },
        "Docstring": "Violin plot.\n\nWraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nkeys\n    Keys for accessing variables of `.var_names` or fields of `.obs`.\ngroupby\n    The key of the observation grouping to consider.\nlog\n    Plot on logarithmic axis.\nuse_raw\n    Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\nstripplot\n    Add a stripplot on top of the violin plot.\n    See :func:`~seaborn.stripplot`.\njitter\n    Add jitter to the stripplot (only when stripplot is True)\n    See :func:`~seaborn.stripplot`.\nsize\n    Size of the jitter points.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By\n    default adata.raw.X is plotted. If `use_raw=False` is set,\n    then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\nscale\n    The method used to scale the width of each violin.\n    If 'width' (the default), each violin will have the same width.\n    If 'area', each violin will have the same area.\n    If 'count', a violin\u2019s width corresponds to the number of observations.\norder\n    Order in which to show the categories.\nmulti_panel\n    Display keys in multiple panels also when `groupby is not None`.\nxlabel\n    Label of the x axis. Defaults to `groupby` if `rotation` is `None`,\n    otherwise, no label is shown.\nylabel\n    Label of the y axis. If `None` and `groupby` is `None`, defaults\n    to `'value'`. If `None` and `groubpy` is not `None`, defaults to `keys`.\nrotation\n    Rotation of xtick labels.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n**kwds\n    Are passed to :func:`~seaborn.violinplot`.\n\nReturns\n-------\nA :class:`~matplotlib.axes.Axes` object if `ax` is `None` else `None`.\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.pl.violin(adata, keys='S_score')\n\nPlot by category. Rotate x-axis labels so that they do not overlap.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.violin(adata, keys='S_score', groupby='bulk_labels', rotation=90)\n\nSet order of categories to be plotted or select specific categories to be plotted.\n\n.. plot::\n    :context: close-figs\n\n    groupby_order = ['CD34+', 'CD19+ B']\n    sc.pl.violin(adata, keys='S_score', groupby='bulk_labels', rotation=90,\n        order=groupby_order)\n\nPlot multiple keys.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.violin(adata, keys=['S_score', 'G2M_score'], groupby='bulk_labels',\n        rotation=90)\n\nFor large datasets consider omitting the overlaid scatter plot.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.violin(adata, keys='S_score', stripplot=False)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\npl.stacked_violin",
        "description": "Violin plot.Wraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.pl.violin(adata, keys='S_score')\n\nPlot by category. Rotate x-axis labels so that they do not overlap.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.violin(adata, keys='S_score', groupby='bulk_labels', rotation=90)\n\nSet order of categories to be plotted or select specific categories to be plotted.\n\n.. plot::\n    :context: close-figs\n\n    groupby_order = ['CD34+', 'CD19+ B']\n    sc.pl.violin(adata, keys='S_score', groupby='bulk_labels', rotation=90,\n        order=groupby_order)\n\nPlot multiple keys.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.violin(adata, keys=['S_score', 'G2M_score'], groupby='bulk_labels',\n        rotation=90)\n\nFor large datasets consider omitting the overlaid scatter plot.\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.violin(adata, keys='S_score', stripplot=False)\n\n.. currentmodule:: scanpy\n\nSee also\n--------\npl.stacked_violin",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.violin(adata=$, keys=@, groupby=@, log=@, use_raw=@, stripplot=@, jitter=@, size=@, layer=@, scale=$, order=@, multi_panel=@, xlabel=@, ylabel=@, rotation=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.normalize_per_cell": {
        "Parameters": {
            "data": {
                "type": "Union[AnnData, ndarray, spmatrix]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\nto cells and columns to genes.",
                "optional_value": true
            },
            "counts_per_cell_after": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If `None`, after normalization, each cell has a total count equal\nto the median of the *counts_per_cell* before normalization.",
                "optional_value": false
            },
            "counts_per_cell": {
                "type": "Optional[ndarray]",
                "default": "None",
                "optional": true,
                "description": "Precomputed counts per cell.",
                "optional_value": true
            },
            "key_n_counts": {
                "type": "str",
                "default": "n_counts",
                "optional": true,
                "description": "Name of the field in `adata.obs` where the total counts per cell are\nstored.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If an :class:`~anndata.AnnData` is passed, determines whether a copy\nis returned.",
                "optional_value": false
            },
            "layers": {
                "type": "Union[Literal[all], Iterable[str]]",
                "default": "()",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[Literal[after, X]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "min_counts": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Cells with counts less than `min_counts` are filtered out during\nnormalization.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Returns or updates `adata` with normalized version of the original\n`adata.X`, depending on `copy`."
        },
        "Docstring": "Normalize total counts per cell.\n\n.. warning::\n    .. deprecated:: 1.3.7\n        Use :func:`~scanpy.pp.normalize_total` instead.\n        The new function is equivalent to the present\n        function, except that\n\n        * the new function doesn't filter cells based on `min_counts`,\n          use :func:`~scanpy.pp.filter_cells` if filtering is needed.\n        * some arguments were renamed\n        * `copy` is replaced by `inplace`\n\nNormalize each cell by total counts over all genes, so that every cell has\nthe same total count after normalization.\n\nSimilar functions are used, for example, by Seurat [Satija15]_, Cell Ranger\n[Zheng17]_ or SPRING [Weinreb17]_.\n\nParameters\n----------\ndata\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\n    to cells and columns to genes.\ncounts_per_cell_after\n    If `None`, after normalization, each cell has a total count equal\n    to the median of the *counts_per_cell* before normalization.\ncounts_per_cell\n    Precomputed counts per cell.\nkey_n_counts\n    Name of the field in `adata.obs` where the total counts per cell are\n    stored.\ncopy\n    If an :class:`~anndata.AnnData` is passed, determines whether a copy\n    is returned.\nmin_counts\n    Cells with counts less than `min_counts` are filtered out during\n    normalization.\n\nReturns\n-------\nReturns or updates `adata` with normalized version of the original\n`adata.X`, depending on `copy`.\n\nExamples\n--------\n>>> import scanpy as sc\n>>> adata = AnnData(np.array([[1, 0], [3, 0], [5, 6]]))\n>>> print(adata.X.sum(axis=1))\n[  1.   3.  11.]\n>>> sc.pp.normalize_per_cell(adata)\n>>> print(adata.obs)\n>>> print(adata.X.sum(axis=1))\n   n_counts\n0       1.0\n1       3.0\n2      11.0\n[ 3.  3.  3.]\n>>> sc.pp.normalize_per_cell(\n>>>     adata, counts_per_cell_after=1,\n>>>     key_n_counts='n_counts2',\n>>> )\n>>> print(adata.obs)\n>>> print(adata.X.sum(axis=1))\n   n_counts  n_counts2\n0       1.0        3.0\n1       3.0        3.0\n2      11.0        3.0\n[ 1.  1.  1.]",
        "description": "Normalize total counts per cell... warning::\n    .. deprecated:: 1.3.7\n        Use :func:`~scanpy.pp.normalize_total` instead.\n        The new function is equivalent to the present\n        function, except that\n\n        * the new function doesn't filter cells based on `min_counts`,\n          use :func:`~scanpy.pp.filter_cells` if filtering is needed.\n        * some arguments were renamed\n        * `copy` is replaced by `inplace`\n\nNormalize each cell by total counts over all genes, so that every cell has\nthe same total count after normalization.\n\nSimilar functions are used, for example, by Seurat [Satija15]_, Cell Ranger\n[Zheng17]_ or SPRING [Weinreb17]_.",
        "example": "Examples\n--------\n>>> import scanpy as sc\n>>> adata = AnnData(np.array([[1, 0], [3, 0], [5, 6]]))\n>>> print(adata.X.sum(axis=1))\n[  1.   3.  11.]\n>>> sc.pp.normalize_per_cell(adata)\n>>> print(adata.obs)\n>>> print(adata.X.sum(axis=1))\n   n_counts\n0       1.0\n1       3.0\n2      11.0\n[ 3.  3.  3.]\n>>> sc.pp.normalize_per_cell(\n>>>     adata, counts_per_cell_after=1,\n>>>     key_n_counts='n_counts2',\n>>> )\n>>> print(adata.obs)\n>>> print(adata.X.sum(axis=1))\n   n_counts  n_counts2\n0       1.0        3.0\n1       3.0        3.0\n2      11.0        3.0\n[ 1.  1.  1.]",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.normalize_per_cell(data=$, counts_per_cell_after=@, counts_per_cell=$, key_n_counts=@, copy=@, layers=@, use_rep=$, min_counts=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.metrics.confusion_matrix": {
        "Parameters": {
            "orig": {
                "type": "Union[Series, ndarray, Sequence[]]",
                "default": null,
                "optional": false,
                "description": "Original labels.",
                "optional_value": true
            },
            "new": {
                "type": "Union[Series, ndarray, Sequence[]]",
                "default": null,
                "optional": false,
                "description": "New labels.",
                "optional_value": true
            },
            "data": {
                "type": "Optional[DataFrame]",
                "default": "None",
                "optional": true,
                "description": "Optional dataframe to fill entries from.",
                "optional_value": true
            },
            "normalize": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Should the confusion matrix be normalized?",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": ""
        },
        "Docstring": "Given an original and new set of labels, create a labelled confusion matrix.\n\nParameters `orig` and `new` can either be entries in data or categorical arrays\nof the same size.\n\nParams\n------\norig\n    Original labels.\nnew\n    New labels.\ndata\n    Optional dataframe to fill entries from.\nnormalize\n    Should the confusion matrix be normalized?\n\n\nExamples\n--------\n\n.. plot::\n\n    import scanpy as sc; import seaborn as sns\n    pbmc = sc.datasets.pbmc68k_reduced()\n    cmtx = sc.metrics.confusion_matrix(\"bulk_labels\", \"louvain\", pbmc.obs)\n    sns.heatmap(cmtx)",
        "description": "Given an original and new set of labels, create a labelled confusion matrix.Parameters `orig` and `new` can either be entries in data or categorical arrays\nof the same size.",
        "example": "Examples\n--------\n\n.. plot::\n\n    import scanpy as sc; import seaborn as sns\n    pbmc = sc.datasets.pbmc68k_reduced()\n    cmtx = sc.metrics.confusion_matrix(\"bulk_labels\", \"louvain\", pbmc.obs)\n    sns.heatmap(cmtx)",
        "api_type": "function",
        "api_calling": [
            "scanpy.metrics.confusion_matrix(orig=$, new=$, data=$, normalize=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pl.scrublet_score_distribution": {
        "Parameters": {
            "adata": {
                "type": null,
                "default": null,
                "optional": false,
                "description": "An annData object resulting from func:`~scanpy.external.scrublet`.",
                "optional_value": true
            },
            "scale_hist_obs": {
                "type": "str",
                "default": "log",
                "optional": true,
                "description": "Set y axis scale transformation in matplotlib for the plot of observed\ntranscriptomes (e.g. \"linear\", \"log\", \"symlog\", \"logit\")",
                "optional_value": false
            },
            "scale_hist_sim": {
                "type": "str",
                "default": "linear",
                "optional": true,
                "description": "Set y axis scale transformation in matplotlib for the plot of simulated\ndoublets (e.g. \"linear\", \"log\", \"symlog\", \"logit\")",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "(8, 3)",
                "optional": true,
                "description": "width, height",
                "optional_value": false
            },
            "return_fig": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "show": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `return_fig` is True, a :class:`~matplotlib.figure.Figure`.\nIf `show==False` a list of :class:`~matplotlib.axes.Axes`.\nSee also\n:func:`~scanpy.external.pp.scrublet`: Main way of running Scrublet, runs\npreprocessing, doublet simulation and calling.\n:func:`~scanpy.external.pp.scrublet_simulate_doublets`: Run Scrublet's doublet\nsimulation separately for advanced usage."
        },
        "Docstring": "Plot histogram of doublet scores for observed transcriptomes and simulated doublets.\n\nThe histogram for simulated doublets is useful for determining the correct doublet\nscore threshold.\n\nScrublet must have been run previously with the input object.\n\nParameters\n----------\nadata\n    An annData object resulting from func:`~scanpy.external.scrublet`.\nscale_hist_obs\n    Set y axis scale transformation in matplotlib for the plot of observed\n    transcriptomes (e.g. \"linear\", \"log\", \"symlog\", \"logit\")\nscale_hist_sim\n    Set y axis scale transformation in matplotlib for the plot of simulated\n    doublets (e.g. \"linear\", \"log\", \"symlog\", \"logit\")\nfigsize\n    width, height\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n\nReturns\n-------\nIf `return_fig` is True, a :class:`~matplotlib.figure.Figure`.\nIf `show==False` a list of :class:`~matplotlib.axes.Axes`.\n\nSee also\n--------\n:func:`~scanpy.external.pp.scrublet`: Main way of running Scrublet, runs\n    preprocessing, doublet simulation and calling.\n:func:`~scanpy.external.pp.scrublet_simulate_doublets`: Run Scrublet's doublet\n    simulation separately for advanced usage.",
        "description": "Plot histogram of doublet scores for observed transcriptomes and simulated doublets.The histogram for simulated doublets is useful for determining the correct doublet\nscore threshold.\n\nScrublet must have been run previously with the input object.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pl.scrublet_score_distribution(adata=$, scale_hist_obs=@, scale_hist_sim=@, figsize=@, return_fig=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.paga_path": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An annotated data matrix.",
                "optional_value": true
            },
            "nodes": {
                "type": "Sequence[Union[str, int]]",
                "default": null,
                "optional": false,
                "description": "A path through nodes of the abstracted graph, that is, names or indices\n(within `.categories`) of groups that have been used to run PAGA.",
                "optional_value": false
            },
            "keys": {
                "type": "Sequence[str]",
                "default": null,
                "optional": false,
                "description": "Either variables in `adata.var_names` or annotations in\n`adata.obs`. They are plotted using `color_map`.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Use `adata.raw` for retrieving gene expressions if it has been set.",
                "optional_value": false
            },
            "annotations": {
                "type": "Sequence[str]",
                "default": "('dpt_pseudotime',)",
                "optional": true,
                "description": "Plot these keys with `color_maps_annotations`. Need to be keys for\n`adata.obs`.",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[str, Colormap]]",
                "default": "None",
                "optional": true,
                "description": "Matplotlib colormap.",
                "optional_value": false
            },
            "color_maps_annotations": {
                "type": "Mapping[str, Union[str, Colormap]]",
                "default": "{'dpt_pseudotime': 'Greys'}",
                "optional": true,
                "description": "Color maps for plotting the annotations. Keys of the dictionary must\nappear in `annotations`.",
                "optional_value": false
            },
            "palette_groups": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Ususally, use the same `sc.pl.palettes...` as used for coloring the\nabstracted graph.",
                "optional_value": false
            },
            "n_avg": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Number of data points to include in computation of running average.",
                "optional_value": false
            },
            "groups_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key of the grouping used to run PAGA. If `None`, defaults to\n`adata.uns['paga']['groups']`.",
                "optional_value": false
            },
            "xlim": {
                "type": "tuple[Optional[int], Optional[int]]",
                "default": "(None, None)",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "left_margin": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "ytick_fontsize": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "title_fontsize": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "show_node_names": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Plot the node names on the nodes bar.",
                "optional_value": false
            },
            "show_yticks": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show the y ticks.",
                "optional_value": false
            },
            "show_colorbar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show the colorbar.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Optional[Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "normalize_to_zero_one": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Shift and scale the running average to [0, 1] per gene.",
                "optional_value": false
            },
            "as_heatmap": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Plot the timeseries as heatmap. If not plotting as heatmap,\n`annotations` have no effect.",
                "optional_value": false
            },
            "return_data": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return the timeseries data in addition to the axes if `True`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on \\{`'.pdf'`, `'.png'`, `'.svg'`\\}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Axes]",
            "description": "A :class:`~matplotlib.axes.Axes` object, if `ax` is `None`, else `None`.\nIf `return_data`, return the timeseries data in addition to an axes."
        },
        "Docstring": "Gene expression and annotation changes along paths in the abstracted graph.\n\nParameters\n----------\nadata\n    An annotated data matrix.\nnodes\n    A path through nodes of the abstracted graph, that is, names or indices\n    (within `.categories`) of groups that have been used to run PAGA.\nkeys\n    Either variables in `adata.var_names` or annotations in\n    `adata.obs`. They are plotted using `color_map`.\nuse_raw\n    Use `adata.raw` for retrieving gene expressions if it has been set.\nannotations\n    Plot these keys with `color_maps_annotations`. Need to be keys for\n    `adata.obs`.\ncolor_map\n    Matplotlib colormap.\ncolor_maps_annotations\n    Color maps for plotting the annotations. Keys of the dictionary must\n    appear in `annotations`.\npalette_groups\n    Ususally, use the same `sc.pl.palettes...` as used for coloring the\n    abstracted graph.\nn_avg\n    Number of data points to include in computation of running average.\ngroups_key\n    Key of the grouping used to run PAGA. If `None`, defaults to\n    `adata.uns['paga']['groups']`.\nas_heatmap\n    Plot the timeseries as heatmap. If not plotting as heatmap,\n    `annotations` have no effect.\nshow_node_names\n    Plot the node names on the nodes bar.\nshow_colorbar\n    Show the colorbar.\nshow_yticks\n    Show the y ticks.\nnormalize_to_zero_one\n    Shift and scale the running average to [0, 1] per gene.\nreturn_data\n    Return the timeseries data in addition to the axes if `True`.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on \\{`'.pdf'`, `'.png'`, `'.svg'`\\}.\nax\n     A matplotlib axes object.\n\nReturns\n-------\nA :class:`~matplotlib.axes.Axes` object, if `ax` is `None`, else `None`.\nIf `return_data`, return the timeseries data in addition to an axes.",
        "description": "Gene expression and annotation changes along paths in the abstracted graph.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.paga_path(adata=$, nodes=@, keys=@, use_raw=@, annotations=@, color_map=@, color_maps_annotations=@, palette_groups=@, n_avg=@, groups_key=@, xlim=@, title=@, left_margin=$, ytick_fontsize=@, title_fontsize=@, show_node_names=@, show_yticks=@, show_colorbar=@, legend_fontsize=@, legend_fontweight=@, normalize_to_zero_one=@, as_heatmap=@, return_data=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.rank_genes_groups_matrixplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The groups for which to show the gene ranking.",
                "optional_value": false
            },
            "n_genes": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of genes to show. This can be a negative number to show for\nexample the down regulated genes. eg: num_genes=-10. Is ignored if\n`gene_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the observation grouping to consider. By default,\nthe groupby is chosen from the rank genes groups parameter but\nother groupby options can be used.  It is expected that\ngroupby is a categorical. If groupby is not a categorical observation,\nit would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).",
                "optional_value": false
            },
            "values_to_plot": {
                "type": "Optional[Literal[scores, logfoldchanges, pvals, pvals_adj, log10_pvals, log10_pvals_adj]]",
                "default": "None",
                "optional": true,
                "description": "Instead of the mean gene value, plot the values computed by `sc.rank_genes_groups`.\nThe options are: ['scores', 'logfoldchanges', 'pvals', 'pvals_adj',\n'log10_pvals', 'log10_pvals_adj']. When plotting logfoldchanges a divergent\ncolormap is recommended. See examples below.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "Genes to plot. Sometimes is useful to pass a specific list of var names (e.g. genes)\nto check their fold changes or p-values, instead of the top/bottom genes. The\nvar_names could be a dictionary or a list as in :func:`~scanpy.pl.dotplot` or\n:func:`~scanpy.pl.matrixplot`. See examples below.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Value to filter genes in groups if their logfoldchange is less than the\nmin_logfoldchange",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key used to store the ranking results in `adata.uns`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`MatrixPlot` object. Useful for fine-tuning\nthe plot. Takes precedence over `show=False`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "If `return_fig` is `True`, returns a :class:`MatrixPlot` object,\nelse if `show` is false, return axes dict"
        },
        "Docstring": "Plot ranking of genes using matrixplot plot (see :func:`~scanpy.pl.matrixplot`)\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroups\n    The groups for which to show the gene ranking.\nn_genes\n    Number of genes to show. This can be a negative number to show for\n    example the down regulated genes. eg: num_genes=-10. Is ignored if\n    `gene_names` is passed.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\ngroupby\n    The key of the observation grouping to consider. By default,\n    the groupby is chosen from the rank genes groups parameter but\n    other groupby options can be used.  It is expected that\n    groupby is a categorical. If groupby is not a categorical observation,\n    it would be subdivided into `num_categories` (see :func:`~scanpy.pl.dotplot`).\nmin_logfoldchange\n    Value to filter genes in groups if their logfoldchange is less than the\n    min_logfoldchange\nkey\n    Key used to store the ranking results in `adata.uns`.\nvalues_to_plot\n    Instead of the mean gene value, plot the values computed by `sc.rank_genes_groups`.\n    The options are: ['scores', 'logfoldchanges', 'pvals', 'pvals_adj',\n    'log10_pvals', 'log10_pvals_adj']. When plotting logfoldchanges a divergent\n    colormap is recommended. See examples below.\nvar_names\n    Genes to plot. Sometimes is useful to pass a specific list of var names (e.g. genes)\n    to check their fold changes or p-values, instead of the top/bottom genes. The\n    var_names could be a dictionary or a list as in :func:`~scanpy.pl.dotplot` or\n    :func:`~scanpy.pl.matrixplot`. See examples below.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\nreturn_fig\n    Returns :class:`MatrixPlot` object. Useful for fine-tuning\n    the plot. Takes precedence over `show=False`.\n**kwds\n    Are passed to :func:`~scanpy.pl.matrixplot`.\n\nReturns\n-------\nIf `return_fig` is `True`, returns a :class:`MatrixPlot` object,\nelse if `show` is false, return axes dict\n\nExamples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.rank_genes_groups(adata, 'bulk_labels', n_genes=adata.raw.shape[1])\n\nPlot `logfoldchanges` instead of gene expression. In this case a diverging colormap\nlike `bwr` or `seismic` works better. To center the colormap in zero, the minimum\nand maximum values to plot are set to -4 and 4 respectively.\nAlso, only genes with a log fold change of 3 or more are shown.\n\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_matrixplot(\n        adata,\n        n_genes=4,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )\n\nAlso, the last genes can be plotted. This can be useful to identify genes\nthat are lowly expressed in a group. For this `n_genes=-4` is used\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_matrixplot(\n        adata,\n        n_genes=-4,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )\n\nA list specific genes can be given to check their log fold change. If a\ndictionary, the dictionary keys will be added as labels in the plot.\n\n.. plot::\n    :context: close-figs\n\n    var_names = {\"T-cell\": ['CD3D', 'CD3E', 'IL32'],\n                  'B-cell': ['CD79A', 'CD79B', 'MS4A1'],\n                  'myeloid': ['CST3', 'LYZ'] }\n    sc.pl.rank_genes_groups_matrixplot(\n        adata,\n        var_names=var_names,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )",
        "description": "Plot ranking of genes using matrixplot plot (see :func:`~scanpy.pl.matrixplot`)",
        "example": "Examples\n--------\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.rank_genes_groups(adata, 'bulk_labels', n_genes=adata.raw.shape[1])\n\nPlot `logfoldchanges` instead of gene expression. In this case a diverging colormap\nlike `bwr` or `seismic` works better. To center the colormap in zero, the minimum\nand maximum values to plot are set to -4 and 4 respectively.\nAlso, only genes with a log fold change of 3 or more are shown.\n\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_matrixplot(\n        adata,\n        n_genes=4,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )\n\nAlso, the last genes can be plotted. This can be useful to identify genes\nthat are lowly expressed in a group. For this `n_genes=-4` is used\n\n.. plot::\n    :context: close-figs\n\n    sc.pl.rank_genes_groups_matrixplot(\n        adata,\n        n_genes=-4,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )\n\nA list specific genes can be given to check their log fold change. If a\ndictionary, the dictionary keys will be added as labels in the plot.\n\n.. plot::\n    :context: close-figs\n\n    var_names = {\"T-cell\": ['CD3D', 'CD3E', 'IL32'],\n                  'B-cell': ['CD79A', 'CD79B', 'MS4A1'],\n                  'myeloid': ['CST3', 'LYZ'] }\n    sc.pl.rank_genes_groups_matrixplot(\n        adata,\n        var_names=var_names,\n        values_to_plot=\"logfoldchanges\",\n        cmap='bwr',\n        vmin=-4,\n        vmax=4,\n        min_logfoldchange=3,\n        colorbar_title='log fold change',\n    )",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.rank_genes_groups_matrixplot(adata=$, groups=@, n_genes=@, groupby=@, values_to_plot=$, var_names=@, gene_symbols=@, min_logfoldchange=@, key=@, show=@, save=@, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.queries.enrich": {
        "Parameters": {
            "container": {
                "type": "Union[Iterable[str], Mapping[str, Iterable[str]]]",
                "default": null,
                "optional": false,
                "description": "Contains list of genes you'd like to search. If container is a `dict` all\nenrichment queries are made at once.",
                "optional_value": false
            },
            "org": {
                "type": "str",
                "default": "hsapiens",
                "optional": true,
                "description": "Organism to query. Must be an organism in ensembl biomart. \"hsapiens\",\n\"mmusculus\", \"drerio\", etc.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": "Dataframe of enrichment results."
        },
        "Docstring": "Get enrichment for DE results.\n\nThis is a thin convenience wrapper around the very useful gprofiler_.\n\nThis method dispatches on the first argument, leading to the following two\nsignatures::\n\n    enrich(container, ...)\n    enrich(adata: AnnData, group, key: str, ...)\n\nWhere::\n\n    enrich(adata, group, key, ...) = enrich(adata.uns[key][\"names\"][group], ...)\n\n.. _gprofiler: https://pypi.org/project/gprofiler-official/#description\n\nParameters\n----------\ncontainer\n    Contains list of genes you'd like to search. If container is a `dict` all\n    enrichment queries are made at once.\nadata\n    AnnData object whose group will be looked for.\ngroup\n    The group whose genes should be used for enrichment.\nkey\n    Key in `uns` to find group under.\norg\n    Organism to query. Must be an organism in ensembl biomart. \"hsapiens\",\n    \"mmusculus\", \"drerio\", etc.\ngprofiler_kwargs\n    Keyword arguments to pass to `GProfiler.profile`, see gprofiler_. Some\n    useful options are `no_evidences=False` which reports gene intersections,\n    `sources=['GO:BP']` which limits gene sets to only GO biological processes and\n    `all_results=True` which returns all results including the non-significant ones.\n**kwargs\n    All other keyword arguments are passed to `sc.get.rank_genes_groups_df`. E.g.\n    pval_cutoff, log2fc_min.\n\nReturns\n-------\nDataframe of enrichment results.\n\nExamples\n--------\nUsing `sc.queries.enrich` on a list of genes:\n\n>>> import scanpy as sc\n>>> sc.queries.enrich(['KLF4', 'PAX5', 'SOX2', 'NANOG'], org=\"hsapiens\")\n>>> sc.queries.enrich({'set1':['KLF4', 'PAX5'], 'set2':['SOX2', 'NANOG']}, org=\"hsapiens\")\n\nUsing `sc.queries.enrich` on an :class:`anndata.AnnData` object:\n\n>>> pbmcs = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(pbmcs, \"bulk_labels\")\n>>> sc.queries.enrich(pbmcs, \"CD34+\")",
        "description": "Get enrichment for DE results.This is a thin convenience wrapper around the very useful gprofiler_.\n\nThis method dispatches on the first argument, leading to the following two\nsignatures::\n\n    enrich(container, ...)\n    enrich(adata: AnnData, group, key: str, ...)\n\nWhere::\n\n    enrich(adata, group, key, ...) = enrich(adata.uns[key][\"names\"][group], ...)\n\n.. _gprofiler: https://pypi.org/project/gprofiler-official/#description",
        "example": "Examples\n--------\nUsing `sc.queries.enrich` on a list of genes:\n\n>>> import scanpy as sc\n>>> sc.queries.enrich(['KLF4', 'PAX5', 'SOX2', 'NANOG'], org=\"hsapiens\")\n>>> sc.queries.enrich({'set1':['KLF4', 'PAX5'], 'set2':['SOX2', 'NANOG']}, org=\"hsapiens\")\n\nUsing `sc.queries.enrich` on an :class:`anndata.AnnData` object:\n\n>>> pbmcs = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(pbmcs, \"bulk_labels\")\n>>> sc.queries.enrich(pbmcs, \"CD34+\")",
        "api_type": "function",
        "api_calling": [
            "scanpy.queries.enrich(container=@, org=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.pca": {
        "Parameters": {
            "data": {
                "type": "Union[AnnData, ndarray, spmatrix]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "n_comps": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of principal components to compute. Defaults to 50, or 1 - minimum\ndimension size of selected representation.",
                "optional_value": false
            },
            "zero_center": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "If `True`, compute standard PCA from covariance matrix.\nIf `False`, omit zero-centering variables\n(uses :class:`~sklearn.decomposition.TruncatedSVD`),\nwhich allows to handle sparse input efficiently.\nPassing `None` decides automatically based on sparseness of the data.",
                "optional_value": false
            },
            "svd_solver": {
                "type": "str",
                "default": "arpack",
                "optional": true,
                "description": "SVD solver to use:\n\n`'arpack'` (the default)\n  for the ARPACK wrapper in SciPy (:func:`~scipy.sparse.linalg.svds`)\n`'randomized'`\n  for the randomized algorithm due to Halko (2009).\n`'auto'`\n  chooses automatically depending on the size of the problem.\n`'lobpcg'`\n  An alternative SciPy solver.\n\n.. versionchanged:: 1.4.5\n   Default value changed from `'auto'` to `'arpack'`.\n\nEfficient computation of the principal components of a sparse matrix\ncurrently only works with the `'arpack`' or `'lobpcg'` solvers.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Change to use different initial states for the optimization.",
                "optional_value": false
            },
            "return_info": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Only relevant when not passing an :class:`~anndata.AnnData`:\nsee \u201c**Returns**\u201d.",
                "optional_value": false
            },
            "use_highly_variable": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to use highly variable genes only, stored in\n`.var['highly_variable']`.\nBy default uses them if they have been determined beforehand.",
                "optional_value": false
            },
            "dtype": {
                "type": "str",
                "default": "float32",
                "optional": true,
                "description": "Numpy data type string to which to convert the result.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If an :class:`~anndata.AnnData` is passed, determines whether a copy\nis returned. Is ignored otherwise.",
                "optional_value": false
            },
            "chunked": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, perform an incremental PCA on segments of `chunk_size`.\nThe incremental PCA automatically zero centers and ignores settings of\n`random_seed` and `svd_solver`. If `False`, perform a full PCA.",
                "optional_value": false
            },
            "chunk_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of observations to include in each chunk.\nRequired if `chunked=True` was passed.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Union[AnnData, ndarray, spmatrix]",
            "description": "X_pca : :class:`~scipy.sparse.spmatrix`, :class:`~numpy.ndarray`\nIf `data` is array-like and `return_info=False` was passed,\nthis function only returns `X_pca`\u2026\nadata : anndata.AnnData\n\u2026otherwise if `copy=True` it returns or else adds fields to `adata`:\n`.obsm['X_pca']`\nPCA representation of data.\n`.varm['PCs']`\nThe principal components containing the loadings.\n`.uns['pca']['variance_ratio']`\nRatio of explained variance.\n`.uns['pca']['variance']`\nExplained variance, equivalent to the eigenvalues of the\ncovariance matrix."
        },
        "Docstring": "Principal component analysis [Pedregosa11]_.\n\nComputes PCA coordinates, loadings and variance decomposition.\nUses the implementation of *scikit-learn* [Pedregosa11]_.\n\n.. versionchanged:: 1.5.0\n\n    In previous versions, computing a PCA on a sparse matrix would make a dense copy of\n    the array for mean centering.\n    As of scanpy 1.5.0, mean centering is implicit.\n    While results are extremely similar, they are not exactly the same.\n    If you would like to reproduce the old results, pass a dense array.\n\nParameters\n----------\ndata\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\nn_comps\n    Number of principal components to compute. Defaults to 50, or 1 - minimum\n    dimension size of selected representation.\nzero_center\n    If `True`, compute standard PCA from covariance matrix.\n    If `False`, omit zero-centering variables\n    (uses :class:`~sklearn.decomposition.TruncatedSVD`),\n    which allows to handle sparse input efficiently.\n    Passing `None` decides automatically based on sparseness of the data.\nsvd_solver\n    SVD solver to use:\n\n    `'arpack'` (the default)\n      for the ARPACK wrapper in SciPy (:func:`~scipy.sparse.linalg.svds`)\n    `'randomized'`\n      for the randomized algorithm due to Halko (2009).\n    `'auto'`\n      chooses automatically depending on the size of the problem.\n    `'lobpcg'`\n      An alternative SciPy solver.\n\n    .. versionchanged:: 1.4.5\n       Default value changed from `'auto'` to `'arpack'`.\n\n    Efficient computation of the principal components of a sparse matrix\n    currently only works with the `'arpack`' or `'lobpcg'` solvers.\n\nrandom_state\n    Change to use different initial states for the optimization.\nreturn_info\n    Only relevant when not passing an :class:`~anndata.AnnData`:\n    see \u201c**Returns**\u201d.\nuse_highly_variable\n    Whether to use highly variable genes only, stored in\n    `.var['highly_variable']`.\n    By default uses them if they have been determined beforehand.\ndtype\n    Numpy data type string to which to convert the result.\ncopy\n    If an :class:`~anndata.AnnData` is passed, determines whether a copy\n    is returned. Is ignored otherwise.\nchunked\n    If `True`, perform an incremental PCA on segments of `chunk_size`.\n    The incremental PCA automatically zero centers and ignores settings of\n    `random_seed` and `svd_solver`. If `False`, perform a full PCA.\nchunk_size\n    Number of observations to include in each chunk.\n    Required if `chunked=True` was passed.\n\nReturns\n-------\nX_pca : :class:`~scipy.sparse.spmatrix`, :class:`~numpy.ndarray`\n    If `data` is array-like and `return_info=False` was passed,\n    this function only returns `X_pca`\u2026\nadata : anndata.AnnData\n    \u2026otherwise if `copy=True` it returns or else adds fields to `adata`:\n\n    `.obsm['X_pca']`\n         PCA representation of data.\n    `.varm['PCs']`\n         The principal components containing the loadings.\n    `.uns['pca']['variance_ratio']`\n         Ratio of explained variance.\n    `.uns['pca']['variance']`\n         Explained variance, equivalent to the eigenvalues of the\n         covariance matrix.",
        "description": "Principal component analysis [Pedregosa11]_.Computes PCA coordinates, loadings and variance decomposition.\nUses the implementation of *scikit-learn* [Pedregosa11]_.\n\n.. versionchanged:: 1.5.0\n\n    In previous versions, computing a PCA on a sparse matrix would make a dense copy of\n    the array for mean centering.\n    As of scanpy 1.5.0, mean centering is implicit.\n    While results are extremely similar, they are not exactly the same.\n    If you would like to reproduce the old results, pass a dense array.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.pca(data=$, n_comps=@, zero_center=@, svd_solver=@, random_state=@, return_info=@, use_highly_variable=@, dtype=@, copy=@, chunked=@, chunk_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy._settings.ScanpyConfig": {
        "Parameters": {
            "verbosity": {
                "type": "str",
                "default": "warning",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "plot_suffix": {
                "type": "str",
                "default": "",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "file_format_data": {
                "type": "str",
                "default": "h5ad",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "file_format_figs": {
                "type": "str",
                "default": "pdf",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "autosave": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "autoshow": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "writedir": {
                "type": "Union[str, Path]",
                "default": "./write/",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "cachedir": {
                "type": "Union[str, Path]",
                "default": "./cache/",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "datasetdir": {
                "type": "Union[str, Path]",
                "default": "./data/",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "figdir": {
                "type": "Union[str, Path]",
                "default": "./figures/",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "cache_compression": {
                "type": "Optional[str]",
                "default": "lzf",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "max_memory": {
                "type": null,
                "default": "15",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "n_jobs": {
                "type": null,
                "default": "1",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "logfile": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "categories_to_ignore": {
                "type": "Iterable[str]",
                "default": "('N/A', 'dontknow', 'no_gate', '?')",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "_frameon": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "_vector_friendly": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "_low_resolution_warning": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "n_pcs": {
                "type": null,
                "default": "50",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Config manager for scanpy.",
        "description": "Config manager for scanpy.",
        "example": "",
        "api_type": "class",
        "api_calling": [
            "scanpy._settings.ScanpyConfig(verbosity=@, plot_suffix=@, file_format_data=@, file_format_figs=@, autosave=@, autoshow=@, writedir=@, cachedir=@, datasetdir=@, figdir=@, cache_compression=@, max_memory=$, n_jobs=$, logfile=@, categories_to_ignore=@, _frameon=@, _vector_friendly=@, _low_resolution_warning=@, n_pcs=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy._settings.ScanpyConfig.set_figure_params": {
        "Parameters": {
            "scanpy": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Init default values for :obj:`matplotlib.rcParams` suited for Scanpy.",
                "optional_value": false
            },
            "dpi": {
                "type": "int",
                "default": "80",
                "optional": true,
                "description": "Resolution of rendered figures \u2013 this influences the size of figures in notebooks.",
                "optional_value": false
            },
            "dpi_save": {
                "type": "int",
                "default": "150",
                "optional": true,
                "description": "Resolution of saved figures. This should typically be higher to achieve\npublication quality.",
                "optional_value": false
            },
            "frameon": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Add frames and axes labels to scatter plots.",
                "optional_value": false
            },
            "vector_friendly": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Plot scatter plots using `png` backend even when exporting as `pdf` or `svg`.",
                "optional_value": false
            },
            "fontsize": {
                "type": "int",
                "default": "14",
                "optional": true,
                "description": "Set the fontsize for several `rcParams` entries. Ignored if `scanpy=False`.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Set plt.rcParams['figure.figsize'].",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Convenience method for setting the default color map. Ignored if `scanpy=False`.",
                "optional_value": false
            },
            "format": {
                "type": "Literal[png, jpg, tif, tiff, pdf, ps, eps, svg, svgz, pgf, raw, rgba]",
                "default": "pdf",
                "optional": true,
                "description": "This sets the default format for saving figures: `file_format_figs`.",
                "optional_value": true
            },
            "facecolor": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Sets backgrounds via `rcParams['figure.facecolor'] = facecolor` and\n`rcParams['axes.facecolor'] = facecolor`.",
                "optional_value": false
            },
            "transparent": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Save figures with transparent back ground. Sets\n`rcParams['savefig.transparent']`.",
                "optional_value": false
            },
            "ipython_format": {
                "type": "str",
                "default": "png2x",
                "optional": true,
                "description": "Only concerns the notebook/IPython environment; see\n:func:`~IPython.display.set_matplotlib_formats` for details.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Set resolution/size, styling and format of figures.\n\nParameters\n----------\nscanpy\n    Init default values for :obj:`matplotlib.rcParams` suited for Scanpy.\ndpi\n    Resolution of rendered figures \u2013 this influences the size of figures in notebooks.\ndpi_save\n    Resolution of saved figures. This should typically be higher to achieve\n    publication quality.\nframeon\n    Add frames and axes labels to scatter plots.\nvector_friendly\n    Plot scatter plots using `png` backend even when exporting as `pdf` or `svg`.\nfontsize\n    Set the fontsize for several `rcParams` entries. Ignored if `scanpy=False`.\nfigsize\n    Set plt.rcParams['figure.figsize'].\ncolor_map\n    Convenience method for setting the default color map. Ignored if `scanpy=False`.\nformat\n    This sets the default format for saving figures: `file_format_figs`.\nfacecolor\n    Sets backgrounds via `rcParams['figure.facecolor'] = facecolor` and\n    `rcParams['axes.facecolor'] = facecolor`.\ntransparent\n    Save figures with transparent back ground. Sets\n    `rcParams['savefig.transparent']`.\nipython_format\n    Only concerns the notebook/IPython environment; see\n    :func:`~IPython.display.set_matplotlib_formats` for details.",
        "description": "Set resolution/size, styling and format of figures.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy._settings.ScanpyConfig.set_figure_params(scanpy=@, dpi=@, dpi_save=@, frameon=@, vector_friendly=@, fontsize=@, figsize=@, color_map=@, format=$, facecolor=@, transparent=@, ipython_format=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.rank_genes_groups_violin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of group names.",
                "optional_value": false
            },
            "n_genes": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of genes to show. Is ignored if `gene_names` is passed.",
                "optional_value": false
            },
            "gene_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "List of genes to plot. Is only useful if interested in a custom gene list,\nwhich is not the result of :func:`scanpy.tl.rank_genes_groups`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores gene symbols if you do not want to\nuse `.var_names` displayed in the plot.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present. Defaults to the value that\nwas used in :func:`~scanpy.tl.rank_genes_groups`.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "split": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to split the violins or not.",
                "optional_value": false
            },
            "scale": {
                "type": "str",
                "default": "width",
                "optional": true,
                "description": "See :func:`~seaborn.violinplot`.",
                "optional_value": false
            },
            "strip": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show a strip plot on top of the violin plot.",
                "optional_value": false
            },
            "jitter": {
                "type": "Union[int, float, bool]",
                "default": "True",
                "optional": true,
                "description": "If set to 0, no points are drawn. See :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "size": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Size of the jitter points.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes for all tested comparisons.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ngroups\n    List of group names.\nn_genes\n    Number of genes to show. Is ignored if `gene_names` is passed.\ngene_names\n    List of genes to plot. Is only useful if interested in a custom gene list,\n    which is not the result of :func:`scanpy.tl.rank_genes_groups`.\ngene_symbols\n    Key for field in `.var` that stores gene symbols if you do not want to\n    use `.var_names` displayed in the plot.\nuse_raw\n    Use `raw` attribute of `adata` if present. Defaults to the value that\n    was used in :func:`~scanpy.tl.rank_genes_groups`.\nsplit\n    Whether to split the violins or not.\nscale\n    See :func:`~seaborn.violinplot`.\nstrip\n    Show a strip plot on top of the violin plot.\njitter\n    If set to 0, no points are drawn. See :func:`~seaborn.stripplot`.\nsize\n    Size of the jitter points.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.",
        "description": "Plot ranking of genes for all tested comparisons.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.rank_genes_groups_violin(adata=$, groups=@, n_genes=@, gene_names=@, gene_symbols=@, use_raw=@, key=@, split=@, scale=@, strip=@, jitter=@, size=@, ax=$, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pl.phate": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show edges.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Width of edges.",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Union[str, tuple[float, Ellipsis]]",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[List[Axes]]",
            "description": "If `show==False`, a list of :class:`~matplotlib.axes.Axes` objects.\nEvery second element corresponds to the 'right margin'\ndrawing area for color bars and legends."
        },
        "Docstring": "Scatter plot in PHATE basis.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nedges\n    Show edges.\nedges_width\n    Width of edges.\nedges_color\n    Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\nneighbors_key\n    Where to look for neighbors connectivities.\n    If not specified, this looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, this looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\narrows\n    Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\narrows_kwds\n    Passed to :meth:`~matplotlib.axes.Axes.quiver`\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False`, a list of :class:`~matplotlib.axes.Axes` objects.\nEvery second element corresponds to the 'right margin'\ndrawing area for color bars and legends.\n\nExamples\n--------\n>>> from anndata import AnnData\n>>> import scanpy.external as sce\n>>> import phate\n>>> data, branches = phate.tree.gen_dla(\n...     n_dim=100,\n...     n_branch=20,\n...     branch_length=100,\n... )\n>>> data.shape\n(2000, 100)\n>>> adata = AnnData(data)\n>>> adata.obs['branches'] = branches\n>>> sce.tl.phate(adata, k=5, a=20, t=150)\n>>> adata.obsm['X_phate'].shape\n(2000, 2)\n>>> sce.pl.phate(\n...     adata,\n...     color='branches',\n...     color_map='tab20',\n... )",
        "description": "Scatter plot in PHATE basis.",
        "example": "Examples\n--------\n>>> from anndata import AnnData\n>>> import scanpy.external as sce\n>>> import phate\n>>> data, branches = phate.tree.gen_dla(\n...     n_dim=100,\n...     n_branch=20,\n...     branch_length=100,\n... )\n>>> data.shape\n(2000, 100)\n>>> adata = AnnData(data)\n>>> adata.obs['branches'] = branches\n>>> sce.tl.phate(adata, k=5, a=20, t=150)\n>>> adata.obsm['X_phate'].shape\n(2000, 2)\n>>> sce.pl.phate(\n...     adata,\n...     color='branches',\n...     color_map='tab20',\n... )",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pl.phate(adata=$, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.dotplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[str, Sequence[str], Mapping[str, Union[str, Sequence[str]]]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation\nshould be subdivided.",
                "optional_value": false
            },
            "expression_cutoff": {
                "type": "float",
                "default": "0.0",
                "optional": true,
                "description": "Expression cutoff that is used for binarizing the gene expression and\ndetermining the fraction of cells expressing given genes. A gene is\nexpressed only if the expression value is greater than this threshold.",
                "optional_value": false
            },
            "mean_only_expressed": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, gene expression is averaged only over the cells\nexpressing the given genes.",
                "optional_value": false
            },
            "cmap": {
                "type": "str",
                "default": "Reds",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "dot_max": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If none, the maximum dot size is set to the maximum fraction value found\n(e.g. 0.6). If given, the value should be a number between 0 and 1.\nAll fractions larger than dot_max are clipped to this value.",
                "optional_value": false
            },
            "dot_min": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If none, the minimum dot size is set to 0. If given,\nthe value should be a number between 0 and 1.\nAll fractions smaller than dot_min are clipped to this value.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Optional[Literal[var, group]]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "smallest_dot": {
                "type": "Optional[float]",
                "default": "0.0",
                "optional": true,
                "description": "If none, the smallest dot has size 0.\nAll expression levels with `dot_min` are plotted with this size.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure",
                "optional_value": false
            },
            "colorbar_title": {
                "type": "Optional[str]",
                "default": "Mean expression\nin group",
                "optional": true,
                "description": "Title for the color bar. New line character (\\n) can be used.",
                "optional_value": false
            },
            "size_title": {
                "type": "Optional[str]",
                "default": "Fraction of cells\nin group (%)",
                "optional": true,
                "description": "Title for the size legend. New line character (\\n) can be used.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`.\nOtherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called\nwith default parameters.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees.\nBy default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "swap_axes": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "By default, the x axis contains `var_names` (e.g. genes) and the y axis\nthe `groupby` categories. By setting `swap_axes` then x are the\n`groupby` categories and y the `var_names`.",
                "optional_value": false
            },
            "dot_color_df": {
                "type": "Optional[DataFrame]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`DotPlot` object. Useful for fine-tuning\nthe plot. Takes precedence over `show=False`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. Values larger than vmax are plotted\nwith the same color as vmax.",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "Custom color normalization object from matplotlib. See\n`https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[DotPlot, dict]]",
            "description": "If `return_fig` is `True`, returns a :class:`~scanpy.pl.DotPlot` object,\nelse if `show` is false, return axes dict\nSee also\n:class:`~scanpy.pl.DotPlot`: The DotPlot class can be used to to control\nseveral visual parameters not available in this function.\n:func:`~scanpy.pl.rank_genes_groups_dotplot`: to plot marker genes\nidentified using the :func:`~scanpy.tl.rank_genes_groups` function."
        },
        "Docstring": "Makes a *dot plot* of the expression values of `var_names`.\n\nFor each var_name and each `groupby` category a dot is plotted.\nEach dot represents two values: mean expression within each category\n(visualized by color) and fraction of cells expressing the `var_name` in the\ncategory (visualized by the size of the dot). If `groupby` is not given,\nthe dotplot assumes that all data belongs to a single category.\n\n.. note::\n   A gene is considered expressed if the expression value in the `adata` (or\n   `adata.raw`) is above the specified threshold which is zero by default.\n\nAn example of dotplot usage is to visualize, for multiple marker genes,\nthe mean value and the percentage of cells expressing the gene\nacross  multiple clusters.\n\nThis function provides a convenient interface to the :class:`~scanpy.pl.DotPlot`\nclass. If you need more flexibility, you should use :class:`~scanpy.pl.DotPlot`\ndirectly.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nvar_names\n    `var_names` should be a valid subset of `adata.var_names`.\n    If `var_names` is a mapping, then the key is used as label\n    to group the values (see `var_group_labels`). The mapping values\n    should be sequences of valid `adata.var_names`. In this\n    case either coloring or 'brackets' are used for the grouping\n    of var names depending on the plot. When `var_names` is a mapping,\n    then the `var_group_labels` and `var_group_positions` are set.\ngroupby\n    The key of the observation grouping to consider.\nuse_raw\n    Use `raw` attribute of `adata` if present.\nlog\n    Plot on logarithmic axis.\nnum_categories\n    Only used if groupby observation is not categorical. This value\n    determines the number of groups into which the groupby observation\n    should be subdivided.\ncategories_order\n    Order in which to show the categories. Note: add_dendrogram or add_totals\n    can change the categories order.\nfigsize\n    Figure size when `multi_panel=True`.\n    Otherwise the `rcParam['figure.figsize]` value is used.\n    Format is (width, height)\ndendrogram\n    If True or a valid dendrogram key, a dendrogram based on the hierarchical\n    clustering between the `groupby` categories is added.\n    The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n    If `tl.dendrogram` has not been called previously the function is called\n    with default parameters.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols.\n    By default `var_names` refer to the index column of the `.var` DataFrame.\n    Setting this option allows alternative names to be used.\nvar_group_positions\n    Use this parameter to highlight groups of `var_names`.\n    This will draw a 'bracket' or a color block between the given start and end\n    positions. If the parameter `var_group_labels` is set, the corresponding\n    labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n    will add a bracket between the fourth `var_name` and the tenth `var_name`.\n    By giving more positions, more brackets/color blocks are drawn.\nvar_group_labels\n    Labels for each of the `var_group_positions` that want to be highlighted.\nvar_group_rotation\n    Label rotation degrees.\n    By default, labels larger than 4 characters are rotated 90 degrees.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n    If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n    then the layer is plotted. `layer` takes precedence over `use_raw`.\ntitle\n    Title for the figure\ncolorbar_title\n    Title for the color bar. New line character (\\n) can be used.\ncmap\n    String denoting matplotlib color map.\nstandard_scale\n    Whether or not to standardize the given dimension between 0 and 1, meaning for\n    each variable or group, subtract the minimum and divide each by its maximum.\nswap_axes\n     By default, the x axis contains `var_names` (e.g. genes) and the y axis\n     the `groupby` categories. By setting `swap_axes` then x are the\n     `groupby` categories and y the `var_names`.\nreturn_fig\n    Returns :class:`DotPlot` object. Useful for fine-tuning\n    the plot. Takes precedence over `show=False`.\n\nsize_title\n    Title for the size legend. New line character (\\n) can be used.\nexpression_cutoff\n    Expression cutoff that is used for binarizing the gene expression and\n    determining the fraction of cells expressing given genes. A gene is\n    expressed only if the expression value is greater than this threshold.\nmean_only_expressed\n    If True, gene expression is averaged only over the cells\n    expressing the given genes.\ndot_max\n    If none, the maximum dot size is set to the maximum fraction value found\n    (e.g. 0.6). If given, the value should be a number between 0 and 1.\n    All fractions larger than dot_max are clipped to this value.\ndot_min\n    If none, the minimum dot size is set to 0. If given,\n    the value should be a number between 0 and 1.\n    All fractions smaller than dot_min are clipped to this value.\nsmallest_dot\n    If none, the smallest dot has size 0.\n    All expression levels with `dot_min` are plotted with this size.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin.\nvmax\n    The value representing the upper limit of the color scale. Values larger than vmax are plotted\n    with the same color as vmax.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\nnorm\n    Custom color normalization object from matplotlib. See\n    `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.\nkwds\n    Are passed to :func:`matplotlib.pyplot.scatter`.\n\nReturns\n-------\nIf `return_fig` is `True`, returns a :class:`~scanpy.pl.DotPlot` object,\nelse if `show` is false, return axes dict\n\nSee also\n--------\n:class:`~scanpy.pl.DotPlot`: The DotPlot class can be used to to control\n    several visual parameters not available in this function.\n:func:`~scanpy.pl.rank_genes_groups_dotplot`: to plot marker genes\n    identified using the :func:`~scanpy.tl.rank_genes_groups` function.\n\nExamples\n--------\n\nCreate a dot plot using the given markers and the PBMC example dataset grouped by\nthe category 'bulk_labels'.\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.dotplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nUsing var_names as dict:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.dotplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nGet DotPlot object for fine tuning\n\n.. plot::\n    :context: close-figs\n\n    dp = sc.pl.dotplot(adata, markers, 'bulk_labels', return_fig=True)\n    dp.add_totals().style(dot_edge_color='black', dot_edge_lw=0.5).show()\n\nThe axes used can be obtained using the get_axes() method\n\n.. code-block:: python\n\n    axes_dict = dp.get_axes()\n    print(axes_dict)",
        "description": "Makes a *dot plot* of the expression values of `var_names`.For each var_name and each `groupby` category a dot is plotted.\nEach dot represents two values: mean expression within each category\n(visualized by color) and fraction of cells expressing the `var_name` in the\ncategory (visualized by the size of the dot). If `groupby` is not given,\nthe dotplot assumes that all data belongs to a single category.\n\n.. note::\n   A gene is considered expressed if the expression value in the `adata` (or\n   `adata.raw`) is above the specified threshold which is zero by default.\n\nAn example of dotplot usage is to visualize, for multiple marker genes,\nthe mean value and the percentage of cells expressing the gene\nacross  multiple clusters.\n\nThis function provides a convenient interface to the :class:`~scanpy.pl.DotPlot`\nclass. If you need more flexibility, you should use :class:`~scanpy.pl.DotPlot`\ndirectly.",
        "example": "Examples\n--------\n\nCreate a dot plot using the given markers and the PBMC example dataset grouped by\nthe category 'bulk_labels'.\n\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    markers = ['C1QA', 'PSAP', 'CD79A', 'CD79B', 'CST3', 'LYZ']\n    sc.pl.dotplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nUsing var_names as dict:\n\n.. plot::\n    :context: close-figs\n\n    markers = {'T-cell': 'CD3D', 'B-cell': 'CD79A', 'myeloid': 'CST3'}\n    sc.pl.dotplot(adata, markers, groupby='bulk_labels', dendrogram=True)\n\nGet DotPlot object for fine tuning\n\n.. plot::\n    :context: close-figs\n\n    dp = sc.pl.dotplot(adata, markers, 'bulk_labels', return_fig=True)\n    dp.add_totals().style(dot_edge_color='black', dot_edge_lw=0.5).show()\n\nThe axes used can be obtained using the get_axes() method\n\n.. code-block:: python\n\n    axes_dict = dp.get_axes()\n    print(axes_dict)",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.dotplot(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, expression_cutoff=@, mean_only_expressed=@, cmap=@, dot_max=@, dot_min=@, standard_scale=$, smallest_dot=@, title=@, colorbar_title=@, size_title=@, figsize=@, dendrogram=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, swap_axes=@, dot_color_df=$, show=@, save=@, ax=$, return_fig=@, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.phenograph": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, ndarray, spmatrix]",
                "default": null,
                "optional": false,
                "description": "AnnData, or Array of data to cluster, or sparse matrix of k-nearest neighbor\ngraph. If ndarray, n-by-d array of n cells in d dimensions. if sparse matrix,\nn-by-n adjacency matrix.",
                "optional_value": true
            },
            "clustering_algo": {
                "type": "Optional[Literal[louvain, leiden]]",
                "default": "louvain",
                "optional": true,
                "description": "Choose between `'Louvain'` or `'Leiden'` algorithm for clustering.",
                "optional_value": true
            },
            "k": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of nearest neighbors to use in first step of graph construction.",
                "optional_value": false
            },
            "directed": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use a symmetric (default) or asymmetric (`'directed'`) graph.\nThe graph construction process produces a directed graph, which is symmetrized\nby one of two methods (see `prune` below).",
                "optional_value": false
            },
            "prune": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "`prune=False`, symmetrize by taking the average between the graph and its\ntranspose. `prune=True`, symmetrize by taking the product between the graph\nand its transpose.",
                "optional_value": false
            },
            "min_cluster_size": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "Cells that end up in a cluster smaller than min_cluster_size are considered\noutliers and are assigned to -1 in the cluster labels.",
                "optional_value": false
            },
            "jaccard": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, use Jaccard metric between k-neighborhoods to build graph. If\n`False`, use a Gaussian kernel.",
                "optional_value": false
            },
            "primary_metric": {
                "type": "Literal[euclidean, manhattan, correlation, cosine]",
                "default": "euclidean",
                "optional": true,
                "description": "Distance metric to define nearest neighbors. Note that performance will be\nslower for correlation and cosine.",
                "optional_value": true
            },
            "n_jobs": {
                "type": "int",
                "default": "-1",
                "optional": true,
                "description": "Nearest Neighbors and Jaccard coefficients will be computed in parallel using\nn_jobs. If 1 is given, no parallelism is used. If set to -1, all CPUs are used.\nFor n_jobs below -1, `n_cpus + 1 + n_jobs` are used.",
                "optional_value": false
            },
            "q_tol": {
                "type": "float",
                "default": "0.001",
                "optional": true,
                "description": "Tolerance, i.e. precision, for monitoring modularity optimization.",
                "optional_value": false
            },
            "louvain_time_limit": {
                "type": "int",
                "default": "2000",
                "optional": true,
                "description": "Maximum number of seconds to run modularity optimization. If exceeded the best\nresult so far is returned.",
                "optional_value": false
            },
            "nn_method": {
                "type": "Literal[kdtree, brute]",
                "default": "kdtree",
                "optional": true,
                "description": "Whether to use brute force or kdtree for nearest neighbor search.\nFor very large high-dimensional data sets, brute force, with parallel\ncomputation, performs faster than kdtree.",
                "optional_value": true
            },
            "partition_type": {
                "type": "Optional[type[MutableVertexPartition]]",
                "default": "None",
                "optional": true,
                "description": "Defaults to :class:`~leidenalg.RBConfigurationVertexPartition`. For the\navailable options, consult the documentation for\n:func:`~leidenalg.find_partition`.",
                "optional_value": true
            },
            "resolution_parameter": {
                "type": "float",
                "default": "1",
                "optional": true,
                "description": "A parameter value controlling the coarseness of the clustering in Leiden. Higher\nvalues lead to more clusters. Set to `None` if overriding `partition_type` to\none that does not accept a `resolution_parameter`.",
                "optional_value": false
            },
            "n_iterations": {
                "type": "int",
                "default": "-1",
                "optional": true,
                "description": "Number of iterations to run the Leiden algorithm. If the number of iterations is\nnegative, the Leiden algorithm is run until an iteration in which there was no\nimprovement.",
                "optional_value": false
            },
            "use_weights": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Use vertices in the Leiden computation.",
                "optional_value": false
            },
            "seed": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Leiden initialization of the optimization.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy or write to `adata`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "tuple[Optional[ndarray], spmatrix, Optional[float]]",
            "description": "Depending on `copy`, returns or updates `adata` with the following fields:\n**communities** - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.obs`, dtype `int`)\ninteger array of community assignments for each row in data.\n**graph** - :class:`~scipy.sparse.spmatrix` (:attr:`~anndata.AnnData.obsp`, dtype `float`)\nthe graph that was used for clustering.\n**Q** - `float` (:attr:`~anndata.AnnData.uns`, dtype `float`)\nthe modularity score for communities on graph."
        },
        "Docstring": "PhenoGraph clustering [Levine15]_.\n\n**PhenoGraph** is a clustering method designed for high-dimensional single-cell\ndata. It works by creating a graph (\"network\") representing phenotypic similarities\nbetween cells and then identifying communities in this graph. It supports both\nLouvain_ and Leiden_ algorithms for community detection.\n\n.. _Louvain: https://louvain-igraph.readthedocs.io/en/latest/\n\n.. _Leiden: https://leidenalg.readthedocs.io/en/latest/reference.html\n\n.. note::\n   More information and bug reports `here\n   <https://github.com/dpeerlab/PhenoGraph>`__.\n\nParameters\n----------\nadata\n    AnnData, or Array of data to cluster, or sparse matrix of k-nearest neighbor\n    graph. If ndarray, n-by-d array of n cells in d dimensions. if sparse matrix,\n    n-by-n adjacency matrix.\nclustering_algo\n    Choose between `'Louvain'` or `'Leiden'` algorithm for clustering.\nk\n    Number of nearest neighbors to use in first step of graph construction.\ndirected\n    Whether to use a symmetric (default) or asymmetric (`'directed'`) graph.\n    The graph construction process produces a directed graph, which is symmetrized\n    by one of two methods (see `prune` below).\nprune\n    `prune=False`, symmetrize by taking the average between the graph and its\n    transpose. `prune=True`, symmetrize by taking the product between the graph\n    and its transpose.\nmin_cluster_size\n    Cells that end up in a cluster smaller than min_cluster_size are considered\n    outliers and are assigned to -1 in the cluster labels.\njaccard\n    If `True`, use Jaccard metric between k-neighborhoods to build graph. If\n    `False`, use a Gaussian kernel.\nprimary_metric\n    Distance metric to define nearest neighbors. Note that performance will be\n    slower for correlation and cosine.\nn_jobs\n    Nearest Neighbors and Jaccard coefficients will be computed in parallel using\n    n_jobs. If 1 is given, no parallelism is used. If set to -1, all CPUs are used.\n    For n_jobs below -1, `n_cpus + 1 + n_jobs` are used.\nq_tol\n    Tolerance, i.e. precision, for monitoring modularity optimization.\nlouvain_time_limit\n    Maximum number of seconds to run modularity optimization. If exceeded the best\n    result so far is returned.\nnn_method\n    Whether to use brute force or kdtree for nearest neighbor search.\n    For very large high-dimensional data sets, brute force, with parallel\n    computation, performs faster than kdtree.\npartition_type\n    Defaults to :class:`~leidenalg.RBConfigurationVertexPartition`. For the\n    available options, consult the documentation for\n    :func:`~leidenalg.find_partition`.\nresolution_parameter\n    A parameter value controlling the coarseness of the clustering in Leiden. Higher\n    values lead to more clusters. Set to `None` if overriding `partition_type` to\n    one that does not accept a `resolution_parameter`.\nn_iterations\n    Number of iterations to run the Leiden algorithm. If the number of iterations is\n    negative, the Leiden algorithm is run until an iteration in which there was no\n    improvement.\nuse_weights\n    Use vertices in the Leiden computation.\nseed\n    Leiden initialization of the optimization.\ncopy\n    Return a copy or write to `adata`.\nkargs\n    Additional arguments passed to :func:`~leidenalg.find_partition` and the\n    constructor of the `partition_type`.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following fields:\n\n**communities** - :class:`~numpy.ndarray` (:attr:`~anndata.AnnData.obs`, dtype `int`)\n    integer array of community assignments for each row in data.\n\n**graph** - :class:`~scipy.sparse.spmatrix` (:attr:`~anndata.AnnData.obsp`, dtype `float`)\n    the graph that was used for clustering.\n\n**Q** - `float` (:attr:`~anndata.AnnData.uns`, dtype `float`)\n    the modularity score for communities on graph.\n\nExample\n-------\n>>> from anndata import AnnData\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> import numpy as np\n>>> import pandas as pd\n\nWith annotated data as input:\n\n>>> adata = sc.datasets.pbmc3k()\n>>> sc.pp.normalize_per_cell(adata)\n\nThen do PCA:\n\n>>> sc.tl.pca(adata, n_comps=100)\n\nCompute phenograph clusters:\n\n**Louvain** community detection\n\n>>> sce.tl.phenograph(adata, clustering_algo=\"louvain\", k=30)\n\n**Leiden** community detection\n\n>>> sce.tl.phenograph(adata, clustering_algo=\"leiden\", k=30)\n\nReturn only `Graph` object\n\n>>> sce.tl.phenograph(adata, clustering_algo=None, k=30)\n\nNow to show phenograph on tSNE (for example):\n\nCompute tSNE:\n\n>>> sc.tl.tsne(adata, random_state=7)\n\nPlot phenograph clusters on tSNE:\n\n>>> sc.pl.tsne(\n...     adata, color = [\"pheno_louvain\", \"pheno_leiden\"], s = 100,\n...     palette = sc.pl.palettes.vega_20_scanpy, legend_fontsize = 10\n... )\n\nCluster and cluster centroids for input Numpy ndarray\n\n>>> df = np.random.rand(1000, 40)\n>>> dframe = pd.DataFrame(df)\n>>> dframe.index, dframe.columns = (map(str, dframe.index), map(str, dframe.columns))\n>>> adata = AnnData(dframe)\n>>> sc.tl.pca(adata, n_comps=20)\n>>> sce.tl.phenograph(adata, clustering_algo=\"leiden\", k=50)\n>>> sc.tl.tsne(adata, random_state=1)\n>>> sc.pl.tsne(\n...     adata, color=['pheno_leiden'], s=100,\n...     palette=sc.pl.palettes.vega_20_scanpy, legend_fontsize=10\n... )",
        "description": "PhenoGraph clustering [Levine15]_.**PhenoGraph** is a clustering method designed for high-dimensional single-cell\ndata. It works by creating a graph (\"network\") representing phenotypic similarities\nbetween cells and then identifying communities in this graph. It supports both\nLouvain_ and Leiden_ algorithms for community detection.\n\n.. _Louvain: https://louvain-igraph.readthedocs.io/en/latest/\n\n.. _Leiden: https://leidenalg.readthedocs.io/en/latest/reference.html\n\n.. note::\n   More information and bug reports `here\n   <https://github.com/dpeerlab/PhenoGraph>`__.",
        "example": "Example\n-------\n>>> from anndata import AnnData\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> import numpy as np\n>>> import pandas as pd\n\nWith annotated data as input:\n\n>>> adata = sc.datasets.pbmc3k()\n>>> sc.pp.normalize_per_cell(adata)\n\nThen do PCA:\n\n>>> sc.tl.pca(adata, n_comps=100)\n\nCompute phenograph clusters:\n\n**Louvain** community detection\n\n>>> sce.tl.phenograph(adata, clustering_algo=\"louvain\", k=30)\n\n**Leiden** community detection\n\n>>> sce.tl.phenograph(adata, clustering_algo=\"leiden\", k=30)\n\nReturn only `Graph` object\n\n>>> sce.tl.phenograph(adata, clustering_algo=None, k=30)\n\nNow to show phenograph on tSNE (for example):\n\nCompute tSNE:\n\n>>> sc.tl.tsne(adata, random_state=7)\n\nPlot phenograph clusters on tSNE:\n\n>>> sc.pl.tsne(\n...     adata, color = [\"pheno_louvain\", \"pheno_leiden\"], s = 100,\n...     palette = sc.pl.palettes.vega_20_scanpy, legend_fontsize = 10\n... )\n\nCluster and cluster centroids for input Numpy ndarray\n\n>>> df = np.random.rand(1000, 40)\n>>> dframe = pd.DataFrame(df)\n>>> dframe.index, dframe.columns = (map(str, dframe.index), map(str, dframe.columns))\n>>> adata = AnnData(dframe)\n>>> sc.tl.pca(adata, n_comps=20)\n>>> sce.tl.phenograph(adata, clustering_algo=\"leiden\", k=50)\n>>> sc.tl.tsne(adata, random_state=1)\n>>> sc.pl.tsne(\n...     adata, color=['pheno_leiden'], s=100,\n...     palette=sc.pl.palettes.vega_20_scanpy, legend_fontsize=10\n... )",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.phenograph(adata=$, clustering_algo=$, k=@, directed=@, prune=@, min_cluster_size=@, jaccard=@, primary_metric=$, n_jobs=@, q_tol=@, louvain_time_limit=@, nn_method=$, partition_type=$, resolution_parameter=@, n_iterations=@, use_weights=@, seed=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.leiden": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "resolution": {
                "type": "float",
                "default": "1",
                "optional": true,
                "description": "A parameter value controlling the coarseness of the clustering.\nHigher values lead to more clusters.\nSet to `None` if overriding `partition_type`\nto one that doesn\u2019t accept a `resolution_parameter`.",
                "optional_value": false
            },
            "restrict_to": {
                "type": "Optional[tuple[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Restrict the clustering to the categories within the key for sample\nannotation, tuple needs to contain `(obs_key, list_of_categories)`.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Change the initialization of the optimization.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "leiden",
                "optional": true,
                "description": "`adata.obs` key under which to add the cluster labels.",
                "optional_value": false
            },
            "adjacency": {
                "type": "Optional[spmatrix]",
                "default": "None",
                "optional": true,
                "description": "Sparse adjacency matrix of the graph, defaults to neighbors connectivities.",
                "optional_value": true
            },
            "directed": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to treat the graph as directed or undirected.",
                "optional_value": false
            },
            "use_weights": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, edge weights from the graph are used in the computation\n(placing more emphasis on stronger edges).",
                "optional_value": false
            },
            "n_iterations": {
                "type": "int",
                "default": "-1",
                "optional": true,
                "description": "How many iterations of the Leiden clustering algorithm to perform.\nPositive values above 2 define the total number of iterations to perform,\n-1 has the algorithm run until it reaches its optimal clustering.",
                "optional_value": false
            },
            "partition_type": {
                "type": "Optional[type[MutableVertexPartition]]",
                "default": "None",
                "optional": true,
                "description": "Type of partition to use.\nDefaults to :class:`~leidenalg.RBConfigurationVertexPartition`.\nFor the available options, consult the documentation for\n:func:`~leidenalg.find_partition`.",
                "optional_value": true
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use neighbors connectivities as adjacency.\nIf not specified, leiden looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, leiden looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "obsp": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use .obsp[obsp] as adjacency. You can't specify both\n`obsp` and `neighbors_key` at the same time.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to copy `adata` or modify it inplace.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "`adata.obs[key_added]`\nArray of dim (number of samples) that stores the subgroup id\n(`'0'`, `'1'`, ...) for each cell.\n`adata.uns['leiden']['params']`\nA dict with the values for the parameters `resolution`, `random_state`,\nand `n_iterations`."
        },
        "Docstring": "Cluster cells into subgroups [Traag18]_.\n\nCluster cells using the Leiden algorithm [Traag18]_,\nan improved version of the Louvain algorithm [Blondel08]_.\nIt has been proposed for single-cell analysis by [Levine15]_.\n\nThis requires having ran :func:`~scanpy.pp.neighbors` or\n:func:`~scanpy.external.pp.bbknn` first.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nresolution\n    A parameter value controlling the coarseness of the clustering.\n    Higher values lead to more clusters.\n    Set to `None` if overriding `partition_type`\n    to one that doesn\u2019t accept a `resolution_parameter`.\nrandom_state\n    Change the initialization of the optimization.\nrestrict_to\n    Restrict the clustering to the categories within the key for sample\n    annotation, tuple needs to contain `(obs_key, list_of_categories)`.\nkey_added\n    `adata.obs` key under which to add the cluster labels.\nadjacency\n    Sparse adjacency matrix of the graph, defaults to neighbors connectivities.\ndirected\n    Whether to treat the graph as directed or undirected.\nuse_weights\n    If `True`, edge weights from the graph are used in the computation\n    (placing more emphasis on stronger edges).\nn_iterations\n    How many iterations of the Leiden clustering algorithm to perform.\n    Positive values above 2 define the total number of iterations to perform,\n    -1 has the algorithm run until it reaches its optimal clustering.\npartition_type\n    Type of partition to use.\n    Defaults to :class:`~leidenalg.RBConfigurationVertexPartition`.\n    For the available options, consult the documentation for\n    :func:`~leidenalg.find_partition`.\nneighbors_key\n    Use neighbors connectivities as adjacency.\n    If not specified, leiden looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, leiden looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\nobsp\n    Use .obsp[obsp] as adjacency. You can't specify both\n    `obsp` and `neighbors_key` at the same time.\ncopy\n    Whether to copy `adata` or modify it inplace.\n**partition_kwargs\n    Any further arguments to pass to `~leidenalg.find_partition`\n    (which in turn passes arguments to the `partition_type`).\n\nReturns\n-------\n`adata.obs[key_added]`\n    Array of dim (number of samples) that stores the subgroup id\n    (`'0'`, `'1'`, ...) for each cell.\n`adata.uns['leiden']['params']`\n    A dict with the values for the parameters `resolution`, `random_state`,\n    and `n_iterations`.",
        "description": "Cluster cells into subgroups [Traag18]_.Cluster cells using the Leiden algorithm [Traag18]_,\nan improved version of the Louvain algorithm [Blondel08]_.\nIt has been proposed for single-cell analysis by [Levine15]_.\n\nThis requires having ran :func:`~scanpy.pp.neighbors` or\n:func:`~scanpy.external.pp.bbknn` first.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.leiden(adata=$, resolution=@, restrict_to=@, random_state=@, key_added=@, adjacency=$, directed=@, use_weights=@, n_iterations=@, partition_type=$, neighbors_key=@, obsp=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.pbmc68k_reduced": {
        "Parameters": {},
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "Subsampled and processed 68k PBMCs.\n\n10x PBMC 68k dataset from\nhttps://support.10xgenomics.com/single-cell-gene-expression/datasets\n\nThe original PBMC 68k dataset was preprocessed using scanpy and was saved\nkeeping only 724 cells and 221 highly variable genes.\n\nThe saved file contains the annotation of cell types (key: `'bulk_labels'`),\nUMAP coordinates, louvain clustering and gene rankings based on the\n`bulk_labels`.\n\nReturns\n-------\nAnnotated data matrix.",
        "description": "Subsampled and processed 68k PBMCs.10x PBMC 68k dataset from\nhttps://support.10xgenomics.com/single-cell-gene-expression/datasets\n\nThe original PBMC 68k dataset was preprocessed using scanpy and was saved\nkeeping only 724 cells and 221 highly variable genes.\n\nThe saved file contains the annotation of cell types (key: `'bulk_labels'`),\nUMAP coordinates, louvain clustering and gene rankings based on the\n`bulk_labels`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.pbmc68k_reduced()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_hdf": {
        "Parameters": {
            "filename": {
                "type": "PathLike",
                "default": null,
                "optional": false,
                "description": "Filename of data file.",
                "optional_value": true
            },
            "key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Name of dataset in the file.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Read `.h5` (hdf5) file.\n\nNote: Also looks for fields `row_names` and `col_names`.\n\nParameters\n----------\nfilename\n    Filename of data file.\nkey\n    Name of dataset in the file.",
        "description": "Read `.h5` (hdf5) file.Note: Also looks for fields `row_names` and `col_names`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_hdf(filename=$, key=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.highly_variable_genes": {
        "Parameters": {
            "adata_or_result": {
                "type": "Union[AnnData, DataFrame, recarray]",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axes.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {{`'.pdf'`, `'.png'`, `'.svg'`}}.",
                "optional_value": false
            },
            "highly_variable_genes": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot dispersions or normalized variance versus means for genes.\n\nProduces Supp. Fig. 5c of Zheng et al. (2017) and MeanVarPlot() and\nVariableFeaturePlot() of Seurat.\n\nParameters\n----------\nadata\n    Result of :func:`~scanpy.pp.highly_variable_genes`.\nlog\n    Plot on logarithmic axes.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {{`'.pdf'`, `'.png'`, `'.svg'`}}.",
        "description": "Plot dispersions or normalized variance versus means for genes.Produces Supp. Fig. 5c of Zheng et al. (2017) and MeanVarPlot() and\nVariableFeaturePlot() of Seurat.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.highly_variable_genes(adata_or_result=$, log=@, show=@, save=@, highly_variable_genes=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.visium_sge": {
        "Parameters": {
            "sample_id": {
                "type": "Literal[V1_Breast_Cancer_Block_A_Section_1, V1_Breast_Cancer_Block_A_Section_2, V1_Human_Heart, V1_Human_Lymph_Node, V1_Mouse_Kidney, V1_Adult_Mouse_Brain, V1_Mouse_Brain_Sagittal_Posterior, V1_Mouse_Brain_Sagittal_Posterior_Section_2, V1_Mouse_Brain_Sagittal_Anterior, V1_Mouse_Brain_Sagittal_Anterior_Section_2, V1_Human_Brain_Section_1, V1_Human_Brain_Section_2, V1_Adult_Mouse_Brain_Coronal_Section_1, V1_Adult_Mouse_Brain_Coronal_Section_2, Targeted_Visium_Human_Cerebellum_Neuroscience, Parent_Visium_Human_Cerebellum, Targeted_Visium_Human_SpinalCord_Neuroscience, Parent_Visium_Human_SpinalCord, Targeted_Visium_Human_Glioblastoma_Pan_Cancer, Parent_Visium_Human_Glioblastoma, Targeted_Visium_Human_BreastCancer_Immunology, Parent_Visium_Human_BreastCancer, Targeted_Visium_Human_OvarianCancer_Pan_Cancer, Targeted_Visium_Human_OvarianCancer_Immunology, Parent_Visium_Human_OvarianCancer, Targeted_Visium_Human_ColorectalCancer_GeneSignature, Parent_Visium_Human_ColorectalCancer]",
                "default": "V1_Breast_Cancer_Block_A_Section_1",
                "optional": true,
                "description": "The ID of the data sample in 10x\u2019s spatial database.",
                "optional_value": true
            },
            "include_hires_tiff": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Download and include the high-resolution tissue image (tiff) in `adata.uns[\"spatial\"][sample_id][\"metadata\"][\"source_image_path\"]`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "Processed Visium Spatial Gene Expression data from 10x Genomics.\nDatabase: https://support.10xgenomics.com/spatial-gene-expression/datasets\n\nParameters\n----------\nsample_id\n    The ID of the data sample in 10x\u2019s spatial database.\ninclude_hires_tiff\n    Download and include the high-resolution tissue image (tiff) in `adata.uns[\"spatial\"][sample_id][\"metadata\"][\"source_image_path\"]`.\n\nReturns\n-------\nAnnotated data matrix.",
        "description": "Processed Visium Spatial Gene Expression data from 10x Genomics.Database: https://support.10xgenomics.com/spatial-gene-expression/datasets",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.visium_sge(sample_id=$, include_hires_tiff=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.normalize_total": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "target_sum": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If `None`, after normalization, each observation (cell) has a total\ncount equal to the median of total counts for observations (cells)\nbefore normalization.",
                "optional_value": false
            },
            "exclude_highly_expressed": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Exclude (very) highly expressed genes for the computation of the\nnormalization factor (size factor) for each cell. A gene is considered\nhighly expressed, if it has more than `max_fraction` of the total counts\nin at least one cell. The not-excluded genes will sum up to\n`target_sum`.",
                "optional_value": false
            },
            "max_fraction": {
                "type": "float",
                "default": "0.05",
                "optional": true,
                "description": "If `exclude_highly_expressed=True`, consider cells as highly expressed\nthat have more counts than `max_fraction` of the original total counts\nin at least one cell.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the field in `adata.obs` where the normalization factor is\nstored.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Layer to normalize instead of `X`. If `None`, `X` is normalized.",
                "optional_value": false
            },
            "layers": {
                "type": "Union[Literal[all], Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "layer_norm": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to update `adata` or return dictionary with normalized copies of\n`adata.X` and `adata.layers`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to modify copied input object. Not compatible with inplace=False.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Dict[str, ndarray]]",
            "description": "Returns dictionary with normalized copies of `adata.X` and `adata.layers`\nor updates `adata` with normalized version of the original\n`adata.X` and `adata.layers`, depending on `inplace`."
        },
        "Docstring": "Normalize counts per cell.\n\nNormalize each cell by total counts over all genes,\nso that every cell has the same total count after normalization.\nIf choosing `target_sum=1e6`, this is CPM normalization.\n\nIf `exclude_highly_expressed=True`, very highly expressed genes are excluded\nfrom the computation of the normalization factor (size factor) for each\ncell. This is meaningful as these can strongly influence the resulting\nnormalized values for all other genes [Weinreb17]_.\n\nSimilar functions are used, for example, by Seurat [Satija15]_, Cell Ranger\n[Zheng17]_ or SPRING [Weinreb17]_.\n\nParams\n------\nadata\n    The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\ntarget_sum\n    If `None`, after normalization, each observation (cell) has a total\n    count equal to the median of total counts for observations (cells)\n    before normalization.\nexclude_highly_expressed\n    Exclude (very) highly expressed genes for the computation of the\n    normalization factor (size factor) for each cell. A gene is considered\n    highly expressed, if it has more than `max_fraction` of the total counts\n    in at least one cell. The not-excluded genes will sum up to\n    `target_sum`.\nmax_fraction\n    If `exclude_highly_expressed=True`, consider cells as highly expressed\n    that have more counts than `max_fraction` of the original total counts\n    in at least one cell.\nkey_added\n    Name of the field in `adata.obs` where the normalization factor is\n    stored.\nlayer\n    Layer to normalize instead of `X`. If `None`, `X` is normalized.\ninplace\n    Whether to update `adata` or return dictionary with normalized copies of\n    `adata.X` and `adata.layers`.\ncopy\n    Whether to modify copied input object. Not compatible with inplace=False.\n\nReturns\n-------\nReturns dictionary with normalized copies of `adata.X` and `adata.layers`\nor updates `adata` with normalized version of the original\n`adata.X` and `adata.layers`, depending on `inplace`.\n\nExample\n--------\n>>> from anndata import AnnData\n>>> import scanpy as sc\n>>> sc.settings.verbosity = 2\n>>> np.set_printoptions(precision=2)\n>>> adata = AnnData(np.array([\n...    [3, 3, 3, 6, 6],\n...    [1, 1, 1, 2, 2],\n...    [1, 22, 1, 2, 2],\n... ]))\n>>> adata.X\narray([[ 3.,  3.,  3.,  6.,  6.],\n       [ 1.,  1.,  1.,  2.,  2.],\n       [ 1., 22.,  1.,  2.,  2.]], dtype=float32)\n>>> X_norm = sc.pp.normalize_total(adata, target_sum=1, inplace=False)['X']\n>>> X_norm\narray([[0.14, 0.14, 0.14, 0.29, 0.29],\n       [0.14, 0.14, 0.14, 0.29, 0.29],\n       [0.04, 0.79, 0.04, 0.07, 0.07]], dtype=float32)\n>>> X_norm = sc.pp.normalize_total(\n...     adata, target_sum=1, exclude_highly_expressed=True,\n...     max_fraction=0.2, inplace=False\n... )['X']\nThe following highly-expressed genes are not considered during normalization factor computation:\n['1', '3', '4']\n>>> X_norm\narray([[ 0.5,  0.5,  0.5,  1. ,  1. ],\n       [ 0.5,  0.5,  0.5,  1. ,  1. ],\n       [ 0.5, 11. ,  0.5,  1. ,  1. ]], dtype=float32)",
        "description": "Normalize counts per cell.Normalize each cell by total counts over all genes,\nso that every cell has the same total count after normalization.\nIf choosing `target_sum=1e6`, this is CPM normalization.\n\nIf `exclude_highly_expressed=True`, very highly expressed genes are excluded\nfrom the computation of the normalization factor (size factor) for each\ncell. This is meaningful as these can strongly influence the resulting\nnormalized values for all other genes [Weinreb17]_.\n\nSimilar functions are used, for example, by Seurat [Satija15]_, Cell Ranger\n[Zheng17]_ or SPRING [Weinreb17]_.",
        "example": "Example\n--------\n>>> from anndata import AnnData\n>>> import scanpy as sc\n>>> sc.settings.verbosity = 2\n>>> np.set_printoptions(precision=2)\n>>> adata = AnnData(np.array([\n...    [3, 3, 3, 6, 6],\n...    [1, 1, 1, 2, 2],\n...    [1, 22, 1, 2, 2],\n... ]))\n>>> adata.X\narray([[ 3.,  3.,  3.,  6.,  6.],\n       [ 1.,  1.,  1.,  2.,  2.],\n       [ 1., 22.,  1.,  2.,  2.]], dtype=float32)\n>>> X_norm = sc.pp.normalize_total(adata, target_sum=1, inplace=False)['X']\n>>> X_norm\narray([[0.14, 0.14, 0.14, 0.29, 0.29],\n       [0.14, 0.14, 0.14, 0.29, 0.29],\n       [0.04, 0.79, 0.04, 0.07, 0.07]], dtype=float32)\n>>> X_norm = sc.pp.normalize_total(\n...     adata, target_sum=1, exclude_highly_expressed=True,\n...     max_fraction=0.2, inplace=False\n... )['X']\nThe following highly-expressed genes are not considered during normalization factor computation:\n['1', '3', '4']\n>>> X_norm\narray([[ 0.5,  0.5,  0.5,  1. ,  1. ],\n       [ 0.5,  0.5,  0.5,  1. ,  1. ],\n       [ 0.5, 11. ,  0.5,  1. ,  1. ]], dtype=float32)",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.normalize_total(adata=$, target_sum=@, exclude_highly_expressed=@, max_fraction=@, key_added=@, layer=@, layers=@, layer_norm=@, inplace=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.ebi_expression_atlas": {
        "Parameters": {
            "accession": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Dataset accession. Like ``E-GEOD-98816`` or ``E-MTAB-4888``.\nThis can be found in the url on the datasets page, for example\nhttps://www.ebi.ac.uk/gxa/sc/experiments/E-GEOD-98816/results/tsne.",
                "optional_value": false
            },
            "filter_boring": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether boring labels in `.obs` should be automatically removed, such as\nlabels with a single or :attr:`~anndata.AnnData.n_obs` distinct values.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Load a dataset from the `EBI Single Cell Expression Atlas\n<https://www.ebi.ac.uk/gxa/sc/experiments>`__\n\nDownloaded datasets are saved in the directory specified by\n:attr:`~scanpy._settings.ScanpyConfig.datasetdir`.\n\nParams\n------\naccession\n    Dataset accession. Like ``E-GEOD-98816`` or ``E-MTAB-4888``.\n    This can be found in the url on the datasets page, for example\n    https://www.ebi.ac.uk/gxa/sc/experiments/E-GEOD-98816/results/tsne.\nfilter_boring\n    Whether boring labels in `.obs` should be automatically removed, such as\n    labels with a single or :attr:`~anndata.AnnData.n_obs` distinct values.\n\nExample\n-------\n>>> import scanpy as sc\n>>> adata = sc.datasets.ebi_expression_atlas(\"E-MTAB-4888\")",
        "description": "Load a dataset from the `EBI Single Cell Expression Atlas<https://www.ebi.ac.uk/gxa/sc/experiments>`__\n\nDownloaded datasets are saved in the directory specified by\n:attr:`~scanpy._settings.ScanpyConfig.datasetdir`.",
        "example": "Example\n-------\n>>> import scanpy as sc\n>>> adata = sc.datasets.ebi_expression_atlas(\"E-MTAB-4888\")",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.ebi_expression_atlas(accession=@, filter_boring=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.score_genes": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "gene_list": {
                "type": "Sequence[str]",
                "default": null,
                "optional": false,
                "description": "The list of gene names used for score calculation.",
                "optional_value": false
            },
            "ctrl_size": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "Number of reference genes to be sampled from each bin. If `len(gene_list)` is not too\nlow, you can set `ctrl_size=len(gene_list)`.",
                "optional_value": false
            },
            "gene_pool": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Genes for sampling the reference set. Default is all genes.",
                "optional_value": false
            },
            "n_bins": {
                "type": "int",
                "default": "25",
                "optional": true,
                "description": "Number of expression level bins for sampling.",
                "optional_value": false
            },
            "score_name": {
                "type": "str",
                "default": "score",
                "optional": true,
                "description": "Name of the field to be added in `.obs`.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "The random seed for sampling.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Copy `adata` or modify it inplace.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\n\n.. versionchanged:: 1.4.5\n   Default value changed from `False` to `None`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": "Depending on `copy`, returns or updates `adata` with an additional field\n`score_name`."
        },
        "Docstring": "Score a set of genes [Satija15]_.\n\nThe score is the average expression of a set of genes subtracted with the\naverage expression of a reference set of genes. The reference set is\nrandomly sampled from the `gene_pool` for each binned expression value.\n\nThis reproduces the approach in Seurat [Satija15]_ and has been implemented\nfor Scanpy by Davide Cittaro.\n\nParameters\n----------\nadata\n    The annotated data matrix.\ngene_list\n    The list of gene names used for score calculation.\nctrl_size\n    Number of reference genes to be sampled from each bin. If `len(gene_list)` is not too\n    low, you can set `ctrl_size=len(gene_list)`.\ngene_pool\n    Genes for sampling the reference set. Default is all genes.\nn_bins\n    Number of expression level bins for sampling.\nscore_name\n    Name of the field to be added in `.obs`.\nrandom_state\n    The random seed for sampling.\ncopy\n    Copy `adata` or modify it inplace.\nuse_raw\n    Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\n\n    .. versionchanged:: 1.4.5\n       Default value changed from `False` to `None`.\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with an additional field\n`score_name`.\n\nExamples\n--------\nSee this `notebook <https://github.com/scverse/scanpy_usage/tree/master/180209_cell_cycle>`__.",
        "description": "Score a set of genes [Satija15]_.The score is the average expression of a set of genes subtracted with the\naverage expression of a reference set of genes. The reference set is\nrandomly sampled from the `gene_pool` for each binned expression value.\n\nThis reproduces the approach in Seurat [Satija15]_ and has been implemented\nfor Scanpy by Davide Cittaro.",
        "example": "Examples\n--------\nSee this `notebook <https://github.com/scverse/scanpy_usage/tree/master/180209_cell_cycle>`__.",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.score_genes(adata=$, gene_list=@, ctrl_size=@, gene_pool=@, n_bins=@, score_name=@, random_state=@, copy=@, use_raw=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.tl.draw_graph": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "layout": {
                "type": "Literal[fr, drl, kk, grid_fr, lgl, rt, rt_circular, fa]",
                "default": "fa",
                "optional": true,
                "description": "'fa' (`ForceAtlas2`) or any valid `igraph layout\n<http://igraph.org/c/doc/igraph-Layout.html>`__. Of particular interest\nare 'fr' (Fruchterman Reingold), 'grid_fr' (Grid Fruchterman Reingold,\nfaster than 'fr'), 'kk' (Kamadi Kawai', slower than 'fr'), 'lgl' (Large\nGraph, very fast), 'drl' (Distributed Recursive Layout, pretty fast) and\n'rt' (Reingold Tilford tree layout).",
                "optional_value": true
            },
            "init_pos": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "`'paga'`/`True`, `None`/`False`, or any valid 2d-`.obsm` key.\nUse precomputed coordinates for initialization.\nIf `False`/`None` (the default), initialize randomly.",
                "optional_value": false
            },
            "root": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Root for tree layouts.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "For layouts with random initialization like 'fr', change this to use\ndifferent intial states for the optimization. If `None`, no seed is set.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "adjacency": {
                "type": "Optional[spmatrix]",
                "default": "None",
                "optional": true,
                "description": "Sparse adjacency matrix of the graph, defaults to neighbors connectivities.",
                "optional_value": true
            },
            "key_added_ext": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "By default, append `layout`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, draw_graph looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, draw_graph looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "obsp": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use .obsp[obsp] as adjacency. You can't specify both\n`obsp` and `neighbors_key` at the same time.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to adata.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Depending on `copy`, returns or updates `adata` with the following field.\n**X_draw_graph_layout** : `adata.obsm`\nCoordinates of graph layout. E.g. for layout='fa' (the default),\nthe field is called 'X_draw_graph_fa'"
        },
        "Docstring": "Force-directed graph drawing [Islam11]_ [Jacomy14]_ [Chippada18]_.\n\nAn alternative to tSNE that often preserves the topology of the data\nbetter. This requires to run :func:`~scanpy.pp.neighbors`, first.\n\nThe default layout ('fa', `ForceAtlas2`) [Jacomy14]_ uses the package |fa2|_\n[Chippada18]_, which can be installed via `pip install fa2`.\n\n`Force-directed graph drawing`_ describes a class of long-established\nalgorithms for visualizing graphs.\nIt has been suggested for visualizing single-cell data by [Islam11]_.\nMany other layouts as implemented in igraph [Csardi06]_ are available.\nSimilar approaches have been used by [Zunder15]_ or [Weinreb17]_.\n\n.. |fa2| replace:: `fa2`\n.. _fa2: https://github.com/bhargavchippada/forceatlas2\n.. _Force-directed graph drawing: https://en.wikipedia.org/wiki/Force-directed_graph_drawing\n\nParameters\n----------\nadata\n    Annotated data matrix.\nlayout\n    'fa' (`ForceAtlas2`) or any valid `igraph layout\n    <http://igraph.org/c/doc/igraph-Layout.html>`__. Of particular interest\n    are 'fr' (Fruchterman Reingold), 'grid_fr' (Grid Fruchterman Reingold,\n    faster than 'fr'), 'kk' (Kamadi Kawai', slower than 'fr'), 'lgl' (Large\n    Graph, very fast), 'drl' (Distributed Recursive Layout, pretty fast) and\n    'rt' (Reingold Tilford tree layout).\nroot\n    Root for tree layouts.\nrandom_state\n    For layouts with random initialization like 'fr', change this to use\n    different intial states for the optimization. If `None`, no seed is set.\nadjacency\n    Sparse adjacency matrix of the graph, defaults to neighbors connectivities.\nkey_added_ext\n    By default, append `layout`.\nproceed\n    Continue computation, starting off with 'X_draw_graph_`layout`'.\ninit_pos\n    `'paga'`/`True`, `None`/`False`, or any valid 2d-`.obsm` key.\n    Use precomputed coordinates for initialization.\n    If `False`/`None` (the default), initialize randomly.\nneighbors_key\n    If not specified, draw_graph looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, draw_graph looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\nobsp\n    Use .obsp[obsp] as adjacency. You can't specify both\n    `obsp` and `neighbors_key` at the same time.\ncopy\n    Return a copy instead of writing to adata.\n**kwds\n    Parameters of chosen igraph layout. See e.g. `fruchterman-reingold`_\n    [Fruchterman91]_. One of the most important ones is `maxiter`.\n\n    .. _fruchterman-reingold: http://igraph.org/python/doc/igraph.Graph-class.html#layout_fruchterman_reingold\n\nReturns\n-------\nDepending on `copy`, returns or updates `adata` with the following field.\n\n**X_draw_graph_layout** : `adata.obsm`\n    Coordinates of graph layout. E.g. for layout='fa' (the default),\n    the field is called 'X_draw_graph_fa'",
        "description": "Force-directed graph drawing [Islam11]_ [Jacomy14]_ [Chippada18]_.An alternative to tSNE that often preserves the topology of the data\nbetter. This requires to run :func:`~scanpy.pp.neighbors`, first.\n\nThe default layout ('fa', `ForceAtlas2`) [Jacomy14]_ uses the package |fa2|_\n[Chippada18]_, which can be installed via `pip install fa2`.\n\n`Force-directed graph drawing`_ describes a class of long-established\nalgorithms for visualizing graphs.\nIt has been suggested for visualizing single-cell data by [Islam11]_.\nMany other layouts as implemented in igraph [Csardi06]_ are available.\nSimilar approaches have been used by [Zunder15]_ or [Weinreb17]_.\n\n.. |fa2| replace:: `fa2`\n.. _fa2: https://github.com/bhargavchippada/forceatlas2\n.. _Force-directed graph drawing: https://en.wikipedia.org/wiki/Force-directed_graph_drawing",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.tl.draw_graph(adata=$, layout=$, init_pos=@, root=@, random_state=@, n_jobs=@, adjacency=$, key_added_ext=@, neighbors_key=@, obsp=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.filter_genes": {
        "Parameters": {
            "data": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\nto cells and columns to genes.",
                "optional_value": true
            },
            "min_counts": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum number of counts required for a gene to pass filtering.",
                "optional_value": false
            },
            "min_cells": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum number of cells expressed required for a gene to pass filtering.",
                "optional_value": false
            },
            "max_counts": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum number of counts required for a gene to pass filtering.",
                "optional_value": false
            },
            "max_cells": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum number of cells expressed required for a gene to pass filtering.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Perform computation inplace or return result.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[AnnData, tuple[ndarray, ndarray]]]",
            "description": "Depending on `inplace`, returns the following arrays or directly subsets\nand annotates the data matrix\ngene_subset\nBoolean index mask that does filtering. `True` means that the\ngene is kept. `False` means the gene is removed.\nnumber_per_gene\nDepending on what was thresholded (`counts` or `cells`), the array stores\n`n_counts` or `n_cells` per gene."
        },
        "Docstring": "Filter genes based on number of cells or counts.\n\nKeep genes that have at least `min_counts` counts or are expressed in at\nleast `min_cells` cells or have at most `max_counts` counts or are expressed\nin at most `max_cells` cells.\n\nOnly provide one of the optional parameters `min_counts`, `min_cells`,\n`max_counts`, `max_cells` per call.\n\nParameters\n----------\ndata\n    An annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\n    to cells and columns to genes.\nmin_counts\n    Minimum number of counts required for a gene to pass filtering.\nmin_cells\n    Minimum number of cells expressed required for a gene to pass filtering.\nmax_counts\n    Maximum number of counts required for a gene to pass filtering.\nmax_cells\n    Maximum number of cells expressed required for a gene to pass filtering.\ninplace\n    Perform computation inplace or return result.\n\nReturns\n-------\nDepending on `inplace`, returns the following arrays or directly subsets\nand annotates the data matrix\n\ngene_subset\n    Boolean index mask that does filtering. `True` means that the\n    gene is kept. `False` means the gene is removed.\nnumber_per_gene\n    Depending on what was thresholded (`counts` or `cells`), the array stores\n    `n_counts` or `n_cells` per gene.",
        "description": "Filter genes based on number of cells or counts.Keep genes that have at least `min_counts` counts or are expressed in at\nleast `min_cells` cells or have at most `max_counts` counts or are expressed\nin at most `max_cells` cells.\n\nOnly provide one of the optional parameters `min_counts`, `min_cells`,\n`max_counts`, `max_cells` per call.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.filter_genes(data=$, min_counts=@, min_cells=@, max_counts=@, max_cells=@, inplace=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.datasets.paul15": {
        "Parameters": {},
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data matrix."
        },
        "Docstring": "Development of Myeloid Progenitors [Paul15]_.\n\nNon-logarithmized raw data.\n\nThe data has been sent out by Email from the Amit Lab. An R version for\nloading the data can be found here\nhttps://github.com/theislab/scAnalysisTutorial\n\nReturns\n-------\nAnnotated data matrix.",
        "description": "Development of Myeloid Progenitors [Paul15]_.Non-logarithmized raw data.\n\nThe data has been sent out by Email from the Amit Lab. An R version for\nloading the data can be found here\nhttps://github.com/theislab/scAnalysisTutorial",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.datasets.paul15()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.tl.cyclone": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "marker_pairs": {
                "type": "Optional[Mapping[str, Collection[tuple[str, str]]]]",
                "default": "None",
                "optional": true,
                "description": "Mapping of categories to lists of marker pairs.\nSee :func:`~scanpy.external.tl.sandbag` output.",
                "optional_value": false
            },
            "iterations": {
                "type": "int",
                "default": "1000",
                "optional": true,
                "description": "An integer scalar specifying the number of\niterations for random sampling to obtain a cycle score.",
                "optional_value": false
            },
            "min_iter": {
                "type": "int",
                "default": "100",
                "optional": true,
                "description": "An integer scalar specifying the minimum number of iterations\nfor score estimation.",
                "optional_value": false
            },
            "min_pairs": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "An integer scalar specifying the minimum number of pairs\nfor score estimation.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": "A :class:`~pandas.DataFrame` with samples as index and categories as columns\nwith scores for each category for each sample and a additional column with\nthe name of the max scoring category for each sample.\nIf `marker_pairs` contains only the cell cycle categories G1, S and G2M an\nadditional column `pypairs_cc_prediction` will be added.\nWhere category S is assigned to samples where G1 and G2M score are < 0.5."
        },
        "Docstring": "Assigns scores and predicted class to observations [Scialdone15]_ [Fechtner18]_.\n\nCalculates scores for each observation and each phase and assigns prediction\nbased on marker pairs indentified by :func:`~scanpy.external.tl.sandbag`.\n\nThis reproduces the approach of [Scialdone15]_ in the implementation of\n[Fechtner18]_.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nmarker_pairs\n    Mapping of categories to lists of marker pairs.\n    See :func:`~scanpy.external.tl.sandbag` output.\niterations\n    An integer scalar specifying the number of\n    iterations for random sampling to obtain a cycle score.\nmin_iter\n    An integer scalar specifying the minimum number of iterations\n    for score estimation.\nmin_pairs\n    An integer scalar specifying the minimum number of pairs\n    for score estimation.\n\nReturns\n-------\nA :class:`~pandas.DataFrame` with samples as index and categories as columns\nwith scores for each category for each sample and a additional column with\nthe name of the max scoring category for each sample.\n\nIf `marker_pairs` contains only the cell cycle categories G1, S and G2M an\nadditional column `pypairs_cc_prediction` will be added.\nWhere category S is assigned to samples where G1 and G2M score are < 0.5.",
        "description": "Assigns scores and predicted class to observations [Scialdone15]_ [Fechtner18]_.Calculates scores for each observation and each phase and assigns prediction\nbased on marker pairs indentified by :func:`~scanpy.external.tl.sandbag`.\n\nThis reproduces the approach of [Scialdone15]_ in the implementation of\n[Fechtner18]_.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.tl.cyclone(adata=$, marker_pairs=@, iterations=@, min_iter=@, min_pairs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.filter_genes_dispersion": {
        "Parameters": {
            "result": {
                "type": "recarray",
                "default": null,
                "optional": false,
                "description": "Result of :func:`~scanpy.pp.filter_genes_dispersion`.",
                "optional_value": true
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axes.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {{`'.pdf'`, `'.png'`, `'.svg'`}}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot dispersions versus means for genes.\n\nProduces Supp. Fig. 5c of Zheng et al. (2017) and MeanVarPlot() of Seurat.\n\nParameters\n----------\nresult\n    Result of :func:`~scanpy.pp.filter_genes_dispersion`.\nlog\n    Plot on logarithmic axes.\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {{`'.pdf'`, `'.png'`, `'.svg'`}}.",
        "description": "Plot dispersions versus means for genes.Produces Supp. Fig. 5c of Zheng et al. (2017) and MeanVarPlot() of Seurat.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.filter_genes_dispersion(result=$, log=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.tsne": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/cells or variables/genes, e.g.,\n`'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows\nalternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points\nwith higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show edges.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Width of edges.",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, this looks\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use\n`components='all'`.",
                "optional_value": false
            },
            "dimensions": {
                "type": "Optional[Union[tuple[int, int], Sequence[tuple[int, int]]]]",
                "default": "None",
                "optional": true,
                "description": "0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\nUnlike `components`, this argument is used in the same way as `colors`, e.g. is\nused to specify a single plot at a time. Will eventually replace the components\nargument.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer`\ntakes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "Union[str, tuple[float, Ellipsis]]",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a\ncolor. Used for all points if `color=None`.",
                "optional_value": false
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend. Currently\nonly implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_cells.\nCan be a sequence containing the size for each cell. The order should be\nthe same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in\n:func:`~scanpy.set_figure_params`, defaults to `True`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size.\nSee :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword\nfor the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using\nthe path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "colorbar_loc": {
                "type": "Optional[str]",
                "default": "right",
                "optional": true,
                "description": "Where to place the colorbar for continous variables. If `None`, no colorbar\nis added.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[Union[str, float, Callable[Sequence[float], float], Sequence[Union[str, float, Callable[Sequence[float], float]]]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings,\ne.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, List[Axes]]]",
            "description": "If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it."
        },
        "Docstring": "Scatter plot in tSNE basis.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    Keys for annotations of observations/cells or variables/genes, e.g.,\n    `'ann1'` or `['ann1', 'ann2']`.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. By default `var_names`\n    refer to the index column of the `.var` DataFrame. Setting this option allows\n    alternative names to be used.\nuse_raw\n    Use `.raw` attribute of `adata` for coloring with gene expression. If `None`,\n    defaults to `True` if `layer` isn't provided and `adata.raw` is present.\nlayer\n    Name of the AnnData object layer that wants to be plotted. By default\n    adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n    If `layer` is set to a valid layer name, then the layer is plotted. `layer`\n    takes precedence over `use_raw`.\nedges\n    Show edges.\nedges_width\n    Width of edges.\nedges_color\n    Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\nneighbors_key\n    Where to look for neighbors connectivities.\n    If not specified, this looks .obsp['connectivities'] for connectivities\n    (default storage place for pp.neighbors).\n    If specified, this looks\n    .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\narrows\n    Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\narrows_kwds\n    Passed to :meth:`~matplotlib.axes.Axes.quiver`\nsort_order\n    For continuous annotations used as color parameter, plot data points\n    with higher values on top of others.\ngroups\n    Restrict to a few categories in categorical observation annotation.\n    The default is not to restrict to any groups.\ndimensions\n    0-indexed dimensions of the embedding to plot as integers. E.g. [(0, 1), (1, 2)].\n    Unlike `components`, this argument is used in the same way as `colors`, e.g. is\n    used to specify a single plot at a time. Will eventually replace the components\n    argument.\ncomponents\n    For instance, `['1,2', '2,3']`. To plot all available components use\n    `components='all'`.\nprojection\n    Projection of plot (default: `'2d'`).\nlegend_loc\n    Location of legend, either `'on data'`, `'right margin'` or a valid keyword\n    for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\nlegend_fontsize\n    Numeric size in pt or string describing the size.\n    See :meth:`~matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Legend font weight. A numeric value in range 0-1000 or a string.\n    Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n    See :meth:`~matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Line width of the legend font outline in pt. Draws a white outline using\n    the path effect :class:`~matplotlib.patheffects.withStroke`.\ncolorbar_loc\n    Where to place the colorbar for continous variables. If `None`, no colorbar\n    is added.\nsize\n    Point size. If `None`, is automatically computed as 120000 / n_cells.\n    Can be a sequence containing the size for each cell. The order should be\n    the same as in adata.obs.\ncolor_map\n    Color map to use for continous variables. Can be a name or a\n    :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n    or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n    If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n    The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\npalette\n    Colors to use for plotting categorical annotation groups.\n    The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n    (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n    categories to colors, or a sequence of colors. Colors must be valid to\n    matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n    If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n    variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n    If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\nna_color\n    Color to use for null or masked values. Can be anything matplotlib accepts as a\n    color. Used for all points if `color=None`.\nna_in_legend\n    If there are missing values, whether they get an entry in the legend. Currently\n    only implemented for categorical legends.\nframeon\n    Draw a frame around the scatter plot. Defaults to value set in\n    :func:`~scanpy.set_figure_params`, defaults to `True`.\ntitle\n    Provide title for panels either as string or list of strings,\n    e.g. `['title1', 'title2', ...]`.\n\nvmin\n    The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n    with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n    vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n    For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n    vmin is interpreted as the return value of the function over the list of values to plot.\n    For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n    np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n    minimum value is used as defined by matplotlib `scatter` function. When making multiple\n    plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\nvmax\n    The value representing the upper limit of the color scale. The format is the same as for `vmin`.\nvcenter\n    The value representing the center of the color scale. Useful for diverging colormaps.\n    The format is the same as for `vmin`.\n    Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\nadd_outline\n    If set to True, this will add a thin border around groups of dots. In some situations\n    this can enhance the aesthetics of the resulting image\noutline_color\n    Tuple with two valid color names used to adjust the add_outline. The first color is the\n    border color (default: black), while the second color is a gap color between the\n    border color and the scatter dot (default: white).\noutline_width\n    Tuple with two width numbers used to adjust the outline. The first value is the width\n    of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n    width of the gap color (default: 0.05).\nncols\n    Number of panels per row.\nwspace\n    Adjust the width of the space between multiple panels.\nhspace\n    Adjust the height of the space between multiple panels.\nreturn_fig\n    Return the matplotlib figure.\nkwargs\n    Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n    for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\nshow\n     Show the plot, do not return axis.\nsave\n    If `True` or a `str`, save the figure.\n    A string is appended to the default filename.\n    Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\nax\n    A matplotlib axes object. Only works if plotting a single component.\n\nReturns\n-------\nIf `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.tsne(adata)\n    sc.pl.tsne(adata, color='bulk_labels')\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.tsne",
        "description": "Scatter plot in tSNE basis.",
        "example": "Examples\n--------\n.. plot::\n    :context: close-figs\n\n    import scanpy as sc\n    adata = sc.datasets.pbmc68k_reduced()\n    sc.tl.tsne(adata)\n    sc.pl.tsne(adata, color='bulk_labels')\n\n.. currentmodule:: scanpy\n\nSee also\n--------\ntl.tsne",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.tsne(adata=$, color=@, gene_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, dimensions=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=@, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, colorbar_loc=@, vmax=@, vmin=@, vcenter=@, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.dpt_timeseries": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "color_map": {
                "type": "Union[str, Colormap]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "as_heatmap": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Plot the timeseries as heatmap.",
                "optional_value": false
            },
            "marker": {
                "type": "Union[str, Sequence[str]]",
                "default": ".",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Heatmap of pseudotime series.\n\nParameters\n----------\nas_heatmap\n    Plot the timeseries as heatmap.",
        "description": "Heatmap of pseudotime series.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.dpt_timeseries(adata=$, color_map=@, show=@, save=@, as_heatmap=@, marker=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.get.rank_genes_groups_df": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Object to get results from.",
                "optional_value": true
            },
            "group": {
                "type": "Union[str, Iterable[str]]",
                "default": null,
                "optional": false,
                "description": "Which group (as in :func:`scanpy.tl.rank_genes_groups`'s `groupby`\nargument) to return results from. Can be a list. All groups are\nreturned if groups is `None`.",
                "optional_value": false
            },
            "key": {
                "type": "str",
                "default": "rank_genes_groups",
                "optional": true,
                "description": "Key differential expression groups were stored under.",
                "optional_value": false
            },
            "pval_cutoff": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Return only adjusted p-values below the  cutoff.",
                "optional_value": false
            },
            "log2fc_min": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Minimum logfc to return.",
                "optional_value": false
            },
            "log2fc_max": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Maximum logfc to return.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols. Specifying\nthis will add that column to the returned dataframe.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": ""
        },
        "Docstring": ":func:`scanpy.tl.rank_genes_groups` results in the form of a\n:class:`~pandas.DataFrame`.\n\nParams\n------\nadata\n    Object to get results from.\ngroup\n    Which group (as in :func:`scanpy.tl.rank_genes_groups`'s `groupby`\n    argument) to return results from. Can be a list. All groups are\n    returned if groups is `None`.\nkey\n    Key differential expression groups were stored under.\npval_cutoff\n    Return only adjusted p-values below the  cutoff.\nlog2fc_min\n    Minimum logfc to return.\nlog2fc_max\n    Maximum logfc to return.\ngene_symbols\n    Column name in `.var` DataFrame that stores gene symbols. Specifying\n    this will add that column to the returned dataframe.\n\nExample\n-------\n>>> import scanpy as sc\n>>> pbmc = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(pbmc, groupby=\"louvain\", use_raw=True)\n>>> dedf = sc.get.rank_genes_groups_df(pbmc, group=\"0\")",
        "description": ":func:`scanpy.tl.rank_genes_groups` results in the form of a:class:`~pandas.DataFrame`.",
        "example": "Example\n-------\n>>> import scanpy as sc\n>>> pbmc = sc.datasets.pbmc68k_reduced()\n>>> sc.tl.rank_genes_groups(pbmc, groupby=\"louvain\", use_raw=True)\n>>> dedf = sc.get.rank_genes_groups_df(pbmc, group=\"0\")",
        "api_type": "function",
        "api_calling": [
            "scanpy.get.rank_genes_groups_df(adata=$, group=@, key=@, pval_cutoff=@, log2fc_min=@, log2fc_max=@, gene_symbols=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.queries.biomart_annotations": {
        "Parameters": {
            "org": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Organism to query. Must be an organism in ensembl biomart. \"hsapiens\",\n\"mmusculus\", \"drerio\", etc.",
                "optional_value": false
            },
            "attrs": {
                "type": "Iterable[str]",
                "default": null,
                "optional": false,
                "description": "Attributes to query biomart for.",
                "optional_value": false
            },
            "host": {
                "type": "str",
                "default": "www.ensembl.org",
                "optional": true,
                "description": "A valid BioMart host URL. Alternative values include archive urls (like\n\"grch37.ensembl.org\") or regional mirrors (like \"useast.ensembl.org\").",
                "optional_value": false
            },
            "use_cache": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether pybiomart should use a cache for requests. Will create a\n`.pybiomart.sqlite` file in current directory if used.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "DataFrame",
            "description": "Dataframe containing annotations."
        },
        "Docstring": "Retrieve gene annotations from ensembl biomart.\n\nParameters\n----------\norg\n    Organism to query. Must be an organism in ensembl biomart. \"hsapiens\",\n    \"mmusculus\", \"drerio\", etc.\nattrs\n    Attributes to query biomart for.\nhost\n    A valid BioMart host URL. Alternative values include archive urls (like\n    \"grch37.ensembl.org\") or regional mirrors (like \"useast.ensembl.org\").\nuse_cache\n    Whether pybiomart should use a cache for requests. Will create a\n    `.pybiomart.sqlite` file in current directory if used.\n\nReturns\n-------\nDataframe containing annotations.\n\nExamples\n--------\nRetrieve genes coordinates and chromosomes\n\n>>> import scanpy as sc\n>>> annot = sc.queries.biomart_annotations(\n        \"hsapiens\",\n        [\"ensembl_gene_id\", \"start_position\", \"end_position\", \"chromosome_name\"],\n    ).set_index(\"ensembl_gene_id\")\n>>> adata.var[annot.columns] = annot",
        "description": "Retrieve gene annotations from ensembl biomart.",
        "example": "Examples\n--------\nRetrieve genes coordinates and chromosomes\n\n>>> import scanpy as sc\n>>> annot = sc.queries.biomart_annotations(\n        \"hsapiens\",\n        [\"ensembl_gene_id\", \"start_position\", \"end_position\", \"chromosome_name\"],\n    ).set_index(\"ensembl_gene_id\")\n>>> adata.var[annot.columns] = annot",
        "api_type": "function",
        "api_calling": [
            "scanpy.queries.biomart_annotations(org=@, attrs=@, host=@, use_cache=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pp.log1p": {
        "Parameters": {
            "X": {
                "type": "Union[AnnData, ndarray, spmatrix]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\nRows correspond to cells and columns to genes.",
                "optional_value": true
            },
            "base": {
                "type": "Optional[Number]",
                "default": "None",
                "optional": true,
                "description": "Base of the logarithm. Natural logarithm is used by default.",
                "optional_value": true
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If an :class:`~anndata.AnnData` is passed, determines whether a copy\nis returned.",
                "optional_value": false
            },
            "chunked": {
                "type": "bool",
                "default": "None",
                "optional": true,
                "description": "Process the data matrix in chunks, which will save memory.\nApplies only to :class:`~anndata.AnnData`.",
                "optional_value": false
            },
            "chunk_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "`n_obs` of the chunks to process the data in.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Entry of layers to transform.",
                "optional_value": false
            },
            "obsm": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Entry of obsm to transform.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Returns or updates `data`, depending on `copy`."
        },
        "Docstring": "Logarithmize the data matrix.\n\nComputes :math:`X = \\log(X + 1)`,\nwhere :math:`log` denotes the natural logarithm unless a different base is given.\n\nParameters\n----------\nX\n    The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`.\n    Rows correspond to cells and columns to genes.\nbase\n    Base of the logarithm. Natural logarithm is used by default.\ncopy\n    If an :class:`~anndata.AnnData` is passed, determines whether a copy\n    is returned.\nchunked\n    Process the data matrix in chunks, which will save memory.\n    Applies only to :class:`~anndata.AnnData`.\nchunk_size\n    `n_obs` of the chunks to process the data in.\nlayer\n    Entry of layers to transform.\nobsm\n    Entry of obsm to transform.\n\nReturns\n-------\nReturns or updates `data`, depending on `copy`.",
        "description": "Logarithmize the data matrix.Computes :math:`X = \\log(X + 1)`,\nwhere :math:`log` denotes the natural logarithm unless a different base is given.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pp.log1p(X=$, base=$, copy=@, chunked=@, chunk_size=@, layer=@, obsm=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.read_excel": {
        "Parameters": {
            "filename": {
                "type": "PathLike",
                "default": null,
                "optional": false,
                "description": "File name to read from.",
                "optional_value": true
            },
            "sheet": {
                "type": "Union[str, int]",
                "default": null,
                "optional": false,
                "description": "Name of sheet in Excel file.",
                "optional_value": false
            },
            "dtype": {
                "type": "str",
                "default": "float32",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Read `.xlsx` (Excel) file.\n\nAssumes that the first columns stores the row names and the first row the\ncolumn names.\n\nParameters\n----------\nfilename\n    File name to read from.\nsheet\n    Name of sheet in Excel file.",
        "description": "Read `.xlsx` (Excel) file.Assumes that the first columns stores the row names and the first row the\ncolumn names.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.read_excel(filename=$, sheet=@, dtype=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.pl.paga_compare": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "basis": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "edges": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "color": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "alpha": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "groups": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "components": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "projection": {
                "type": "Literal[2d, 3d]",
                "default": "2d",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "legend_loc": {
                "type": null,
                "default": "on data",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, Literal[xx-small, x-small, small, medium, large, x-large, xx-large]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, Literal[light, normal, medium, semibold, bold, heavy, black]]",
                "default": "bold",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "color_map": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "palette": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "frameon": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "size": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "title": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "right_margin": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "left_margin": {
                "type": null,
                "default": "0.05",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "show": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "save": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "title_graph": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "groups_graph": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "pos": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "paga_graph_params": {
                "type": null,
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "A list of :class:`~matplotlib.axes.Axes` if `show` is `False`."
        },
        "Docstring": "Scatter and PAGA graph side-by-side.\n\nConsists in a scatter plot and the abstracted graph. See\n:func:`~scanpy.pl.paga` for all related parameters.\n\nSee :func:`~scanpy.pl.paga_path` for visualizing gene changes along paths\nthrough the abstracted graph.\n\nAdditional parameters are as follows.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nkwds_scatter\n    Keywords for :func:`~scanpy.pl.scatter`.\nkwds_paga\n    Keywords for :func:`~scanpy.pl.paga`.\n\nReturns\n-------\nA list of :class:`~matplotlib.axes.Axes` if `show` is `False`.",
        "description": "Scatter and PAGA graph side-by-side.Consists in a scatter plot and the abstracted graph. See\n:func:`~scanpy.pl.paga` for all related parameters.\n\nSee :func:`~scanpy.pl.paga_path` for visualizing gene changes along paths\nthrough the abstracted graph.\n\nAdditional parameters are as follows.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "scanpy.pl.paga_compare(adata=$, basis=$, edges=$, color=$, alpha=$, groups=$, components=$, projection=$, legend_loc=$, legend_fontsize=@, legend_fontweight=@, legend_fontoutline=$, color_map=$, palette=$, frameon=$, size=$, title=$, right_margin=$, left_margin=$, show=$, save=$, title_graph=$, groups_graph=$, pos=$, paga_graph_params=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "scanpy.external.pp.scanorama_integrate": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": true
            },
            "key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "The name of the column in ``adata.obs`` that differentiates\namong experiments/batches. Cells from the same batch must be\ncontiguously stored in ``adata``.",
                "optional_value": false
            },
            "basis": {
                "type": "str",
                "default": "X_pca",
                "optional": true,
                "description": "The name of the field in ``adata.obsm`` where the PCA table is\nstored. Defaults to ``'X_pca'``, which is the default for\n``sc.tl.pca()``.",
                "optional_value": false
            },
            "adjusted_basis": {
                "type": "str",
                "default": "X_scanorama",
                "optional": true,
                "description": "The name of the field in ``adata.obsm`` where the integrated\nembeddings will be stored after running this function. Defaults\nto ``X_scanorama``.",
                "optional_value": false
            },
            "knn": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of nearest neighbors to use for matching.",
                "optional_value": false
            },
            "sigma": {
                "type": "float",
                "default": "15",
                "optional": true,
                "description": "Correction smoothing parameter on Gaussian kernel.",
                "optional_value": false
            },
            "approx": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Use approximate nearest neighbors with Python ``annoy``;\ngreatly speeds up matching runtime.",
                "optional_value": false
            },
            "alpha": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Alignment score minimum cutoff.",
                "optional_value": false
            },
            "batch_size": {
                "type": "int",
                "default": "5000",
                "optional": true,
                "description": "The batch size used in the alignment vector computation. Useful\nwhen integrating very large (>100k samples) datasets. Set to\nlarge value that runs within available memory.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Updates adata with the field ``adata.obsm[adjusted_basis]``,\ncontaining Scanorama embeddings such that different experiments\nare integrated."
        },
        "Docstring": "Use Scanorama [Hie19]_ to integrate different experiments.\n\nScanorama [Hie19]_ is an algorithm for integrating single-cell\ndata from multiple experiments stored in an AnnData object. This\nfunction should be run after performing PCA but before computing\nthe neighbor graph, as illustrated in the example below.\n\nThis uses the implementation of `scanorama\n<https://github.com/brianhie/scanorama>`__ [Hie19]_.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nkey\n    The name of the column in ``adata.obs`` that differentiates\n    among experiments/batches. Cells from the same batch must be\n    contiguously stored in ``adata``.\nbasis\n    The name of the field in ``adata.obsm`` where the PCA table is\n    stored. Defaults to ``'X_pca'``, which is the default for\n    ``sc.tl.pca()``.\nadjusted_basis\n    The name of the field in ``adata.obsm`` where the integrated\n    embeddings will be stored after running this function. Defaults\n    to ``X_scanorama``.\nknn\n    Number of nearest neighbors to use for matching.\nsigma\n    Correction smoothing parameter on Gaussian kernel.\napprox\n    Use approximate nearest neighbors with Python ``annoy``;\n    greatly speeds up matching runtime.\nalpha\n    Alignment score minimum cutoff.\nbatch_size\n    The batch size used in the alignment vector computation. Useful\n    when integrating very large (>100k samples) datasets. Set to\n    large value that runs within available memory.\nkwargs\n    Any additional arguments will be passed to\n    ``scanorama.integrate()``.\n\nReturns\n-------\nUpdates adata with the field ``adata.obsm[adjusted_basis]``,\ncontaining Scanorama embeddings such that different experiments\nare integrated.\n\nExample\n-------\nFirst, load libraries and example dataset, and preprocess.\n\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> adata = sc.datasets.pbmc3k()\n>>> sc.pp.recipe_zheng17(adata)\n>>> sc.tl.pca(adata)\n\nWe now arbitrarily assign a batch metadata variable to each cell\nfor the sake of example, but during real usage there would already\nbe a column in ``adata.obs`` giving the experiment each cell came\nfrom.\n\n>>> adata.obs['batch'] = 1350*['a'] + 1350*['b']\n\nFinally, run Scanorama. Afterwards, there will be a new table in\n``adata.obsm`` containing the Scanorama embeddings.\n\n>>> sce.pp.scanorama_integrate(adata, 'batch')\n>>> 'X_scanorama' in adata.obsm\nTrue",
        "description": "Use Scanorama [Hie19]_ to integrate different experiments.Scanorama [Hie19]_ is an algorithm for integrating single-cell\ndata from multiple experiments stored in an AnnData object. This\nfunction should be run after performing PCA but before computing\nthe neighbor graph, as illustrated in the example below.\n\nThis uses the implementation of `scanorama\n<https://github.com/brianhie/scanorama>`__ [Hie19]_.",
        "example": "Example\n-------\nFirst, load libraries and example dataset, and preprocess.\n\n>>> import scanpy as sc\n>>> import scanpy.external as sce\n>>> adata = sc.datasets.pbmc3k()\n>>> sc.pp.recipe_zheng17(adata)\n>>> sc.tl.pca(adata)\n\nWe now arbitrarily assign a batch metadata variable to each cell\nfor the sake of example, but during real usage there would already\nbe a column in ``adata.obs`` giving the experiment each cell came\nfrom.\n\n>>> adata.obs['batch'] = 1350*['a'] + 1350*['b']\n\nFinally, run Scanorama. Afterwards, there will be a new table in\n``adata.obsm`` containing the Scanorama embeddings.\n\n>>> sce.pp.scanorama_integrate(adata, 'batch')\n>>> 'X_scanorama' in adata.obsm\nTrue",
        "api_type": "function",
        "api_calling": [
            "scanpy.external.pp.scanorama_integrate(adata=$, key=@, basis=@, adjusted_basis=@, knn=@, sigma=@, approx=@, alpha=@, batch_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "embed_umap_paga_graph": {
        "relevant APIs": [
            "scanpy.tl.paga",
            "scanpy.pl.paga",
            "scanpy.tl.umap"
        ],
        "type": "compositeAPI",
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix containing information about the cells and their attributes."
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "An annotated data matrix with the embedded neighborhood graph in two dimensions."
        },
        "Docstring": "Embeds the neighborhood graph of the input annotated data matrix into two dimensions using UMAP, potentially preserving global manifold connectivity better than tSNE.\n\nThis function takes an annotated data matrix (AnnData) as input and returns an annotated data matrix with the embedded graph in two dimensions. The neighborhood graph is created using APIs for mapping coarse-grained connectivity structures [Wolf19] and is then visualized as a PAGA graph through low-connectivity edge thresholding [API2]. The embedding is performed using UMAP [McInnes18]. Disconnected clusters and connectivity violations might be observed, which can usually be remedied\nby additional processing.\n\nParameters:\n----------\nadata : AnnData\n    Annotated data matrix containing information about the cells and their attributes.\n\nReturns:\n----------\nAnnData\n    An annotated data matrix with the embedded neighborhood graph in two dimensions.\n\nNotes:\n----------\nWe recommend using UMAP for embedding the graph as it can better preserve the global connectivity of the manifold compared to tSNE. If issues like disconnected clusters or connectivity violations arise, additional steps may be necessary to address them.\n\nReferences:\n----------\n- Wolf, F. A., Hamey, F. K., Plass, M., Solana, J., Dahlin, J. S., Gttgens, B., ... & Theis, F. J. (2019).\n  PAGA: graph abstraction reconciles clustering with trajectory inference through a topology preserving map\n  of single cells. Genome biology, 20(1), 59.\n\n- McInnes, L., Healy, J., & Melville, J. (2018).\n  UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction.\n  arXiv preprint arXiv:1802.03426.",
        "description": "Embeds the neighborhood graph of the input annotated data matrix into two dimensions using UMAP, potentially preserving global manifold connectivity better than tSNE.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "embed_umap_paga_graph(adata=$)"
        ]
    },
        "rank_genes_groups_analysis": {
            "relevant APIs": [
                "scanpy.tl.rank_genes_groups",
                "scanpy.pl.rank_genes_groups"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "An annotated data matrix."
                },
                "groupby": {
                    "type": "str",
                    "default": null,
                    "optional": false,
                    "description": "The key of the observation grouping to consider."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "An annotated data matrix with computed marker gene rankings."
            },
            "Docstring":"Find marker genes.\n\nCompute a ranking of highly differential genes for each cluster defined by the 'groupby' key in the provided annotated data matrix ('adata'). This function uses the t-test as the default method to calculate differential expression. The ranking is then used to characterize groups based on gene expression.\n\nParameters:\nadata ('AnnData'): An annotated data matrix.\ngroupby (str): The key of the observation grouping to consider.\n\nReturns:\n'AnnData': An annotated data matrix with computed marker gene rankings.\n\nExample usage:\n>>> result_data = find_marker_genes(adata, 'cell_type')",
            "description":"Find marker genes.",
            "example": "result_data = find_marker_genes(adata, 'cell_type')",
            "api_type": "function",
            "api_calling": [
                "rank_genes_groups_analysis(adata=$, groupby=@)"
            ]
        },
        "configure_plotting_and_versions": {
            "relevant APIs": [
                "scanpy.settings.verbosity",
                "scanpy.logging.print_versions",
                "scanpy.settings.set_figure_params"
            ],
            "type": "compositeAPI",
            "Parameters": {},
            "Returns": {
                "type": "None",
                "description": "None"
            },
            "Docstring":"Perform internal operations that influence numerical output. This function sets up the resolution, styling, and export options for default plotting. It also prints package versions that might affect numerical results. The verbosity level can be adjusted to control the level of information displayed.",
            "description":"Perform internal operations that influence numerical output",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "configure_plotting_and_versions()"
            ]
        },
        "preprocess_pca_neighgraph_draw": {
            "relevant APIs": [
                "scanpy.pp.recipe_zheng17",
                "scanpy.tl.pca",
                "scanpy.pp.neighbors",
                "scanpy.tl.draw_graph",
                "scanpy.pl.draw_graph"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "An annotated data matrix."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "An annotated data matrix after preprocessing."
            },
            "Docstring":"Perform preprocessing on the input annotated data matrix using various APIs.\n\nParameters:\nadata (AnnData): An annotated data matrix.\n\nReturns:\nAnnData: An annotated data matrix after preprocessing.\n\nThis function applies a series of preprocessing steps on the input data matrix using various APIs. It scales the data to have unit variance and zero mean using API1. Then, it performs Principal Component Analysis (PCA) using API2. Next, it computes a neighborhood graph of observations using API3. The graph is further visualized through force-directed graph drawing using API4. Finally, the results of the graph drawing are plotted using API5. The function returns the annotated data matrix after all these preprocessing and visualization steps.",
            "description":"Perform preprocessing on the input annotated data matrix using various APIs.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "preprocess_pca_neighgraph_draw(adata=$)"
            ]
        },
        "preprocess_diffmap_neighbors": {
            "relevant APIs": [
                "scanpy.tl.diffmap",
                "scanpy.pp.neighbors"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "An annotated data matrix."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "An annotated data matrix containing the preprocessed data."
            },
            "Docstring":"Apply a simple preprocessing recipe to the provided annotated data matrix.\n\nThis function takes an annotated data matrix (`adata`) as input and performs a preprocessing procedure, utilizing Diffusion maps and neighborhood graph computation. The resulting preprocessed data matrix is returned as an annotated data matrix.\n\nParameters:\n    adata (AnnData): An annotated data matrix.\n\nReturns:\n    AnnData: An annotated data matrix containing the preprocessed data.\n\nAPIs used:\n    - Diffusion maps [Coifman05]_ [Haghverdi15]_\n    - Compute a neighborhood graph of observations [Wolf19]_",
            "description":"Apply a simple preprocessing recipe to the provided annotated data matrix.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "preprocess_diffmap_neighbors(adata=$)"
            ]
        },
        "transform_log_scale_adata": {
            "relevant APIs": [
                "scanpy.pp.log1p",
                "scanpy.pp.scale"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "An annotated data matrix."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "An annotated data matrix after applying logarithmization and scaling."
            },
            "Docstring":"Apply logarithm transformation and standard scaling to the input annotated data matrix.\n\nParameters:\nadata ('AnnData'): An annotated data matrix.\n\nReturns:\n'AnnData': An annotated data matrix after applying logarithmization and scaling.\n\nUse the full raw data for visualization.",
            "description":"Apply logarithm transformation and standard scaling to the input annotated data matrix.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "transform_log_scale_adata(adata=$)"
            ]
        },
        "combine_plots_dot_stacked_matrix": {
            "relevant APIs": [
                "scanpy.pl.dotplot",
                "scanpy.pl.stacked_violin",
                "scanpy.pl.matrixplot"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "An annotated data matrix."
                },
                "var_names": {
                    "type": "list",
                    "default": null,
                    "optional": false,
                    "description": "List of gene names."
                },
                "groupby": {
                    "type": "str",
                    "default": null,
                    "optional": false,
                    "description": "The key of the observation grouping to consider."
                }
            },
            "Returns": {
                "type": "tuple",
                "description": "A tuple containing three dictionaries. Each dictionary corresponds to one of the plots: Dot plot of expression values, Stacked Violin plot, and Matrix plot."
            },
            "Docstring":"Combine Dot, Stacked Violin, and Matrix plots for visualizing expression values.\n\nGenerate and combine three types of plots (Dot plot, Stacked Violin plot, and Matrix plot) for visualizing expression values in the provided annotated data matrix, considering the given gene names and observation grouping.\n\nParameters:\n    adata ('AnnData'): An annotated data matrix.\n    var_names (list): List of gene names.\n    groupby (str): The key of the observation grouping to consider.\n\nReturns:\n    tuple: A tuple containing three dictionaries. Each dictionary corresponds to one of\n           the plots: Dot plot of expression values, Stacked Violin plot, and Matrix plot.\n\nExample:\n    Combining plots in subplots. An axis can be passed to a plot to combine multiple outputs as in the following example.",
            "description":"Combine Dot, Stacked Violin, and Matrix plots for visualizing expression values.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "combine_plots_dot_stacked_matrix(adata=$, var_names=@, groupby=@)"
            ]
        },
        "embed_umap_and_plot_paga": {
            "relevant APIs": [
                "scanpy.pl.umap",
                "scanpy.pl.paga"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "An annotated data matrix."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "An annotated data matrix with PAGA dot centers set to the mean of the UMAP embedding values of cells from corresponding groups."
            },
            "Docstring":"Embeds the neighborhood graph using UMAP [McInnes18]_ and plots the PAGA graph by thresholding low-connectivity edges.\n\nParameters:\nadata ('AnnData'): An annotated data matrix.\n\nReturns:\n'AnnData': An annotated data matrix with PAGA dot centers set to the mean of the UMAP embedding values of cells from corresponding groups.\n\nDescription:\nPAGA layout corresponding to UMAP. This function sets PAGA dot centers to the mean of the UMAP embedding values of cells from the corresponding groups.\n\nReferences:\n.. [McInnes18] McInnes, L., Healy, J., Saul, N., & Grossberger, L. (2018).\n   UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction.\n   arXiv preprint arXiv:1802.03426.",
            "description":"Embeds the neighborhood graph using UMAP [McInnes18]_ and plots the PAGA graph by thresholding low-connectivity edges.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "embed_umap_and_plot_paga(adata=$)"
            ]
        },
        "batch_effect_umap_reduction": {
            "relevant APIs": [
                "scanpy.pp.pca",
                "scanpy.pp.neighbors",
                "scanpy.tl.umap",
                "scanpy.pl.umap"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "An annotated data matrix."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "An annotated data matrix with reduced batch effects."
            },
            "Docstring":"Perform dimension embedding and visualization to address batch effects in the data.\n\nThis function takes an annotated data matrix as input and utilizes principal component analysis, neighborhood graph computation, UMAP embedding, and scatter plot visualization to mitigate batch effects. The function returns an annotated data matrix with reduced batch effects.\n\nParameters:\nadata ('AnnData'): An annotated data matrix.\n\nReturns:\n'AnnData': An annotated data matrix with reduced batch effects.\n\nNote:\nSeeing the batch effect, the function employs dimension reduction techniques and visualization to mitigate the observed batch effect.\n\nReferences:\n- [Pedregosa11] Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., ... & Vanderplas, J.\n  (2011). Scikit-learn: Machine learning in Python. Journal of Machine Learning Research, 12(Oct), 2825-2830.\n- [Wolf19] Wolf, F. A., Angerer, P., & Theis, F. J. (2019). SCANPY: Large-scale single-cell gene\n  expression data analysis. Genome biology, 20(1), 1-14.\n- [McInnes18] McInnes, L., Healy, J., & Melville, J. (2018). UMAP: Uniform manifold approximation\n  and projection for dimension reduction. arXiv preprint arXiv:1802.03426.",
            "description":"Perform dimension embedding and visualization to address batch effects in the data.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "batch_effect_umap_reduction(adata=$)"
            ]
        },
        "integrate_embed_visualize_data": {
            "relevant APIs": [
                "scanpy.external.pp.bbknn",
                "scanpy.tl.umap",
                "scanpy.pl.umap"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "Annotated data matrix containing single-cell gene expression data."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "Annotated data matrix after integration and visualization."
            },
            "Docstring": "Perform data integration and visualization.\n\nThis function takes an annotated data matrix `adata` as input and performs the following steps:\n1. Correct batch effects by adjusting mutual KNN graphs using BBKNN.\n2. Embed the neighborhood graph using UMAP [McInnes18]_.\n3. Generate a scatter plot of observations.\n\nParameters:\nadata ('AnnData'): An annotated data matrix.\n\nReturns:\n'AnnData': An annotated data matrix after integration and visualization.\n\nNote: The function utilizes the BBKNN algorithm for batch effect correction and UMAP for dimensionality reduction. For more iterative integration from a single reference dataset, the function also supports the use of ingest.\n\nReferences:\n[McInnes18] McInnes, L., Healy, J., Saul, N., & Groberger, L. (2018). UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction.\n\n[Polanski19] Polaski, K., Young, M. D., Miao, Z., Meyer, K. B., & Teichmann, S. A. (2019). BBKNN: fast batch alignment of single cell transcriptomes.",
            "description": "Perform data integration and visualization.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "integrate_embed_visualize_data(adata=$)"
            ]
        },
        "compute_visualize_embedding_density": {
            "relevant APIs": [
                "scanpy.tl.embedding_density",
                "scanpy.pl.embedding_density"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "Annotated data matrix."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "Annotated data matrix with computed density estimate."
            },
            "Docstring": "Compute and visualize the density estimate of embeddings across batches.\n\nThis function takes an annotated data matrix as input and computes a density estimatefor the embeddings. It then plots the density estimate to visualize distributions across batches, where batches often correspond to experiments that one aims to compare.\n\nParameters:\nadata (AnnData): An annotated data matrix.\n\nReturns:\nAnnData: An annotated data matrix with the computed density estimate.",
            "description": "Compute and visualize the density estimate of embeddings across batches.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "compute_visualize_embedding_density(adata=$)"
            ]
        },
        "filter_qc_cells_genes": {
            "relevant APIs": [
                "scanpy.pp.filter_cells",
                "scanpy.pp.filter_genes"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "Annotated data matrix."
                },
                "min_counts": {
                    "type": "int",
                    "default": null,
                    "optional": false,
                    "description": "Minimum number of counts required."
                },
                "max_counts": {
                    "type": "int",
                    "default": null,
                    "optional": false,
                    "description": "Maximum number of counts allowed."
                },
                "min_cells": {
                    "type": "int",
                    "default": null,
                    "optional": false,
                    "description": "Minimum number of cells in which a gene must be expressed."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "Annotated data matrix with filtered cells and genes."
            },
            "Docstring": "Perform quality control and preprocessing on an annotated data matrix.\n\nThis function filters spots in the input annotated data matrix based on total counts and expressed genes.\n\nParameters:\nadata ('AnnData'): An annotated data matrix.\nmin_counts (int): Minimum number of counts required.\nmax_counts (int): Maximum number of counts allowed.\nmin_cells (int): Minimum number of cells in which a gene must be expressed.\n\nReturns:\n'AnnData': An annotated data matrix with spots filtered based on counts and gene expression.\n\nNote: This function uses APIs for filtering cell outliers and genes based on counts and cell expression.",
            "description": "Perform quality control and preprocessing on an annotated data matrix.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "filter_qc_cells_genes(adata=$, min_counts=@, max_counts=@, min_cells=@)"
            ]
        },
        "normalize_and_detect_hvg": {
            "relevant APIs": [
                "scanpy.pp.normalize_total",
                "scanpy.pp.log1p",
                "scanpy.pp.highly_variable_genes"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "Annotated data matrix containing single-cell gene expression data."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "Annotated data matrix with normalized counts and identified highly-variable genes."
            },
            "Docstring": "Normalize the input annotated data matrix using the built-in normalize_total method from Scanpy, and detect highly-variable genes for later analysis.\n\nParameters:\nadata (AnnData): An annotated data matrix.\n\nReturns:\nAnnData: An annotated data matrix with normalized counts and identified highly-variable genes.\n\nDescription:\nThis function employs the Scanpy library's built-in normalize_total method to perform data normalization on the input 'adata'. Additionally, it identifies highly-variable genes within the normalized data, which will be utilized for subsequent analysis.\n\nAPI References:\n- API1: Normalize data per cell (Scanpy)\n- API3: Annotate highly variable genes [Satija15], [Zheng17]",
            "description": "Normalize the input annotated data matrix using the built-in normalize_total method from Scanpy, and detect highly-variable genes for later analysis.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "normalize_and_detect_hvg(adata=$)"
            ]
        },
        "transcriptional_manifold_clustering": {
            "relevant APIs": [
                "scanpy.pp.pca",
                "scanpy.pp.neighbors",
                "scanpy.tl.umap",
                "scanpy.tl.leiden"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "Annotated data matrix containing single-cell gene expression data."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "Annotated data matrix after manifold embedding and clustering."
            },
            "Docstring": "Perform manifold embedding and clustering based on transcriptional similarity.\n\nThis function takes an annotated data matrix as input and performs the following steps:\n1. Principal Component Analysis (PCA) to reduce dimensionality.\n2. Computation of a neighborhood graph of observations.\n3. Embedding of the neighborhood graph using UMAP.\n4. Clustering of cells into subgroups.\n\nParameters:\nadata (AnnData): An annotated data matrix.\n\nReturns:\nAnnData: An annotated data matrix containing the results of the manifold embedding and clustering.\n\nNote: This process is based on standard clustering techniques and utilizes various APIs for PCA, neighborhood graph\ncomputation, UMAP embedding, and cell clustering. Refer to the respective literature for details on the APIs.\n\nReferences:\n- [Pedregosa11] Pedregosa, F. et al. Scikit-learn: Machine Learning in Python. JMLR 12, 2825-2830 (2011).\n- [Wolf19] Wolf, F.A. et al. Graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells. bioRxiv, 691062 (2019).\n- [McInnes18] McInnes, L., Healy, J., & Melville, J. UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. arXiv preprint arXiv:1802.03426 (2018).\n- [Levine15] Levine, J.H. et al. Data-Driven Phenotypic Dissection of AML Reveals Progenitor-like Cells that Correlate with Prognosis. Cell 162, 184-197 (2015).\n- [Traag17] Traag, V.A., Waltman, L., & van Eck, N.J. From Louvain to Leiden: guaranteeing well-connected communities. Scientific Reports 9, 5233 (2019).",
            "description": "Perform manifold embedding and clustering based on transcriptional similarity.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "transcriptional_manifold_clustering(adata=$)"
            ]
        },
        "process_normalize_log_pca_embed": {
            "relevant APIs": [
                "scanpy.pp.normalize_per_cell",
                "scanpy.pp.log1p",
                "scanpy.pp.pca",
                "scanpy.pp.neighbors",
                "scanpy.tl.umap",
                "scanpy.tl.leiden"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "Annotated data matrix containing single-cell gene expression data."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "Annotated data matrix after preprocessing and dimensionality reduction."
            },
            "Docstring": "Preprocesses and reduces dimensionality of the input annotated data matrix.\n\nThis function takes an annotated data matrix as input and performs standard preprocessing steps, including normalizing each cell by total counts over genes, logarithmizing the data matrix, and applying Principal Component Analysis (PCA). It then computes a neighborhood graph of observations using a specified API and embeds the graph using UMAP. Finally, it clusters cells into subgroups based on their gene expression profiles.\n\nParameters:\nadata ('AnnData'): An annotated data matrix representing gene expression counts from single cells.\n\nReturns:\n'AnnData': An annotated data matrix after preprocessing and dimensionality reduction.\n\nNote:\nThe experiment involved measuring gene expression counts from cultured U2-OS cells. The clusters obtained correspond to different stages of the cell cycle.",
            "description": "Preprocesses and reduces dimensionality of the input annotated data matrix.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "process_normalize_log_pca_embed(adata=$)"
            ]
        },
        "visualize_leiden_clusters_umap_spatial": {
            "relevant APIs": [
                "scanpy.pl.umap",
                "scanpy.pl.embedding"
            ],
            "type": "compositeAPI",
            "Parameters": {
                "adata": {
                    "type": "AnnData",
                    "default": null,
                    "optional": false,
                    "description": "Annotated data matrix containing single-cell gene expression data."
                }
            },
            "Returns": {
                "type": "AnnData",
                "description": "Annotated data matrix with clusters visualized in UMAP and spatial coordinates."
            },
            "Docstring": "Visualizes clusters obtained from running Leiden in UMAP space and spatial coordinates.\n\nParameters:\nadata ('AnnData'): An annotated data matrix.\n\nReturns:\n'AnnData': An annotated data matrix with clusters visualized in UMAP and spatial coordinates.\n\nExample:\ninvisible_function(adata)\n\nWe can visualize the clusters obtained from running Leiden in UMAP space and spatial coordinates using this function.",
            "description": "Visualizes clusters obtained from running Leiden in UMAP space and spatial coordinates.",
            "example": "",
            "api_type": "function",
            "api_calling": [
                "visualize_leiden_clusters_umap_spatial(adata=$)"
            ]
        }
}